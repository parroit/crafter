function module_preamble() {
    var loadedModules = {};
    var modulesFactories = {};
    define_modules();
    
    function define_modules() {
        _define(0, function (module, exports) {
            'use strict';
            var vinylFs = require(13);
            var duplexer2 = require(15);
            var repipeRequirement = require(1).repipe;
            var modulesBuilder = require(2);
            var codeGenerator = require(3);
            var astBodyConcat = require(4);
            var functionWrapper = require(5);
            var astParser = require(7);
            var astVisitor = require(8);
            var requireFinder = require(9);
            var fallup = require(10);
            var assignId = require(11);
            var replaceRequires = require(12);
            function reportThroughError(through) {
                return function (err) {
                    console.log(through._transform ? 'Error occurred in function ' + through._transform.name : 'Error occurred ' + ' in file ' + err.file.path);
                    console.warn(err.stack);
                };
            }
            function createPipeset(throughStreams) {
                var writable = throughStreams[0];
                var streamIdx = 1;
                var current = writable;
                var readable;
                for (; streamIdx < throughStreams.length; streamIdx++) {
                    var through = throughStreams[streamIdx];
                    through.on('error', reportThroughError(through));
                    current = current.pipe(through);
                }
                readable = current;
                return duplexer2(writable, readable);
            }
            exports.bundle = function bundle(options) {
                if (typeof options === 'string' || typeof options === 'undefined') {
                    options = { target: options };
                }
                options.target = options.target || 'index.js';
                options.exports = options.exports || [];
                var throughStreams = [
                    modulesBuilder(),
                    fallup(),
                    astParser(options.exports.parsers),
                    astVisitor(requireFinder),
                    repipeRequirement(vinylFs),
                    assignId(),
                    replaceRequires(),
                    functionWrapper(),
                    astBodyConcat(options.target, options.exports),
                    codeGenerator()
                ];
                return createPipeset(throughStreams);
            };
        });
        _define(1, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var duplexer2 = require(15);
            var astParser = require(7);
            var astVisitor = require(8);
            var requireFinder = require(9);
            var fallup = require(10);
            function repipeRequirement(adapter) {
                var builder;
                return through2.obj(function loadRequired(file, enc, next) {
                    if (!file.requires) {
                        this.push(file);
                        return next();
                    }
                    if (!builder) {
                        builder = file.builder;
                    }
                    if (!file.builder) {
                        file.builder = builder;
                    }
                    var relatives = Object.keys(file.requires.relatives).map(function (filePath) {
                        return file.requires.relatives[filePath];
                    });
                    var dependencies = Object.keys(file.requires.dependencies).map(function (filePath) {
                        return file.requires.dependencies[filePath];
                    });
                    var allDeps = relatives.concat(dependencies).filter(function (filePath) {
                        return Object.keys(builder.modules).indexOf(filePath) === -1;
                    });
                    builder.resolved[file.path.replace(/\\/g, '/')] = true;
                    if (allDeps.length) {
                        allDeps.forEach(function (dep) {
                            builder.modules[dep.replace(/\\/g, '/')] = true;
                        });
                        adapter.src(allDeps, { base: file.base }).pipe(file.fallup, { end: false });
                    } else {
                        if (!builder.needResolve()) {
                            file.fallup.end();
                        }
                    }
                    this.push(file);
                    return next();
                });
            }
            function includeRequirements(adapter) {
                var writable = fallup();
                var readable = writable.pipe(astParser()).pipe(astVisitor(requireFinder)).pipe(repipeRequirement(adapter));
                return duplexer2(writable, readable);
            }
            includeRequirements.repipe = repipeRequirement;
            module.exports = includeRequirements;
        });
        _define(2, function (module, exports) {
            'use strict';
            var through2 = require(6);
            function modulesBuilder() {
                var builder = {
                    rootModules: {},
                    modules: {},
                    resolved: {},
                    needResolve: function () {
                        var resolvedKeys = Object.keys(builder.resolved);
                        var moduleKeys = Object.keys(builder.modules);
                        var toResoveKeys = moduleKeys.filter(function (module) {
                            return resolvedKeys.indexOf(module) === -1;
                        });
                        return toResoveKeys.length > 0;
                    }
                };
                return through2.obj(function visit(file, enc, next) {
                    if (file.isNull()) {
                        this.push(file);
                        return next();
                    }
                    if (file.isStream()) {
                        this.emit('error', new Error('Streaming not supported'));
                        return next();
                    }
                    var dep = file.path.replace(/\\/g, '/');
                    builder.rootModules[dep] = true;
                    builder.modules[dep] = true;
                    file.builder = builder;
                    this.push(file);
                    return next();
                });
            }
            module.exports = modulesBuilder;
        });
        _define(3, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var walk = require(16);
            var escodegen = require(14);
            function codeGenerator() {
                return through2.obj(function visit(file, enc, next) {
                    if (file.isNull()) {
                        this.push(file);
                        return next();
                    }
                    if (file.isStream()) {
                        this.emit('error', new Error('Streaming not supported'));
                        return next();
                    }
                    try {
                        var code = escodegen.generate(file.ast);
                        file.contents = new Buffer(code);
                        this.push(file);
                        return next();
                    } catch (err) {
                        this.emit('error', err);
                        return next();
                    }
                });
            }
            module.exports = codeGenerator;
        });
        _define(4, function (module, exports) {
            'use strict';
            var astVisitor = require(8);
            var requireFinder = require(9);
            var estemplate = require(17);
            var through = require(18);
            var fs = require('fs');
            var File = require(19);
            var cachedTemplate = null;
            var escodegen = require(14);
            var path = require('path');
            var acorn = require(20);
            module.exports = function (targetPath, exports) {
                var modules = [];
                var builder;
                var exportsIds = {};
                exports = exports || [];
                return through(function write(file) {
                    if (file.isNull()) {
                        this.queue(file);
                        return;
                    }
                    if (file.isStream()) {
                        this.emit('error', new Error('Streaming not supported'));
                        return;
                    }
                    if (file.builder && !builder) {
                        builder = file.builder;
                    }
                    var relativePath = path.relative(file.base, file.path);
                    if (Object.keys(exports).indexOf(relativePath) !== -1) {
                        exportsIds[path.basename(relativePath)] = {
                            id: file.id,
                            name: exports[relativePath]
                        };
                    }
                    [].push.apply(modules, file.ast.body);
                }, function end() {
                    var stream = this;
                    if (cachedTemplate) {
                        applyTemplate(cachedTemplate);
                    } else {
                        fs.readFile(__dirname + '/body-concat.jst', 'utf8', function (err, data) {
                            cachedTemplate = data;
                            applyTemplate(cachedTemplate);
                        });
                    }
                    function applyTemplate(template) {
                        try {
                            var file = new File({ path: targetPath });
                            file.builder = builder;
                            var exportCode = '';
                            var exportsKeys = Object.keys(exportsIds);
                            if (exportsKeys === 0) {
                                exportCode = 'return undefined;';
                            } else if (exportsKeys.length > 1 || exportsIds[exportsKeys[0]] && exportsIds[exportsKeys[0]].name !== null) {
                                exportCode = 'return {' + exportsKeys.map(function (key) {
                                    var mod = exportsIds[key];
                                    return '\'' + mod.name + '\': require(' + mod.id + ');';
                                }).join(',\n') + '};';
                            } else if (exportsKeys.length === 1) {
                                var mod = exportsIds[exportsKeys[0]];
                                exportCode = 'return require(' + mod.id + ');';
                            }
                            var outputName = path.basename(targetPath, path.extname(targetPath));
                            file.ast = estemplate(template, {
                                modules: modules,
                                exportCode: acorn.parse(exportCode, { allowReturnOutsideFunction: true }),
                                outputName: outputName
                            });
                            file.contents = new Buffer(escodegen.generate(file.ast));
                            stream.queue(file);
                            stream.queue(null);
                        } catch (err) {
                            err.file = file;
                            stream.emit('error', err);
                        }
                    }
                });
            };
        });
        _define(5, function (module, exports) {
            'use strict';
            var astVisitor = require(8);
            var requireFinder = require(9);
            var estemplate = require(17);
            var through2 = require(6);
            var fs = require('fs');
            var templateCache = null;
            module.exports = function () {
                return through2.obj(function visit(file, enc, next) {
                    var stream = this;
                    if (file.isNull()) {
                        stream.push(file);
                        return next();
                    }
                    if (file.isStream()) {
                        stream.emit('error', new Error('Streaming not supported'));
                        return next();
                    }
                    function applyTemplate(template) {
                        file.ast = estemplate(template, file);
                        stream.push(file);
                        return next();
                    }
                    if (templateCache !== null) {
                        applyTemplate(templateCache);
                    } else {
                        fs.readFile(__dirname + '/function-define.jst', 'utf8', function (err, data) {
                            templateCache = data;
                            applyTemplate(templateCache);
                        });
                    }
                });
            };
        });
        _define(6, function (module, exports) {
            var Transform = require(21), inherits = require('util').inherits, xtend = require(22);
            function DestroyableTransform(opts) {
                Transform.call(this, opts);
                this._destroyed = false;
            }
            inherits(DestroyableTransform, Transform);
            DestroyableTransform.prototype.destroy = function (err) {
                if (this._destroyed)
                    return;
                this._destroyed = true;
                var self = this;
                process.nextTick(function () {
                    if (err)
                        self.emit('error', err);
                    self.emit('close');
                });
            };
            function noop(chunk, enc, callback) {
                callback(null, chunk);
            }
            function through2(construct) {
                return function (options, transform, flush) {
                    if (typeof options == 'function') {
                        flush = transform;
                        transform = options;
                        options = {};
                    }
                    if (typeof transform != 'function')
                        transform = noop;
                    if (typeof flush != 'function')
                        flush = null;
                    return construct(options, transform, flush);
                };
            }
            module.exports = through2(function (options, transform, flush) {
                var t2 = new DestroyableTransform(options);
                t2._transform = transform;
                if (flush)
                    t2._flush = flush;
                return t2;
            });
            module.exports.ctor = through2(function (options, transform, flush) {
                function Through2(override) {
                    if (!(this instanceof Through2))
                        return new Through2(override);
                    this.options = xtend(options, override);
                    DestroyableTransform.call(this, this.options);
                }
                inherits(Through2, DestroyableTransform);
                Through2.prototype._transform = transform;
                if (flush)
                    Through2.prototype._flush = flush;
                return Through2;
            });
            module.exports.obj = through2(function (options, transform, flush) {
                var t2 = new DestroyableTransform(xtend({
                    objectMode: true,
                    highWaterMark: 16
                }, options));
                t2._transform = transform;
                if (flush)
                    t2._flush = flush;
                return t2;
            });
        });
        _define(7, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var acorn = require(20);
            var path = require('path');
            function parseJs(code, options) {
                return acorn.parse(code, { locations: options.loc });
            }
            function parseJSON(code, options) {
                return acorn.parse('module.exports = ' + code + ';', { locations: options.loc });
            }
            function astParser(options) {
                options = options || { loc: true };
                options.loc = 'loc' in options ? options.loc : true;
                options.parsers = options.parsers || {
                    js: parseJs,
                    json: parseJSON
                };
                options.parsers.js = options.parsers.js || parseJs;
                options.parsers.parseJSON = options.parsers.parseJSON || parseJSON;
                return through2.obj(function visit(file, enc, next) {
                    if (file.isNull()) {
                        this.push(file);
                        return next();
                    }
                    if (file.isStream()) {
                        this.emit('error', new Error('Streaming not supported'));
                        return next();
                    }
                    try {
                        var code = file.contents.toString(enc);
                        var ext = path.extname(file.path).slice(1);
                        if (ext in options.parsers) {
                            file.ast = options.parsers[ext](code, options);
                            this.push(file);
                            return next();
                        } else {
                            throw new Error('Unsupported file extension:' + ext + ' for file ' + file.path);
                        }
                    } catch (err) {
                        console.dir(file);
                        err.file = file;
                        this.emit('error', err);
                        return next();
                    }
                });
            }
            module.exports = astParser;
        });
        _define(8, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var walk = require(16);
            var Promise = require(23);
            function astVisitor(visitors) {
                if (typeof visitors === 'function') {
                    visitors = [visitors];
                }
                return through2.obj(function visit(file, enc, next) {
                    var _this = this;
                    if (file.isNull()) {
                        _this.push(file);
                        return next();
                    }
                    if (file.isStream()) {
                        _this.emit('error', new Error('Streaming not supported'));
                        return next();
                    }
                    try {
                        visitors.forEach(function (visitor) {
                            walk(file.ast, visitor.bind(file));
                        });
                        if (file.results) {
                            Promise.all(file.results).then(function () {
                                _this.push(file);
                                file.results = null;
                                return next();
                            }).catch(function (err) {
                                _this.emit('error', err);
                                return next();
                            });
                        } else {
                            _this.push(file);
                            return next();
                        }
                    } catch (err) {
                        _this.emit('error', err);
                        return next();
                    }
                });
            }
            module.exports = astVisitor;
        });
        _define(9, function (module, exports) {
            'use strict';
            var resolve = require(24);
            var path = require('path');
            var Promise = require(23);
            function astRequireFinder(options) {
                return function (node) {
                    var file = this;
                    if (!file.requires) {
                        file.requires = {
                            core: {},
                            relatives: {},
                            dependencies: {}
                        };
                    }
                    if (!file.results) {
                        file.results = [];
                    }
                    if (node.type === 'CallExpression' && node.callee.name === 'require') {
                        var modulePath = node.arguments[0].value;
                        if (resolve.isCore(modulePath)) {
                            if (modulePath in options.core && options.core[modulePath] !== 'ignore') {
                                modulePath = options.core[modulePath];
                            } else {
                                file.requires.core[modulePath] = true;
                                if (options.core[modulePath] !== 'ignore') {
                                    var relPath = path.relative(file.base, file.path);
                                    relPath = relPath.replace(/\\?node_modules\\/g, '->');
                                    var msg = 'Not configured core module ' + modulePath + ' at ' + relPath + ':' + node.loc.start.line + '[' + node.loc.start.column + ',' + node.loc.end.column + ']';
                                    console.warn(msg);
                                }
                                return;
                            }
                        }
                        var opts = { basedir: path.dirname(file.path) };
                        var result = new Promise(function (resolvePromise, rejectPromise) {
                            resolve(modulePath, opts, function (err, res) {
                                if (err) {
                                    return resolvePromise(err);
                                }
                                res = res.replace(/\\/g, '/');
                                node.resolvedPath = res;
                                if (modulePath[0] === '.') {
                                    file.requires.relatives[modulePath] = res;
                                } else {
                                    file.requires.dependencies[modulePath] = res;
                                }
                                resolvePromise(res);
                            });
                        });
                        file.results.push(result);
                    }
                };
            }
            module.exports = astRequireFinder({ core: {} });
            module.exports.withOptions = astRequireFinder;
        });
        _define(10, function (module, exports) {
            'use strict';
            var through = require(18);
            var through2 = require(6);
            var PassThrough = require('stream').PassThrough;
            var duplexer = require(15);
            var merge = require(25);
            var Readable = require('stream').Readable;
            var Writable = require('stream').Writable;
            function fallup() {
                var fallupStream = new PassThrough({ objectMode: true });
                var input = new PassThrough({ objectMode: true });
                fallupStream.available = true;
                fallupStream.destroy = function () {
                    fallupStream.available = false;
                };
                fallupStream.on('finish', function () {
                    fallupStream.available = false;
                });
                fallupStream.available = true;
                var output = through2.obj(function streamRewind(file, enc, next) {
                    file.fallup = fallupStream;
                    this.push(file);
                    return next();
                });
                merge(input, fallupStream).pipe(output);
                return duplexer(input, output);
            }
            module.exports = fallup;
        });
        _define(11, function (module, exports) {
            'use strict';
            var through = require(18);
            module.exports = assignModuleId;
            function assignModuleId() {
                var id = 0;
                var allFiles = [];
                return through(function write(file) {
                    if (file.isNull()) {
                        this.push(file);
                        return;
                    }
                    if (file.isStream()) {
                        this.emit('error', new Error('Streaming not supported'));
                        return;
                    }
                    var builder = file.builder;
                    var filePath = file.path.replace(/\\/g, '/');
                    if (!(filePath in builder.modules)) {
                        this.emit('error', new Error('Not loaded in modules: ', filePath));
                        return;
                    }
                    file.id = id++;
                    builder.modules[filePath] = file.id;
                    allFiles.push(file);
                    return;
                }, function end() {
                    var _this = this;
                    allFiles.forEach(function (file) {
                        _this.queue(file);
                    });
                    _this.queue(null);
                });
            }
        });
        _define(12, function (module, exports) {
            'use strict';
            var astVisitor = require(8);
            var requireFinder = require(9);
            function astRequiresReplacer(node) {
                var file = this;
                if (!file.requires) {
                    file.requires = {
                        core: {},
                        relatives: {},
                        dependencies: {}
                    };
                }
                if (!file.results) {
                    file.results = [];
                }
                if (node.type === 'CallExpression' && node.callee.name === 'require') {
                    if (!(node.resolvedPath in file.builder.modules)) {
                        return;
                    }
                    node.arguments[0].value = file.builder.modules[node.resolvedPath];
                }
            }
            module.exports = function () {
                return astVisitor(astRequiresReplacer);
            };
        });
        _define(13, function (module, exports) {
            'use strict';
            module.exports = {
                src: require(26),
                dest: require(27),
                watch: require(28)
            };
        });
        _define(14, function (module, exports) {
            (function () {
                'use strict';
                var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, FORMAT_MINIFY, FORMAT_DEFAULTS;
                estraverse = require(30);
                esutils = require(31);
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    ArrayPattern: 'ArrayPattern',
                    ArrowFunctionExpression: 'ArrowFunctionExpression',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ClassBody: 'ClassBody',
                    ClassDeclaration: 'ClassDeclaration',
                    ClassExpression: 'ClassExpression',
                    ComprehensionBlock: 'ComprehensionBlock',
                    ComprehensionExpression: 'ComprehensionExpression',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExportBatchSpecifier: 'ExportBatchSpecifier',
                    ExportDeclaration: 'ExportDeclaration',
                    ExportSpecifier: 'ExportSpecifier',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    ForOfStatement: 'ForOfStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    GeneratorExpression: 'GeneratorExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    ImportSpecifier: 'ImportSpecifier',
                    ImportDeclaration: 'ImportDeclaration',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    MethodDefinition: 'MethodDefinition',
                    ModuleDeclaration: 'ModuleDeclaration',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    ObjectPattern: 'ObjectPattern',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SpreadElement: 'SpreadElement',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    TaggedTemplateExpression: 'TaggedTemplateExpression',
                    TemplateElement: 'TemplateElement',
                    TemplateLiteral: 'TemplateLiteral',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement',
                    YieldExpression: 'YieldExpression'
                };
                function isExpression(node) {
                    switch (node.type) {
                    case Syntax.AssignmentExpression:
                    case Syntax.ArrayExpression:
                    case Syntax.ArrayPattern:
                    case Syntax.BinaryExpression:
                    case Syntax.CallExpression:
                    case Syntax.ConditionalExpression:
                    case Syntax.ClassExpression:
                    case Syntax.ExportBatchSpecifier:
                    case Syntax.ExportSpecifier:
                    case Syntax.FunctionExpression:
                    case Syntax.Identifier:
                    case Syntax.ImportSpecifier:
                    case Syntax.Literal:
                    case Syntax.LogicalExpression:
                    case Syntax.MemberExpression:
                    case Syntax.MethodDefinition:
                    case Syntax.NewExpression:
                    case Syntax.ObjectExpression:
                    case Syntax.ObjectPattern:
                    case Syntax.Property:
                    case Syntax.SequenceExpression:
                    case Syntax.ThisExpression:
                    case Syntax.UnaryExpression:
                    case Syntax.UpdateExpression:
                    case Syntax.YieldExpression:
                        return true;
                    }
                    return false;
                }
                function isStatement(node) {
                    switch (node.type) {
                    case Syntax.BlockStatement:
                    case Syntax.BreakStatement:
                    case Syntax.CatchClause:
                    case Syntax.ContinueStatement:
                    case Syntax.ClassDeclaration:
                    case Syntax.ClassBody:
                    case Syntax.DirectiveStatement:
                    case Syntax.DoWhileStatement:
                    case Syntax.DebuggerStatement:
                    case Syntax.EmptyStatement:
                    case Syntax.ExpressionStatement:
                    case Syntax.ForStatement:
                    case Syntax.ForInStatement:
                    case Syntax.ForOfStatement:
                    case Syntax.FunctionDeclaration:
                    case Syntax.IfStatement:
                    case Syntax.LabeledStatement:
                    case Syntax.ModuleDeclaration:
                    case Syntax.Program:
                    case Syntax.ReturnStatement:
                    case Syntax.SwitchStatement:
                    case Syntax.SwitchCase:
                    case Syntax.ThrowStatement:
                    case Syntax.TryStatement:
                    case Syntax.VariableDeclaration:
                    case Syntax.VariableDeclarator:
                    case Syntax.WhileStatement:
                    case Syntax.WithStatement:
                        return true;
                    }
                    return false;
                }
                Precedence = {
                    Sequence: 0,
                    Yield: 1,
                    Assignment: 1,
                    Conditional: 2,
                    ArrowFunction: 2,
                    LogicalOR: 3,
                    LogicalAND: 4,
                    BitwiseOR: 5,
                    BitwiseXOR: 6,
                    BitwiseAND: 7,
                    Equality: 8,
                    Relational: 9,
                    BitwiseSHIFT: 10,
                    Additive: 11,
                    Multiplicative: 12,
                    Unary: 13,
                    Postfix: 14,
                    Call: 15,
                    New: 16,
                    TaggedTemplate: 17,
                    Member: 18,
                    Primary: 19
                };
                BinaryPrecedence = {
                    '||': Precedence.LogicalOR,
                    '&&': Precedence.LogicalAND,
                    '|': Precedence.BitwiseOR,
                    '^': Precedence.BitwiseXOR,
                    '&': Precedence.BitwiseAND,
                    '==': Precedence.Equality,
                    '!=': Precedence.Equality,
                    '===': Precedence.Equality,
                    '!==': Precedence.Equality,
                    'is': Precedence.Equality,
                    'isnt': Precedence.Equality,
                    '<': Precedence.Relational,
                    '>': Precedence.Relational,
                    '<=': Precedence.Relational,
                    '>=': Precedence.Relational,
                    'in': Precedence.Relational,
                    'instanceof': Precedence.Relational,
                    '<<': Precedence.BitwiseSHIFT,
                    '>>': Precedence.BitwiseSHIFT,
                    '>>>': Precedence.BitwiseSHIFT,
                    '+': Precedence.Additive,
                    '-': Precedence.Additive,
                    '*': Precedence.Multiplicative,
                    '%': Precedence.Multiplicative,
                    '/': Precedence.Multiplicative
                };
                function getDefaultOptions() {
                    return {
                        indent: null,
                        base: null,
                        parse: null,
                        comment: false,
                        format: {
                            indent: {
                                style: '    ',
                                base: 0,
                                adjustMultilineComment: false
                            },
                            newline: '\n',
                            space: ' ',
                            json: false,
                            renumber: false,
                            hexadecimal: false,
                            quotes: 'single',
                            escapeless: false,
                            compact: false,
                            parentheses: true,
                            semicolons: true,
                            safeConcatenation: false
                        },
                        moz: {
                            comprehensionExpressionStartsWithAssignment: false,
                            starlessGenerator: false
                        },
                        sourceMap: null,
                        sourceMapRoot: null,
                        sourceMapWithCode: false,
                        directive: false,
                        raw: true,
                        verbatim: null
                    };
                }
                function stringRepeat(str, num) {
                    var result = '';
                    for (num |= 0; num > 0; num >>>= 1, str += str) {
                        if (num & 1) {
                            result += str;
                        }
                    }
                    return result;
                }
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                function hasLineTerminator(str) {
                    return /[\r\n]/g.test(str);
                }
                function endsWithLineTerminator(str) {
                    var len = str.length;
                    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
                }
                function updateDeeply(target, override) {
                    var key, val;
                    function isHashObject(target) {
                        return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
                    }
                    for (key in override) {
                        if (override.hasOwnProperty(key)) {
                            val = override[key];
                            if (isHashObject(val)) {
                                if (isHashObject(target[key])) {
                                    updateDeeply(target[key], val);
                                } else {
                                    target[key] = updateDeeply({}, val);
                                }
                            } else {
                                target[key] = val;
                            }
                        }
                    }
                    return target;
                }
                function generateNumber(value) {
                    var result, point, temp, exponent, pos;
                    if (value !== value) {
                        throw new Error('Numeric literal whose value is NaN');
                    }
                    if (value < 0 || value === 0 && 1 / value < 0) {
                        throw new Error('Numeric literal whose value is negative');
                    }
                    if (value === 1 / 0) {
                        return json ? 'null' : renumber ? '1e400' : '1e+400';
                    }
                    result = '' + value;
                    if (!renumber || result.length < 3) {
                        return result;
                    }
                    point = result.indexOf('.');
                    if (!json && result.charCodeAt(0) === 48 && point === 1) {
                        point = 0;
                        result = result.slice(1);
                    }
                    temp = result;
                    result = result.replace('e+', 'e');
                    exponent = 0;
                    if ((pos = temp.indexOf('e')) > 0) {
                        exponent = +temp.slice(pos + 1);
                        temp = temp.slice(0, pos);
                    }
                    if (point >= 0) {
                        exponent -= temp.length - point - 1;
                        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
                    }
                    pos = 0;
                    while (temp.charCodeAt(temp.length + pos - 1) === 48) {
                        --pos;
                    }
                    if (pos !== 0) {
                        exponent -= pos;
                        temp = temp.slice(0, pos);
                    }
                    if (exponent !== 0) {
                        temp += 'e' + exponent;
                    }
                    if ((temp.length < result.length || hexadecimal && value > 1000000000000 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {
                        result = temp;
                    }
                    return result;
                }
                function escapeRegExpCharacter(ch, previousIsBackslash) {
                    if ((ch & ~1) === 8232) {
                        return (previousIsBackslash ? 'u' : '\\u') + (ch === 8232 ? '2028' : '2029');
                    } else if (ch === 10 || ch === 13) {
                        return (previousIsBackslash ? '' : '\\') + (ch === 10 ? 'n' : 'r');
                    }
                    return String.fromCharCode(ch);
                }
                function generateRegExp(reg) {
                    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
                    result = reg.toString();
                    if (reg.source) {
                        match = result.match(/\/([^/]*)$/);
                        if (!match) {
                            return result;
                        }
                        flags = match[1];
                        result = '';
                        characterInBrack = false;
                        previousIsBackslash = false;
                        for (i = 0, iz = reg.source.length; i < iz; ++i) {
                            ch = reg.source.charCodeAt(i);
                            if (!previousIsBackslash) {
                                if (characterInBrack) {
                                    if (ch === 93) {
                                        characterInBrack = false;
                                    }
                                } else {
                                    if (ch === 47) {
                                        result += '\\';
                                    } else if (ch === 91) {
                                        characterInBrack = true;
                                    }
                                }
                                result += escapeRegExpCharacter(ch, previousIsBackslash);
                                previousIsBackslash = ch === 92;
                            } else {
                                result += escapeRegExpCharacter(ch, previousIsBackslash);
                                previousIsBackslash = false;
                            }
                        }
                        return '/' + result + '/' + flags;
                    }
                    return result;
                }
                function escapeAllowedCharacter(code, next) {
                    var hex, result = '\\';
                    switch (code) {
                    case 8:
                        result += 'b';
                        break;
                    case 12:
                        result += 'f';
                        break;
                    case 9:
                        result += 't';
                        break;
                    default:
                        hex = code.toString(16).toUpperCase();
                        if (json || code > 255) {
                            result += 'u' + '0000'.slice(hex.length) + hex;
                        } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {
                            result += '0';
                        } else if (code === 11) {
                            result += 'x0B';
                        } else {
                            result += 'x' + '00'.slice(hex.length) + hex;
                        }
                        break;
                    }
                    return result;
                }
                function escapeDisallowedCharacter(code) {
                    var result = '\\';
                    switch (code) {
                    case 92:
                        result += '\\';
                        break;
                    case 10:
                        result += 'n';
                        break;
                    case 13:
                        result += 'r';
                        break;
                    case 8232:
                        result += 'u2028';
                        break;
                    case 8233:
                        result += 'u2029';
                        break;
                    default:
                        throw new Error('Incorrectly classified character');
                    }
                    return result;
                }
                function escapeDirective(str) {
                    var i, iz, code, quote;
                    quote = quotes === 'double' ? '"' : '\'';
                    for (i = 0, iz = str.length; i < iz; ++i) {
                        code = str.charCodeAt(i);
                        if (code === 39) {
                            quote = '"';
                            break;
                        } else if (code === 34) {
                            quote = '\'';
                            break;
                        } else if (code === 92) {
                            ++i;
                        }
                    }
                    return quote + str + quote;
                }
                function escapeString(str) {
                    var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
                    for (i = 0, len = str.length; i < len; ++i) {
                        code = str.charCodeAt(i);
                        if (code === 39) {
                            ++singleQuotes;
                        } else if (code === 34) {
                            ++doubleQuotes;
                        } else if (code === 47 && json) {
                            result += '\\';
                        } else if (esutils.code.isLineTerminator(code) || code === 92) {
                            result += escapeDisallowedCharacter(code);
                            continue;
                        } else if (json && code < 32 || !(json || escapeless || code >= 32 && code <= 126)) {
                            result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                            continue;
                        }
                        result += String.fromCharCode(code);
                    }
                    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);
                    quote = single ? '\'' : '"';
                    if (!(single ? singleQuotes : doubleQuotes)) {
                        return quote + result + quote;
                    }
                    str = result;
                    result = quote;
                    for (i = 0, len = str.length; i < len; ++i) {
                        code = str.charCodeAt(i);
                        if (code === 39 && single || code === 34 && !single) {
                            result += '\\';
                        }
                        result += String.fromCharCode(code);
                    }
                    return result + quote;
                }
                function flattenToString(arr) {
                    var i, iz, elem, result = '';
                    for (i = 0, iz = arr.length; i < iz; ++i) {
                        elem = arr[i];
                        result += isArray(elem) ? flattenToString(elem) : elem;
                    }
                    return result;
                }
                function toSourceNodeWhenNeeded(generated, node) {
                    if (!sourceMap) {
                        if (isArray(generated)) {
                            return flattenToString(generated);
                        } else {
                            return generated;
                        }
                    }
                    if (node == null) {
                        if (generated instanceof SourceNode) {
                            return generated;
                        } else {
                            node = {};
                        }
                    }
                    if (node.loc == null) {
                        return new SourceNode(null, null, sourceMap, generated, node.name || null);
                    }
                    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
                }
                function noEmptySpace() {
                    return space ? space : ' ';
                }
                function join(left, right) {
                    var leftSource, rightSource, leftCharCode, rightCharCode;
                    leftSource = toSourceNodeWhenNeeded(left).toString();
                    if (leftSource.length === 0) {
                        return [right];
                    }
                    rightSource = toSourceNodeWhenNeeded(right).toString();
                    if (rightSource.length === 0) {
                        return [left];
                    }
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = rightSource.charCodeAt(0);
                    if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
                        return [
                            left,
                            noEmptySpace(),
                            right
                        ];
                    } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
                        return [
                            left,
                            right
                        ];
                    }
                    return [
                        left,
                        space,
                        right
                    ];
                }
                function addIndent(stmt) {
                    return [
                        base,
                        stmt
                    ];
                }
                function withIndent(fn) {
                    var previousBase, result;
                    previousBase = base;
                    base += indent;
                    result = fn.call(this, base);
                    base = previousBase;
                    return result;
                }
                function calculateSpaces(str) {
                    var i;
                    for (i = str.length - 1; i >= 0; --i) {
                        if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                            break;
                        }
                    }
                    return str.length - 1 - i;
                }
                function adjustMultilineComment(value, specialBase) {
                    var array, i, len, line, j, spaces, previousBase, sn;
                    array = value.split(/\r\n|[\r\n]/);
                    spaces = Number.MAX_VALUE;
                    for (i = 1, len = array.length; i < len; ++i) {
                        line = array[i];
                        j = 0;
                        while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                            ++j;
                        }
                        if (spaces > j) {
                            spaces = j;
                        }
                    }
                    if (typeof specialBase !== 'undefined') {
                        previousBase = base;
                        if (array[1][spaces] === '*') {
                            specialBase += ' ';
                        }
                        base = specialBase;
                    } else {
                        if (spaces & 1) {
                            --spaces;
                        }
                        previousBase = base;
                    }
                    for (i = 1, len = array.length; i < len; ++i) {
                        sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
                        array[i] = sourceMap ? sn.join('') : sn;
                    }
                    base = previousBase;
                    return array.join('\n');
                }
                function generateComment(comment, specialBase) {
                    if (comment.type === 'Line') {
                        if (endsWithLineTerminator(comment.value)) {
                            return '//' + comment.value;
                        } else {
                            return '//' + comment.value + '\n';
                        }
                    }
                    if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
                        return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
                    }
                    return '/*' + comment.value + '*/';
                }
                function addComments(stmt, result) {
                    var i, len, comment, save, tailingToStatement, specialBase, fragment;
                    if (stmt.leadingComments && stmt.leadingComments.length > 0) {
                        save = result;
                        comment = stmt.leadingComments[0];
                        result = [];
                        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                            result.push('\n');
                        }
                        result.push(generateComment(comment));
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push('\n');
                        }
                        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                            comment = stmt.leadingComments[i];
                            fragment = [generateComment(comment)];
                            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                                fragment.push('\n');
                            }
                            result.push(addIndent(fragment));
                        }
                        result.push(addIndent(save));
                    }
                    if (stmt.trailingComments) {
                        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                        specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([
                            base,
                            result,
                            indent
                        ]).toString()));
                        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                            comment = stmt.trailingComments[i];
                            if (tailingToStatement) {
                                if (i === 0) {
                                    result = [
                                        result,
                                        indent
                                    ];
                                } else {
                                    result = [
                                        result,
                                        specialBase
                                    ];
                                }
                                result.push(generateComment(comment, specialBase));
                            } else {
                                result = [
                                    result,
                                    addIndent(generateComment(comment))
                                ];
                            }
                            if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                                result = [
                                    result,
                                    '\n'
                                ];
                            }
                        }
                    }
                    return result;
                }
                function parenthesize(text, current, should) {
                    if (current < should) {
                        return [
                            '(',
                            text,
                            ')'
                        ];
                    }
                    return text;
                }
                function maybeBlock(stmt, semicolonOptional, functionBody) {
                    var result, noLeadingComment;
                    noLeadingComment = !extra.comment || !stmt.leadingComments;
                    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
                        return [
                            space,
                            generateStatement(stmt, { functionBody: functionBody })
                        ];
                    }
                    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
                        return ';';
                    }
                    withIndent(function () {
                        result = [
                            newline,
                            addIndent(generateStatement(stmt, {
                                semicolonOptional: semicolonOptional,
                                functionBody: functionBody
                            }))
                        ];
                    });
                    return result;
                }
                function maybeBlockSuffix(stmt, result) {
                    var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
                        return [
                            result,
                            space
                        ];
                    }
                    if (ends) {
                        return [
                            result,
                            base
                        ];
                    }
                    return [
                        result,
                        newline,
                        base
                    ];
                }
                function generateVerbatimString(string) {
                    var i, iz, result;
                    result = string.split(/\r\n|\n/);
                    for (i = 1, iz = result.length; i < iz; i++) {
                        result[i] = newline + base + result[i];
                    }
                    return result;
                }
                function generateVerbatim(expr, option) {
                    var verbatim, result, prec;
                    verbatim = expr[extra.verbatim];
                    if (typeof verbatim === 'string') {
                        result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, option.precedence);
                    } else {
                        result = generateVerbatimString(verbatim.content);
                        prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
                        result = parenthesize(result, prec, option.precedence);
                    }
                    return toSourceNodeWhenNeeded(result, expr);
                }
                function generateIdentifier(node) {
                    return toSourceNodeWhenNeeded(node.name, node);
                }
                function generatePattern(node, options) {
                    var result;
                    if (node.type === Syntax.Identifier) {
                        result = generateIdentifier(node);
                    } else {
                        result = generateExpression(node, {
                            precedence: options.precedence,
                            allowIn: options.allowIn,
                            allowCall: true
                        });
                    }
                    return result;
                }
                function generateFunctionParams(node) {
                    var i, iz, result, hasDefault;
                    hasDefault = false;
                    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
                        result = [generateIdentifier(node.params[0])];
                    } else {
                        result = ['('];
                        if (node.defaults) {
                            hasDefault = true;
                        }
                        for (i = 0, iz = node.params.length; i < iz; ++i) {
                            if (hasDefault && node.defaults[i]) {
                                result.push(generateAssignment(node.params[i], node.defaults[i], '=', {
                                    precedence: Precedence.Assignment,
                                    allowIn: true,
                                    allowCall: true
                                }));
                            } else {
                                result.push(generatePattern(node.params[i], {
                                    precedence: Precedence.Assignment,
                                    allowIn: true,
                                    allowCall: true
                                }));
                            }
                            if (i + 1 < iz) {
                                result.push(',' + space);
                            }
                        }
                        if (node.rest) {
                            if (node.params.length) {
                                result.push(',' + space);
                            }
                            result.push('...');
                            result.push(generateIdentifier(node.rest, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                        }
                        result.push(')');
                    }
                    return result;
                }
                function generateFunctionBody(node) {
                    var result, expr;
                    result = generateFunctionParams(node);
                    if (node.type === Syntax.ArrowFunctionExpression) {
                        result.push(space);
                        result.push('=>');
                    }
                    if (node.expression) {
                        result.push(space);
                        expr = generateExpression(node.body, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        });
                        if (expr.toString().charAt(0) === '{') {
                            expr = [
                                '(',
                                expr,
                                ')'
                            ];
                        }
                        result.push(expr);
                    } else {
                        result.push(maybeBlock(node.body, false, true));
                    }
                    return result;
                }
                function generateIterationForStatement(operator, stmt, semicolonIsNotNeeded) {
                    var result = ['for' + space + '('];
                    withIndent(function () {
                        if (stmt.left.type === Syntax.VariableDeclaration) {
                            withIndent(function () {
                                result.push(stmt.left.kind + noEmptySpace());
                                result.push(generateStatement(stmt.left.declarations[0], { allowIn: false }));
                            });
                        } else {
                            result.push(generateExpression(stmt.left, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true
                            }));
                        }
                        result = join(result, operator);
                        result = [
                            join(result, generateExpression(stmt.right, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })),
                            ')'
                        ];
                    });
                    result.push(maybeBlock(stmt.body, semicolonIsNotNeeded));
                    return result;
                }
                function generateVariableDeclaration(stmt, semicolon, allowIn) {
                    var result, i, iz, node;
                    result = [stmt.kind];
                    function block() {
                        node = stmt.declarations[0];
                        if (extra.comment && node.leadingComments) {
                            result.push('\n');
                            result.push(addIndent(generateStatement(node, { allowIn: allowIn })));
                        } else {
                            result.push(noEmptySpace());
                            result.push(generateStatement(node, { allowIn: allowIn }));
                        }
                        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                            node = stmt.declarations[i];
                            if (extra.comment && node.leadingComments) {
                                result.push(',' + newline);
                                result.push(addIndent(generateStatement(node, { allowIn: allowIn })));
                            } else {
                                result.push(',' + space);
                                result.push(generateStatement(node, { allowIn: allowIn }));
                            }
                        }
                    }
                    if (stmt.declarations.length > 1) {
                        withIndent(block);
                    } else {
                        block();
                    }
                    result.push(semicolon);
                    return result;
                }
                function generateClassBody(classBody) {
                    var result = [
                        '{',
                        newline
                    ];
                    withIndent(function (indent) {
                        var i, iz;
                        for (i = 0, iz = classBody.body.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(generateExpression(classBody.body[i], {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true,
                                type: Syntax.Property
                            }));
                            if (i + 1 < iz) {
                                result.push(newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base);
                    result.push('}');
                    return result;
                }
                function generateLiteral(expr) {
                    var raw;
                    if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                        try {
                            raw = parse(expr.raw).body[0].expression;
                            if (raw.type === Syntax.Literal) {
                                if (raw.value === expr.value) {
                                    return expr.raw;
                                }
                            }
                        } catch (e) {
                        }
                    }
                    if (expr.value === null) {
                        return 'null';
                    }
                    if (typeof expr.value === 'string') {
                        return escapeString(expr.value);
                    }
                    if (typeof expr.value === 'number') {
                        return generateNumber(expr.value);
                    }
                    if (typeof expr.value === 'boolean') {
                        return expr.value ? 'true' : 'false';
                    }
                    return generateRegExp(expr.value);
                }
                function generatePropertyKey(expr, computed, option) {
                    var result = [];
                    if (computed) {
                        result.push('[');
                    }
                    result.push(generateExpression(expr, option));
                    if (computed) {
                        result.push(']');
                    }
                    return result;
                }
                function generateAssignment(left, right, operator, option) {
                    var allowIn, precedence;
                    precedence = option.precedence;
                    allowIn = option.allowIn || Precedence.Assignment < precedence;
                    return parenthesize([
                        generateExpression(left, {
                            precedence: Precedence.Call,
                            allowIn: allowIn,
                            allowCall: true
                        }),
                        space + operator + space,
                        generateExpression(right, {
                            precedence: Precedence.Assignment,
                            allowIn: allowIn,
                            allowCall: true
                        })
                    ], Precedence.Assignment, precedence);
                }
                function generateExpression(expr, option) {
                    var result, precedence, type, currentPrecedence, i, len, fragment, multiline, leftCharCode, leftSource, rightCharCode, allowIn, allowCall, allowUnparenthesizedNew, property, isGenerator;
                    precedence = option.precedence;
                    allowIn = option.allowIn;
                    allowCall = option.allowCall;
                    type = expr.type || option.type;
                    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
                        return generateVerbatim(expr, option);
                    }
                    switch (type) {
                    case Syntax.SequenceExpression:
                        result = [];
                        allowIn |= Precedence.Sequence < precedence;
                        for (i = 0, len = expr.expressions.length; i < len; ++i) {
                            result.push(generateExpression(expr.expressions[i], {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push(',' + space);
                            }
                        }
                        result = parenthesize(result, Precedence.Sequence, precedence);
                        break;
                    case Syntax.AssignmentExpression:
                        result = generateAssignment(expr.left, expr.right, expr.operator, option);
                        break;
                    case Syntax.ArrowFunctionExpression:
                        allowIn |= Precedence.ArrowFunction < precedence;
                        result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
                        break;
                    case Syntax.ConditionalExpression:
                        allowIn |= Precedence.Conditional < precedence;
                        result = parenthesize([
                            generateExpression(expr.test, {
                                precedence: Precedence.LogicalOR,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + '?' + space,
                            generateExpression(expr.consequent, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + ':' + space,
                            generateExpression(expr.alternate, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            })
                        ], Precedence.Conditional, precedence);
                        break;
                    case Syntax.LogicalExpression:
                    case Syntax.BinaryExpression:
                        currentPrecedence = BinaryPrecedence[expr.operator];
                        allowIn |= currentPrecedence < precedence;
                        fragment = generateExpression(expr.left, {
                            precedence: currentPrecedence,
                            allowIn: allowIn,
                            allowCall: true
                        });
                        leftSource = fragment.toString();
                        if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                            result = [
                                fragment,
                                noEmptySpace(),
                                expr.operator
                            ];
                        } else {
                            result = join(fragment, expr.operator);
                        }
                        fragment = generateExpression(expr.right, {
                            precedence: currentPrecedence + 1,
                            allowIn: allowIn,
                            allowCall: true
                        });
                        if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                            result.push(noEmptySpace());
                            result.push(fragment);
                        } else {
                            result = join(result, fragment);
                        }
                        if (expr.operator === 'in' && !allowIn) {
                            result = [
                                '(',
                                result,
                                ')'
                            ];
                        } else {
                            result = parenthesize(result, currentPrecedence, precedence);
                        }
                        break;
                    case Syntax.CallExpression:
                        result = [generateExpression(expr.callee, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true,
                                allowUnparenthesizedNew: false
                            })];
                        result.push('(');
                        for (i = 0, len = expr['arguments'].length; i < len; ++i) {
                            result.push(generateExpression(expr['arguments'][i], {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push(',' + space);
                            }
                        }
                        result.push(')');
                        if (!allowCall) {
                            result = [
                                '(',
                                result,
                                ')'
                            ];
                        } else {
                            result = parenthesize(result, Precedence.Call, precedence);
                        }
                        break;
                    case Syntax.NewExpression:
                        len = expr['arguments'].length;
                        allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;
                        result = join('new', generateExpression(expr.callee, {
                            precedence: Precedence.New,
                            allowIn: true,
                            allowCall: false,
                            allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                        }));
                        if (!allowUnparenthesizedNew || parentheses || len > 0) {
                            result.push('(');
                            for (i = 0; i < len; ++i) {
                                result.push(generateExpression(expr['arguments'][i], {
                                    precedence: Precedence.Assignment,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                if (i + 1 < len) {
                                    result.push(',' + space);
                                }
                            }
                            result.push(')');
                        }
                        result = parenthesize(result, Precedence.New, precedence);
                        break;
                    case Syntax.MemberExpression:
                        result = [generateExpression(expr.object, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: allowCall,
                                allowUnparenthesizedNew: false
                            })];
                        if (expr.computed) {
                            result.push('[');
                            result.push(generateExpression(expr.property, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: allowCall
                            }));
                            result.push(']');
                        } else {
                            if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                                fragment = toSourceNodeWhenNeeded(result).toString();
                                if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                                    result.push('.');
                                }
                            }
                            result.push('.');
                            result.push(generateIdentifier(expr.property));
                        }
                        result = parenthesize(result, Precedence.Member, precedence);
                        break;
                    case Syntax.UnaryExpression:
                        fragment = generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        });
                        if (space === '') {
                            result = join(expr.operator, fragment);
                        } else {
                            result = [expr.operator];
                            if (expr.operator.length > 2) {
                                result = join(result, fragment);
                            } else {
                                leftSource = toSourceNodeWhenNeeded(result).toString();
                                leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                                rightCharCode = fragment.toString().charCodeAt(0);
                                if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode)) {
                                    result.push(noEmptySpace());
                                    result.push(fragment);
                                } else {
                                    result.push(fragment);
                                }
                            }
                        }
                        result = parenthesize(result, Precedence.Unary, precedence);
                        break;
                    case Syntax.YieldExpression:
                        if (expr.delegate) {
                            result = 'yield*';
                        } else {
                            result = 'yield';
                        }
                        if (expr.argument) {
                            result = join(result, generateExpression(expr.argument, {
                                precedence: Precedence.Yield,
                                allowIn: true,
                                allowCall: true
                            }));
                        }
                        result = parenthesize(result, Precedence.Yield, precedence);
                        break;
                    case Syntax.UpdateExpression:
                        if (expr.prefix) {
                            result = parenthesize([
                                expr.operator,
                                generateExpression(expr.argument, {
                                    precedence: Precedence.Unary,
                                    allowIn: true,
                                    allowCall: true
                                })
                            ], Precedence.Unary, precedence);
                        } else {
                            result = parenthesize([
                                generateExpression(expr.argument, {
                                    precedence: Precedence.Postfix,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                expr.operator
                            ], Precedence.Postfix, precedence);
                        }
                        break;
                    case Syntax.FunctionExpression:
                        isGenerator = expr.generator && !extra.moz.starlessGenerator;
                        result = isGenerator ? 'function*' : 'function';
                        if (expr.id) {
                            result = [
                                result,
                                isGenerator ? space : noEmptySpace(),
                                generateIdentifier(expr.id),
                                generateFunctionBody(expr)
                            ];
                        } else {
                            result = [
                                result + space,
                                generateFunctionBody(expr)
                            ];
                        }
                        break;
                    case Syntax.ExportBatchSpecifier:
                        result = '*';
                        break;
                    case Syntax.ArrayPattern:
                    case Syntax.ArrayExpression:
                        if (!expr.elements.length) {
                            result = '[]';
                            break;
                        }
                        multiline = expr.elements.length > 1;
                        result = [
                            '[',
                            multiline ? newline : ''
                        ];
                        withIndent(function (indent) {
                            for (i = 0, len = expr.elements.length; i < len; ++i) {
                                if (!expr.elements[i]) {
                                    if (multiline) {
                                        result.push(indent);
                                    }
                                    if (i + 1 === len) {
                                        result.push(',');
                                    }
                                } else {
                                    result.push(multiline ? indent : '');
                                    result.push(generateExpression(expr.elements[i], {
                                        precedence: Precedence.Assignment,
                                        allowIn: true,
                                        allowCall: true
                                    }));
                                }
                                if (i + 1 < len) {
                                    result.push(',' + (multiline ? newline : space));
                                }
                            }
                        });
                        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(multiline ? base : '');
                        result.push(']');
                        break;
                    case Syntax.ClassExpression:
                        result = ['class'];
                        if (expr.id) {
                            result = join(result, generateExpression(expr.id, {
                                allowIn: true,
                                allowCall: true
                            }));
                        }
                        if (expr.superClass) {
                            fragment = join('extends', generateExpression(expr.superClass, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                            result = join(result, fragment);
                        }
                        result.push(space);
                        result.push(generateStatement(expr.body, {
                            semicolonOptional: true,
                            directiveContext: false
                        }));
                        break;
                    case Syntax.MethodDefinition:
                        if (expr['static']) {
                            result = ['static' + space];
                        } else {
                            result = [];
                        }
                        if (expr.kind === 'get' || expr.kind === 'set') {
                            result = join(result, [
                                join(expr.kind, generatePropertyKey(expr.key, expr.computed, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                })),
                                generateFunctionBody(expr.value)
                            ]);
                        } else {
                            fragment = [
                                generatePropertyKey(expr.key, expr.computed, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                generateFunctionBody(expr.value)
                            ];
                            if (expr.value.generator) {
                                result.push('*');
                                result.push(fragment);
                            } else {
                                result = join(result, fragment);
                            }
                        }
                        break;
                    case Syntax.Property:
                        if (expr.kind === 'get' || expr.kind === 'set') {
                            result = [
                                expr.kind,
                                noEmptySpace(),
                                generatePropertyKey(expr.key, expr.computed, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                generateFunctionBody(expr.value)
                            ];
                        } else {
                            if (expr.shorthand) {
                                result = generatePropertyKey(expr.key, expr.computed, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                });
                            } else if (expr.method) {
                                result = [];
                                if (expr.value.generator) {
                                    result.push('*');
                                }
                                result.push(generatePropertyKey(expr.key, expr.computed, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                result.push(generateFunctionBody(expr.value));
                            } else {
                                result = [
                                    generatePropertyKey(expr.key, expr.computed, {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    }),
                                    ':' + space,
                                    generateExpression(expr.value, {
                                        precedence: Precedence.Assignment,
                                        allowIn: true,
                                        allowCall: true
                                    })
                                ];
                            }
                        }
                        break;
                    case Syntax.ObjectExpression:
                        if (!expr.properties.length) {
                            result = '{}';
                            break;
                        }
                        multiline = expr.properties.length > 1;
                        withIndent(function () {
                            fragment = generateExpression(expr.properties[0], {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true,
                                type: Syntax.Property
                            });
                        });
                        if (!multiline) {
                            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                                result = [
                                    '{',
                                    space,
                                    fragment,
                                    space,
                                    '}'
                                ];
                                break;
                            }
                        }
                        withIndent(function (indent) {
                            result = [
                                '{',
                                newline,
                                indent,
                                fragment
                            ];
                            if (multiline) {
                                result.push(',' + newline);
                                for (i = 1, len = expr.properties.length; i < len; ++i) {
                                    result.push(indent);
                                    result.push(generateExpression(expr.properties[i], {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true,
                                        type: Syntax.Property
                                    }));
                                    if (i + 1 < len) {
                                        result.push(',' + newline);
                                    }
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base);
                        result.push('}');
                        break;
                    case Syntax.ObjectPattern:
                        if (!expr.properties.length) {
                            result = '{}';
                            break;
                        }
                        multiline = false;
                        if (expr.properties.length === 1) {
                            property = expr.properties[0];
                            if (property.value.type !== Syntax.Identifier) {
                                multiline = true;
                            }
                        } else {
                            for (i = 0, len = expr.properties.length; i < len; ++i) {
                                property = expr.properties[i];
                                if (!property.shorthand) {
                                    multiline = true;
                                    break;
                                }
                            }
                        }
                        result = [
                            '{',
                            multiline ? newline : ''
                        ];
                        withIndent(function (indent) {
                            for (i = 0, len = expr.properties.length; i < len; ++i) {
                                result.push(multiline ? indent : '');
                                result.push(generateExpression(expr.properties[i], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                if (i + 1 < len) {
                                    result.push(',' + (multiline ? newline : space));
                                }
                            }
                        });
                        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(multiline ? base : '');
                        result.push('}');
                        break;
                    case Syntax.ThisExpression:
                        result = 'this';
                        break;
                    case Syntax.Identifier:
                        result = generateIdentifier(expr);
                        break;
                    case Syntax.ImportSpecifier:
                    case Syntax.ExportSpecifier:
                        result = [expr.id.name];
                        if (expr.name) {
                            result.push(noEmptySpace() + 'as' + noEmptySpace() + expr.name.name);
                        }
                        break;
                    case Syntax.Literal:
                        result = generateLiteral(expr);
                        break;
                    case Syntax.GeneratorExpression:
                    case Syntax.ComprehensionExpression:
                        result = type === Syntax.GeneratorExpression ? ['('] : ['['];
                        if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                            fragment = generateExpression(expr.body, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            });
                            result.push(fragment);
                        }
                        if (expr.blocks) {
                            withIndent(function () {
                                for (i = 0, len = expr.blocks.length; i < len; ++i) {
                                    fragment = generateExpression(expr.blocks[i], {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    });
                                    if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                                        result = join(result, fragment);
                                    } else {
                                        result.push(fragment);
                                    }
                                }
                            });
                        }
                        if (expr.filter) {
                            result = join(result, 'if' + space);
                            fragment = generateExpression(expr.filter, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            });
                            result = join(result, [
                                '(',
                                fragment,
                                ')'
                            ]);
                        }
                        if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                            fragment = generateExpression(expr.body, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            });
                            result = join(result, fragment);
                        }
                        result.push(type === Syntax.GeneratorExpression ? ')' : ']');
                        break;
                    case Syntax.ComprehensionBlock:
                        if (expr.left.type === Syntax.VariableDeclaration) {
                            fragment = [
                                expr.left.kind,
                                noEmptySpace(),
                                generateStatement(expr.left.declarations[0], { allowIn: false })
                            ];
                        } else {
                            fragment = generateExpression(expr.left, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true
                            });
                        }
                        fragment = join(fragment, expr.of ? 'of' : 'in');
                        fragment = join(fragment, generateExpression(expr.right, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }));
                        result = [
                            'for' + space + '(',
                            fragment,
                            ')'
                        ];
                        break;
                    case Syntax.SpreadElement:
                        result = [
                            '...',
                            generateExpression(expr.argument, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            })
                        ];
                        break;
                    case Syntax.TaggedTemplateExpression:
                        result = [
                            generateExpression(expr.tag, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: allowCall,
                                allowUnparenthesizedNew: false
                            }),
                            generateExpression(expr.quasi, { precedence: Precedence.Primary })
                        ];
                        result = parenthesize(result, Precedence.TaggedTemplate, precedence);
                        break;
                    case Syntax.TemplateElement:
                        result = expr.value.raw;
                        break;
                    case Syntax.TemplateLiteral:
                        result = ['`'];
                        for (i = 0, len = expr.quasis.length; i < len; ++i) {
                            result.push(generateExpression(expr.quasis[i], {
                                precedence: Precedence.Primary,
                                allowIn: true,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push('${' + space);
                                result.push(generateExpression(expr.expressions[i], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                result.push(space + '}');
                            }
                        }
                        result.push('`');
                        break;
                    default:
                        throw new Error('Unknown expression type: ' + expr.type);
                    }
                    if (extra.comment) {
                        result = addComments(expr, result);
                    }
                    return toSourceNodeWhenNeeded(result, expr);
                }
                function generateImportDeclaration(stmt, semicolon) {
                    var result, namedStart;
                    if (stmt.specifiers.length === 0) {
                        return [
                            'import',
                            space,
                            generateLiteral(stmt.source),
                            semicolon
                        ];
                    }
                    result = ['import'];
                    namedStart = 0;
                    if (stmt.specifiers[0]['default']) {
                        result = join(result, [stmt.specifiers[0].id.name]);
                        ++namedStart;
                    }
                    if (stmt.specifiers[namedStart]) {
                        if (namedStart !== 0) {
                            result.push(',');
                        }
                        result.push(space + '{');
                        if (stmt.specifiers.length - namedStart === 1) {
                            result.push(space);
                            result.push(generateExpression(stmt.specifiers[namedStart], {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            }));
                            result.push(space + '}' + space);
                        } else {
                            withIndent(function (indent) {
                                var i, iz;
                                result.push(newline);
                                for (i = namedStart, iz = stmt.specifiers.length; i < iz; ++i) {
                                    result.push(indent);
                                    result.push(generateExpression(stmt.specifiers[i], {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    }));
                                    if (i + 1 < iz) {
                                        result.push(',' + newline);
                                    }
                                }
                            });
                            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                                result.push(newline);
                            }
                            result.push(base + '}' + space);
                        }
                    }
                    result = join(result, [
                        'from' + space,
                        generateLiteral(stmt.source),
                        semicolon
                    ]);
                    return result;
                }
                function generateStatement(stmt, option) {
                    var i, len, result, allowIn, functionBody, directiveContext, fragment, semicolon, isGenerator, guardedHandlers;
                    allowIn = true;
                    semicolon = ';';
                    functionBody = false;
                    directiveContext = false;
                    if (option) {
                        allowIn = option.allowIn === undefined || option.allowIn;
                        if (!semicolons && option.semicolonOptional === true) {
                            semicolon = '';
                        }
                        functionBody = option.functionBody;
                        directiveContext = option.directiveContext;
                    }
                    switch (stmt.type) {
                    case Syntax.BlockStatement:
                        result = [
                            '{',
                            newline
                        ];
                        withIndent(function () {
                            for (i = 0, len = stmt.body.length; i < len; ++i) {
                                fragment = addIndent(generateStatement(stmt.body[i], {
                                    semicolonOptional: i === len - 1,
                                    directiveContext: functionBody
                                }));
                                result.push(fragment);
                                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        });
                        result.push(addIndent('}'));
                        break;
                    case Syntax.BreakStatement:
                        if (stmt.label) {
                            result = 'break ' + stmt.label.name + semicolon;
                        } else {
                            result = 'break' + semicolon;
                        }
                        break;
                    case Syntax.ContinueStatement:
                        if (stmt.label) {
                            result = 'continue ' + stmt.label.name + semicolon;
                        } else {
                            result = 'continue' + semicolon;
                        }
                        break;
                    case Syntax.ClassBody:
                        result = generateClassBody(stmt);
                        break;
                    case Syntax.ClassDeclaration:
                        result = ['class ' + stmt.id.name];
                        if (stmt.superClass) {
                            fragment = join('extends', generateExpression(stmt.superClass, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                            result = join(result, fragment);
                        }
                        result.push(space);
                        result.push(generateStatement(stmt.body, {
                            semicolonOptional: true,
                            directiveContext: false
                        }));
                        break;
                    case Syntax.DirectiveStatement:
                        if (extra.raw && stmt.raw) {
                            result = stmt.raw + semicolon;
                        } else {
                            result = escapeDirective(stmt.directive) + semicolon;
                        }
                        break;
                    case Syntax.DoWhileStatement:
                        result = join('do', maybeBlock(stmt.body));
                        result = maybeBlockSuffix(stmt.body, result);
                        result = join(result, [
                            'while' + space + '(',
                            generateExpression(stmt.test, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            }),
                            ')' + semicolon
                        ]);
                        break;
                    case Syntax.CatchClause:
                        withIndent(function () {
                            var guard;
                            result = [
                                'catch' + space + '(',
                                generateExpression(stmt.param, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                            if (stmt.guard) {
                                guard = generateExpression(stmt.guard, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                });
                                result.splice(2, 0, ' if ', guard);
                            }
                        });
                        result.push(maybeBlock(stmt.body));
                        break;
                    case Syntax.DebuggerStatement:
                        result = 'debugger' + semicolon;
                        break;
                    case Syntax.EmptyStatement:
                        result = ';';
                        break;
                    case Syntax.ExportDeclaration:
                        result = ['export'];
                        if (stmt['default']) {
                            result = join(result, 'default');
                            result = join(result, generateExpression(stmt.declaration, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }) + semicolon);
                            break;
                        }
                        if (stmt.specifiers) {
                            if (stmt.specifiers.length === 0) {
                                result = join(result, '{' + space + '}');
                            } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                                result = join(result, generateExpression(stmt.specifiers[0], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                            } else {
                                result = join(result, '{');
                                withIndent(function (indent) {
                                    var i, iz;
                                    result.push(newline);
                                    for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                                        result.push(indent);
                                        result.push(generateExpression(stmt.specifiers[i], {
                                            precedence: Precedence.Sequence,
                                            allowIn: true,
                                            allowCall: true
                                        }));
                                        if (i + 1 < iz) {
                                            result.push(',' + newline);
                                        }
                                    }
                                });
                                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                                    result.push(newline);
                                }
                                result.push(base + '}');
                            }
                            if (stmt.source) {
                                result = join(result, [
                                    'from' + space,
                                    generateLiteral(stmt.source),
                                    semicolon
                                ]);
                            } else {
                                result.push(semicolon);
                            }
                            break;
                        }
                        if (stmt.declaration) {
                            result = join(result, generateStatement(stmt.declaration, { semicolonOptional: semicolon === '' }));
                        }
                        break;
                    case Syntax.ExpressionStatement:
                        result = [generateExpression(stmt.expression, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })];
                        fragment = toSourceNodeWhenNeeded(result).toString();
                        if (fragment.charAt(0) === '{' || fragment.slice(0, 5) === 'class' && ' {'.indexOf(fragment.charAt(5)) >= 0 || fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0 || directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {
                            result = [
                                '(',
                                result,
                                ')' + semicolon
                            ];
                        } else {
                            result.push(semicolon);
                        }
                        break;
                    case Syntax.ImportDeclaration:
                        result = generateImportDeclaration(stmt, semicolon);
                        break;
                    case Syntax.VariableDeclarator:
                        if (stmt.init) {
                            result = [
                                generateExpression(stmt.id, {
                                    precedence: Precedence.Assignment,
                                    allowIn: allowIn,
                                    allowCall: true
                                }),
                                space,
                                '=',
                                space,
                                generateExpression(stmt.init, {
                                    precedence: Precedence.Assignment,
                                    allowIn: allowIn,
                                    allowCall: true
                                })
                            ];
                        } else {
                            result = generatePattern(stmt.id, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn
                            });
                        }
                        break;
                    case Syntax.VariableDeclaration:
                        result = generateVariableDeclaration(stmt, semicolon, allowIn);
                        break;
                    case Syntax.ThrowStatement:
                        result = [
                            join('throw', generateExpression(stmt.argument, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })),
                            semicolon
                        ];
                        break;
                    case Syntax.TryStatement:
                        result = [
                            'try',
                            maybeBlock(stmt.block)
                        ];
                        result = maybeBlockSuffix(stmt.block, result);
                        if (stmt.handlers) {
                            for (i = 0, len = stmt.handlers.length; i < len; ++i) {
                                result = join(result, generateStatement(stmt.handlers[i]));
                                if (stmt.finalizer || i + 1 !== len) {
                                    result = maybeBlockSuffix(stmt.handlers[i].body, result);
                                }
                            }
                        } else {
                            guardedHandlers = stmt.guardedHandlers || [];
                            for (i = 0, len = guardedHandlers.length; i < len; ++i) {
                                result = join(result, generateStatement(guardedHandlers[i]));
                                if (stmt.finalizer || i + 1 !== len) {
                                    result = maybeBlockSuffix(guardedHandlers[i].body, result);
                                }
                            }
                            if (stmt.handler) {
                                if (isArray(stmt.handler)) {
                                    for (i = 0, len = stmt.handler.length; i < len; ++i) {
                                        result = join(result, generateStatement(stmt.handler[i]));
                                        if (stmt.finalizer || i + 1 !== len) {
                                            result = maybeBlockSuffix(stmt.handler[i].body, result);
                                        }
                                    }
                                } else {
                                    result = join(result, generateStatement(stmt.handler));
                                    if (stmt.finalizer) {
                                        result = maybeBlockSuffix(stmt.handler.body, result);
                                    }
                                }
                            }
                        }
                        if (stmt.finalizer) {
                            result = join(result, [
                                'finally',
                                maybeBlock(stmt.finalizer)
                            ]);
                        }
                        break;
                    case Syntax.SwitchStatement:
                        withIndent(function () {
                            result = [
                                'switch' + space + '(',
                                generateExpression(stmt.discriminant, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')' + space + '{' + newline
                            ];
                        });
                        if (stmt.cases) {
                            for (i = 0, len = stmt.cases.length; i < len; ++i) {
                                fragment = addIndent(generateStatement(stmt.cases[i], { semicolonOptional: i === len - 1 }));
                                result.push(fragment);
                                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        }
                        result.push(addIndent('}'));
                        break;
                    case Syntax.SwitchCase:
                        withIndent(function () {
                            if (stmt.test) {
                                result = [
                                    join('case', generateExpression(stmt.test, {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    })),
                                    ':'
                                ];
                            } else {
                                result = ['default:'];
                            }
                            i = 0;
                            len = stmt.consequent.length;
                            if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                                fragment = maybeBlock(stmt.consequent[0]);
                                result.push(fragment);
                                i = 1;
                            }
                            if (i !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                                result.push(newline);
                            }
                            for (; i < len; ++i) {
                                fragment = addIndent(generateStatement(stmt.consequent[i], { semicolonOptional: i === len - 1 && semicolon === '' }));
                                result.push(fragment);
                                if (i + 1 !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        });
                        break;
                    case Syntax.IfStatement:
                        withIndent(function () {
                            result = [
                                'if' + space + '(',
                                generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        if (stmt.alternate) {
                            result.push(maybeBlock(stmt.consequent));
                            result = maybeBlockSuffix(stmt.consequent, result);
                            if (stmt.alternate.type === Syntax.IfStatement) {
                                result = join(result, [
                                    'else ',
                                    generateStatement(stmt.alternate, { semicolonOptional: semicolon === '' })
                                ]);
                            } else {
                                result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                            }
                        } else {
                            result.push(maybeBlock(stmt.consequent, semicolon === ''));
                        }
                        break;
                    case Syntax.ForStatement:
                        withIndent(function () {
                            result = ['for' + space + '('];
                            if (stmt.init) {
                                if (stmt.init.type === Syntax.VariableDeclaration) {
                                    result.push(generateStatement(stmt.init, { allowIn: false }));
                                } else {
                                    result.push(generateExpression(stmt.init, {
                                        precedence: Precedence.Sequence,
                                        allowIn: false,
                                        allowCall: true
                                    }));
                                    result.push(';');
                                }
                            } else {
                                result.push(';');
                            }
                            if (stmt.test) {
                                result.push(space);
                                result.push(generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                result.push(';');
                            } else {
                                result.push(';');
                            }
                            if (stmt.update) {
                                result.push(space);
                                result.push(generateExpression(stmt.update, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                result.push(')');
                            } else {
                                result.push(')');
                            }
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.ForInStatement:
                        result = generateIterationForStatement('in', stmt, semicolon === '');
                        break;
                    case Syntax.ForOfStatement:
                        result = generateIterationForStatement('of', stmt, semicolon === '');
                        break;
                    case Syntax.LabeledStatement:
                        result = [
                            stmt.label.name + ':',
                            maybeBlock(stmt.body, semicolon === '')
                        ];
                        break;
                    case Syntax.ModuleDeclaration:
                        result = [
                            'module',
                            noEmptySpace(),
                            stmt.id.name,
                            noEmptySpace(),
                            'from',
                            space,
                            generateLiteral(stmt.source),
                            semicolon
                        ];
                        break;
                    case Syntax.Program:
                        len = stmt.body.length;
                        result = [safeConcatenation && len > 0 ? '\n' : ''];
                        for (i = 0; i < len; ++i) {
                            fragment = addIndent(generateStatement(stmt.body[i], {
                                semicolonOptional: !safeConcatenation && i === len - 1,
                                directiveContext: true
                            }));
                            result.push(fragment);
                            if (i + 1 < len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                                result.push(newline);
                            }
                        }
                        break;
                    case Syntax.FunctionDeclaration:
                        isGenerator = stmt.generator && !extra.moz.starlessGenerator;
                        result = [
                            isGenerator ? 'function*' : 'function',
                            isGenerator ? space : noEmptySpace(),
                            generateIdentifier(stmt.id),
                            generateFunctionBody(stmt)
                        ];
                        break;
                    case Syntax.ReturnStatement:
                        if (stmt.argument) {
                            result = [
                                join('return', generateExpression(stmt.argument, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                })),
                                semicolon
                            ];
                        } else {
                            result = ['return' + semicolon];
                        }
                        break;
                    case Syntax.WhileStatement:
                        withIndent(function () {
                            result = [
                                'while' + space + '(',
                                generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.WithStatement:
                        withIndent(function () {
                            result = [
                                'with' + space + '(',
                                generateExpression(stmt.object, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    default:
                        throw new Error('Unknown statement type: ' + stmt.type);
                    }
                    if (extra.comment) {
                        result = addComments(stmt, result);
                    }
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\n') {
                        result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
                    }
                    return toSourceNodeWhenNeeded(result, stmt);
                }
                function generateInternal(node) {
                    if (isStatement(node)) {
                        return generateStatement(node);
                    }
                    if (isExpression(node)) {
                        return generateExpression(node, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        });
                    }
                    throw new Error('Unknown node type: ' + node.type);
                }
                function generate(node, options) {
                    var defaultOptions = getDefaultOptions(), result, pair;
                    if (options != null) {
                        if (typeof options.indent === 'string') {
                            defaultOptions.format.indent.style = options.indent;
                        }
                        if (typeof options.base === 'number') {
                            defaultOptions.format.indent.base = options.base;
                        }
                        options = updateDeeply(defaultOptions, options);
                        indent = options.format.indent.style;
                        if (typeof options.base === 'string') {
                            base = options.base;
                        } else {
                            base = stringRepeat(indent, options.format.indent.base);
                        }
                    } else {
                        options = defaultOptions;
                        indent = options.format.indent.style;
                        base = stringRepeat(indent, options.format.indent.base);
                    }
                    json = options.format.json;
                    renumber = options.format.renumber;
                    hexadecimal = json ? false : options.format.hexadecimal;
                    quotes = json ? 'double' : options.format.quotes;
                    escapeless = options.format.escapeless;
                    newline = options.format.newline;
                    space = options.format.space;
                    if (options.format.compact) {
                        newline = space = indent = base = '';
                    }
                    parentheses = options.format.parentheses;
                    semicolons = options.format.semicolons;
                    safeConcatenation = options.format.safeConcatenation;
                    directive = options.directive;
                    parse = json ? null : options.parse;
                    sourceMap = options.sourceMap;
                    extra = options;
                    if (sourceMap) {
                        if (!exports.browser) {
                            SourceNode = require(34).SourceNode;
                        } else {
                            SourceNode = global.sourceMap.SourceNode;
                        }
                    }
                    result = generateInternal(node);
                    if (!sourceMap) {
                        pair = {
                            code: result.toString(),
                            map: null
                        };
                        return options.sourceMapWithCode ? pair : pair.code;
                    }
                    pair = result.toStringWithSourceMap({
                        file: options.file,
                        sourceRoot: options.sourceMapRoot
                    });
                    if (options.sourceContent) {
                        pair.map.setSourceContent(options.sourceMap, options.sourceContent);
                    }
                    if (options.sourceMapWithCode) {
                        return pair;
                    }
                    return pair.map.toString();
                }
                FORMAT_MINIFY = {
                    indent: {
                        style: '',
                        base: 0
                    },
                    renumber: true,
                    hexadecimal: true,
                    quotes: 'auto',
                    escapeless: true,
                    compact: true,
                    parentheses: false,
                    semicolons: false
                };
                FORMAT_DEFAULTS = getDefaultOptions().format;
                exports.version = require(29).version;
                exports.generate = generate;
                exports.attachComments = estraverse.attachComments;
                exports.Precedence = updateDeeply({}, Precedence);
                exports.browser = false;
                exports.FORMAT_MINIFY = FORMAT_MINIFY;
                exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
            }());
        });
        _define(15, function (module, exports) {
            var stream = require(32);
            var duplex2 = module.exports = function duplex2(options, writable, readable) {
                return new DuplexWrapper(options, writable, readable);
            };
            var DuplexWrapper = exports.DuplexWrapper = function DuplexWrapper(options, writable, readable) {
                if (typeof readable === 'undefined') {
                    readable = writable;
                    writable = options;
                    options = null;
                }
                options = options || {};
                options.objectMode = true;
                stream.Duplex.call(this, options);
                this._bubbleErrors = typeof options.bubbleErrors === 'undefined' || !!options.bubbleErrors;
                this._writable = writable;
                this._readable = readable;
                var self = this;
                writable.once('finish', function () {
                    self.end();
                });
                this.once('finish', function () {
                    writable.end();
                });
                readable.on('data', function (e) {
                    if (!self.push(e)) {
                        readable.pause();
                    }
                });
                readable.once('end', function () {
                    return self.push(null);
                });
                if (this._bubbleErrors) {
                    writable.on('error', function (err) {
                        return self.emit('error', err);
                    });
                    readable.on('error', function (err) {
                        return self.emit('error', err);
                    });
                }
            };
            DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
            DuplexWrapper.prototype._write = function _write(input, encoding, done) {
                this._writable.write(input, encoding, done);
            };
            DuplexWrapper.prototype._read = function _read(n) {
                this._readable.resume();
            };
        });
        _define(16, function (module, exports) {
            var types = require(33);
            module.exports = function (node, fn) {
                if (!node)
                    return this;
                node = 1 == arguments.length ? this.root : node;
                function walk(n, override) {
                    if (false === override)
                        fn(n);
                    var type = override || n.type;
                    types[type](n, walk);
                }
                node.parentNode = false;
                walk(node, false);
                delete node.parentNode;
            };
        });
        _define(17, function (module, exports) {
            'use strict';
            var parse = require(35).parse;
            var estraverse = require(36);
            var reCode = /([^\s,;]?)\s*?%(=?)\s*([\s\S]+?)\s*%\s*?([^\s,;]?)/g;
            var reInternalVar = /^__ASTER_DATA_\d+$/;
            var reInternalMarker = /\"(__ASTER_DATA_\d+)\"/g;
            function tmpl(str, options, data) {
                if (!data) {
                    data = options;
                    options = undefined;
                }
                return tmpl.compile(str, options)(data);
            }
            function isInternalVar(node) {
                return node.type === 'Identifier' && reInternalVar.test(node.name);
            }
            function isInternalStmt(node) {
                return node.type === 'ExpressionStatement' && typeof node.expression === 'string';
            }
            var brackets = {
                '<': '>',
                '[': ']',
                '(': ')',
                '{': '}',
                '\'': '\'',
                '"': '"'
            };
            var spread = {
                'ArrayExpression': 'elements',
                'CallExpression': 'arguments',
                'BlockStatement': 'body',
                'FunctionExpression': 'params',
                'FunctionDeclaration': 'params'
            };
            tmpl.fixAST = function (ast) {
                estraverse.traverse(ast, {
                    leave: function (node, parent) {
                        if (node.type !== '...') {
                            return;
                        }
                        var itemsKey = spread[parent.type];
                        if (!itemsKey) {
                            throw new TypeError('Unknown substitution in ' + parent.type);
                        }
                        parent[itemsKey] = parent[itemsKey].reduce(function (items, item) {
                            if (item.type === '...') {
                                return items.concat(item.argument);
                            }
                            items.push(item);
                            return items;
                        }, []);
                    },
                    keys: { '...': ['argument'] }
                });
                return ast;
            };
            tmpl.compile = function (str, options) {
                var code = [], index = 0;
                str = str.replace(reCode, function (match, open, isEval, codePart, close) {
                    if (open) {
                        var expectedClose = brackets[open];
                        if (!expectedClose || close && expectedClose !== close) {
                            return match;
                        }
                    }
                    if (isEval) {
                        var varName = '__ASTER_DATA_' + index++;
                        var isSpread = open !== '<' && open !== '\'' && open !== '"';
                        if (isSpread) {
                            codePart = '{type: "...", argument: ' + codePart + '}';
                        } else if (open === '\'' || open === '"') {
                            codePart = '{type: "Literal", value: ' + codePart + '}';
                        }
                        code.push('\t\tvar ' + varName + ' = ' + codePart);
                        return isSpread ? open + varName + close : varName;
                    } else {
                        if (open !== '<') {
                            return match;
                        }
                        code.push(codePart);
                        return '';
                    }
                });
                var ast = parse(str, options);
                ast = estraverse.replace(ast, {
                    leave: function (node) {
                        if (isInternalVar(node)) {
                            return node.name;
                        }
                        if (isInternalStmt(node)) {
                            return node.expression;
                        }
                    }
                });
                if (!(options && options.fast)) {
                    code.unshift('\twith (it) {');
                    code.push('\t}');
                }
                code.unshift('return function template(it) {');
                code.push('\treturn estemplate.fixAST(' + JSON.stringify(ast).replace(reInternalMarker, '$1') + ')', '}');
                return new Function('estemplate', code.join('\n'))(tmpl);
            };
            module.exports = tmpl;
        });
        _define(18, function (module, exports) {
            var Stream = require('stream');
            exports = module.exports = through;
            through.through = through;
            function through(write, end, opts) {
                write = write || function (data) {
                    this.queue(data);
                };
                end = end || function () {
                    this.queue(null);
                };
                var ended = false, destroyed = false, buffer = [], _ended = false;
                var stream = new Stream();
                stream.readable = stream.writable = true;
                stream.paused = false;
                stream.autoDestroy = !(opts && opts.autoDestroy === false);
                stream.write = function (data) {
                    write.call(this, data);
                    return !stream.paused;
                };
                function drain() {
                    while (buffer.length && !stream.paused) {
                        var data = buffer.shift();
                        if (null === data)
                            return stream.emit('end');
                        else
                            stream.emit('data', data);
                    }
                }
                stream.queue = stream.push = function (data) {
                    if (_ended)
                        return stream;
                    if (data == null)
                        _ended = true;
                    buffer.push(data);
                    drain();
                    return stream;
                };
                stream.on('end', function () {
                    stream.readable = false;
                    if (!stream.writable && stream.autoDestroy)
                        process.nextTick(function () {
                            stream.destroy();
                        });
                });
                function _end() {
                    stream.writable = false;
                    end.call(stream);
                    if (!stream.readable && stream.autoDestroy)
                        stream.destroy();
                }
                stream.end = function (data) {
                    if (ended)
                        return;
                    ended = true;
                    if (arguments.length)
                        stream.write(data);
                    _end();
                    return stream;
                };
                stream.destroy = function () {
                    if (destroyed)
                        return;
                    destroyed = true;
                    ended = true;
                    buffer.length = 0;
                    stream.writable = stream.readable = false;
                    stream.emit('close');
                    return stream;
                };
                stream.pause = function () {
                    if (stream.paused)
                        return;
                    stream.paused = true;
                    return stream;
                };
                stream.resume = function () {
                    if (stream.paused) {
                        stream.paused = false;
                        stream.emit('resume');
                    }
                    drain();
                    if (!stream.paused)
                        stream.emit('drain');
                    return stream;
                };
                return stream;
            }
        });
        _define(19, function (module, exports) {
            var path = require('path');
            var clone = require(47);
            var cloneStats = require(48);
            var cloneBuffer = require(37);
            var isBuffer = require(40);
            var isStream = require(42);
            var isNull = require(44);
            var inspectStream = require(46);
            var Stream = require('stream');
            function File(file) {
                if (!file)
                    file = {};
                var history = file.path ? [file.path] : file.history;
                this.history = history || [];
                this.cwd = file.cwd || process.cwd();
                this.base = file.base || this.cwd;
                this.stat = file.stat || null;
                this.contents = file.contents || null;
            }
            File.prototype.isBuffer = function () {
                return isBuffer(this.contents);
            };
            File.prototype.isStream = function () {
                return isStream(this.contents);
            };
            File.prototype.isNull = function () {
                return isNull(this.contents);
            };
            File.prototype.isDirectory = function () {
                return this.isNull() && this.stat && this.stat.isDirectory();
            };
            File.prototype.clone = function (opt) {
                if (typeof opt === 'boolean') {
                    opt = {
                        deep: opt,
                        contents: true
                    };
                } else if (!opt) {
                    opt = {
                        deep: false,
                        contents: true
                    };
                } else {
                    opt.deep = opt.deep === true;
                    opt.contents = opt.contents !== false;
                }
                var contents;
                if (this.isStream()) {
                    contents = this.contents.pipe(new Stream.PassThrough());
                    this.contents = this.contents.pipe(new Stream.PassThrough());
                } else if (this.isBuffer()) {
                    contents = opt.contents ? cloneBuffer(this.contents) : this.contents;
                }
                var file = new File({
                    cwd: this.cwd,
                    base: this.base,
                    stat: this.stat ? cloneStats(this.stat) : null,
                    history: this.history.slice(),
                    contents: contents
                });
                Object.keys(this).forEach(function (key) {
                    if (key === '_contents' || key === 'stat' || key === 'history' || key === 'path' || key === 'base' || key === 'cwd') {
                        return;
                    }
                    file[key] = opt.deep ? clone(this[key], true) : this[key];
                }, this);
                return file;
            };
            File.prototype.pipe = function (stream, opt) {
                if (!opt)
                    opt = {};
                if (typeof opt.end === 'undefined')
                    opt.end = true;
                if (this.isStream()) {
                    return this.contents.pipe(stream, opt);
                }
                if (this.isBuffer()) {
                    if (opt.end) {
                        stream.end(this.contents);
                    } else {
                        stream.write(this.contents);
                    }
                    return stream;
                }
                if (opt.end)
                    stream.end();
                return stream;
            };
            File.prototype.inspect = function () {
                var inspect = [];
                var filePath = this.base && this.path ? this.relative : this.path;
                if (filePath) {
                    inspect.push('"' + filePath + '"');
                }
                if (this.isBuffer()) {
                    inspect.push(this.contents.inspect());
                }
                if (this.isStream()) {
                    inspect.push(inspectStream(this.contents));
                }
                return '<File ' + inspect.join(' ') + '>';
            };
            Object.defineProperty(File.prototype, 'contents', {
                get: function () {
                    return this._contents;
                },
                set: function (val) {
                    if (!isBuffer(val) && !isStream(val) && !isNull(val)) {
                        throw new Error('File.contents can only be a Buffer, a Stream, or null.');
                    }
                    this._contents = val;
                }
            });
            Object.defineProperty(File.prototype, 'relative', {
                get: function () {
                    if (!this.base)
                        throw new Error('No base specified! Can not get relative.');
                    if (!this.path)
                        throw new Error('No path specified! Can not get relative.');
                    return path.relative(this.base, this.path);
                },
                set: function () {
                    throw new Error('File.relative is generated from the base and path attributes. Do not modify it.');
                }
            });
            Object.defineProperty(File.prototype, 'path', {
                get: function () {
                    return this.history[this.history.length - 1];
                },
                set: function (path) {
                    if (typeof path !== 'string')
                        throw new Error('path should be string');
                    if (path && path !== this.path) {
                        this.history.push(path);
                    }
                }
            });
            module.exports = File;
        });
        _define(20, function (module, exports) {
            (function (root, mod) {
                if (typeof exports == 'object' && typeof module == 'object')
                    return mod(exports);
                if (typeof define == 'function' && define.amd)
                    return define(['exports'], mod);
                mod(root.acorn || (root.acorn = {}));
            }(this, function (exports) {
                'use strict';
                exports.version = '0.9.0';
                var options, input, inputLen, sourceFile;
                exports.parse = function (inpt, opts) {
                    input = String(inpt);
                    inputLen = input.length;
                    setOptions(opts);
                    initTokenState();
                    initParserState();
                    return parseTopLevel(options.program);
                };
                var defaultOptions = exports.defaultOptions = {
                    ecmaVersion: 5,
                    strictSemicolons: false,
                    allowTrailingCommas: true,
                    forbidReserved: false,
                    allowReturnOutsideFunction: false,
                    locations: false,
                    onToken: null,
                    onComment: null,
                    ranges: false,
                    program: null,
                    sourceFile: null,
                    directSourceFile: null
                };
                exports.parseExpressionAt = function (inpt, pos, opts) {
                    input = String(inpt);
                    inputLen = input.length;
                    setOptions(opts);
                    initTokenState(pos);
                    initParserState();
                    return parseExpression();
                };
                var isArray = function (obj) {
                    return Object.prototype.toString.call(obj) === '[object Array]';
                };
                function setOptions(opts) {
                    options = opts || {};
                    for (var opt in defaultOptions)
                        if (!has(options, opt))
                            options[opt] = defaultOptions[opt];
                    sourceFile = options.sourceFile || null;
                    if (isArray(options.onToken)) {
                        var tokens = options.onToken;
                        options.onToken = function (token) {
                            tokens.push(token);
                        };
                    }
                    if (isArray(options.onComment)) {
                        var comments = options.onComment;
                        options.onComment = function (block, text, start, end, startLoc, endLoc) {
                            var comment = {
                                type: block ? 'Block' : 'Line',
                                value: text,
                                start: start,
                                end: end
                            };
                            if (options.locations) {
                                comment.loc = new SourceLocation();
                                comment.loc.start = startLoc;
                                comment.loc.end = endLoc;
                            }
                            if (options.ranges)
                                comment.range = [
                                    start,
                                    end
                                ];
                            comments.push(comment);
                        };
                    }
                    isKeyword = options.ecmaVersion >= 6 ? isEcma6Keyword : isEcma5AndLessKeyword;
                }
                var getLineInfo = exports.getLineInfo = function (input, offset) {
                    for (var line = 1, cur = 0;;) {
                        lineBreak.lastIndex = cur;
                        var match = lineBreak.exec(input);
                        if (match && match.index < offset) {
                            ++line;
                            cur = match.index + match[0].length;
                        } else
                            break;
                    }
                    return {
                        line: line,
                        column: offset - cur
                    };
                };
                function Token() {
                    this.type = tokType;
                    this.value = tokVal;
                    this.start = tokStart;
                    this.end = tokEnd;
                    if (options.locations) {
                        this.loc = new SourceLocation();
                        this.loc.end = tokEndLoc;
                        this.startLoc = tokStartLoc;
                        this.endLoc = tokEndLoc;
                    }
                    if (options.ranges)
                        this.range = [
                            tokStart,
                            tokEnd
                        ];
                }
                exports.Token = Token;
                exports.tokenize = function (inpt, opts) {
                    input = String(inpt);
                    inputLen = input.length;
                    setOptions(opts);
                    initTokenState();
                    function getToken(forceRegexp) {
                        lastEnd = tokEnd;
                        readToken(forceRegexp);
                        return new Token();
                    }
                    getToken.jumpTo = function (pos, reAllowed) {
                        tokPos = pos;
                        if (options.locations) {
                            tokCurLine = 1;
                            tokLineStart = lineBreak.lastIndex = 0;
                            var match;
                            while ((match = lineBreak.exec(input)) && match.index < pos) {
                                ++tokCurLine;
                                tokLineStart = match.index + match[0].length;
                            }
                        }
                        tokRegexpAllowed = reAllowed;
                        skipSpace();
                    };
                    return getToken;
                };
                var tokPos;
                var tokStart, tokEnd;
                var tokStartLoc, tokEndLoc;
                var tokType, tokVal;
                var tokRegexpAllowed;
                var tokCurLine, tokLineStart;
                var lastStart, lastEnd, lastEndLoc;
                var inFunction, inGenerator, labels, strict;
                var metParenL;
                var inTemplate;
                function initParserState() {
                    lastStart = lastEnd = tokPos;
                    if (options.locations)
                        lastEndLoc = new Position();
                    inFunction = inGenerator = strict = false;
                    labels = [];
                    readToken();
                }
                function raise(pos, message) {
                    var loc = getLineInfo(input, pos);
                    message += ' (' + loc.line + ':' + loc.column + ')';
                    var err = new SyntaxError(message);
                    err.pos = pos;
                    err.loc = loc;
                    err.raisedAt = tokPos;
                    throw err;
                }
                var empty = [];
                var _num = { type: 'num' }, _regexp = { type: 'regexp' }, _string = { type: 'string' };
                var _name = { type: 'name' }, _eof = { type: 'eof' };
                var _break = { keyword: 'break' }, _case = {
                        keyword: 'case',
                        beforeExpr: true
                    }, _catch = { keyword: 'catch' };
                var _continue = { keyword: 'continue' }, _debugger = { keyword: 'debugger' }, _default = { keyword: 'default' };
                var _do = {
                        keyword: 'do',
                        isLoop: true
                    }, _else = {
                        keyword: 'else',
                        beforeExpr: true
                    };
                var _finally = { keyword: 'finally' }, _for = {
                        keyword: 'for',
                        isLoop: true
                    }, _function = { keyword: 'function' };
                var _if = { keyword: 'if' }, _return = {
                        keyword: 'return',
                        beforeExpr: true
                    }, _switch = { keyword: 'switch' };
                var _throw = {
                        keyword: 'throw',
                        beforeExpr: true
                    }, _try = { keyword: 'try' }, _var = { keyword: 'var' };
                var _let = { keyword: 'let' }, _const = { keyword: 'const' };
                var _while = {
                        keyword: 'while',
                        isLoop: true
                    }, _with = { keyword: 'with' }, _new = {
                        keyword: 'new',
                        beforeExpr: true
                    };
                var _this = { keyword: 'this' };
                var _class = { keyword: 'class' }, _extends = {
                        keyword: 'extends',
                        beforeExpr: true
                    };
                var _export = { keyword: 'export' }, _import = { keyword: 'import' };
                var _yield = {
                    keyword: 'yield',
                    beforeExpr: true
                };
                var _null = {
                        keyword: 'null',
                        atomValue: null
                    }, _true = {
                        keyword: 'true',
                        atomValue: true
                    };
                var _false = {
                    keyword: 'false',
                    atomValue: false
                };
                var _in = {
                    keyword: 'in',
                    binop: 7,
                    beforeExpr: true
                };
                var keywordTypes = {
                    'break': _break,
                    'case': _case,
                    'catch': _catch,
                    'continue': _continue,
                    'debugger': _debugger,
                    'default': _default,
                    'do': _do,
                    'else': _else,
                    'finally': _finally,
                    'for': _for,
                    'function': _function,
                    'if': _if,
                    'return': _return,
                    'switch': _switch,
                    'throw': _throw,
                    'try': _try,
                    'var': _var,
                    'let': _let,
                    'const': _const,
                    'while': _while,
                    'with': _with,
                    'null': _null,
                    'true': _true,
                    'false': _false,
                    'new': _new,
                    'in': _in,
                    'instanceof': {
                        keyword: 'instanceof',
                        binop: 7,
                        beforeExpr: true
                    },
                    'this': _this,
                    'typeof': {
                        keyword: 'typeof',
                        prefix: true,
                        beforeExpr: true
                    },
                    'void': {
                        keyword: 'void',
                        prefix: true,
                        beforeExpr: true
                    },
                    'delete': {
                        keyword: 'delete',
                        prefix: true,
                        beforeExpr: true
                    },
                    'class': _class,
                    'extends': _extends,
                    'export': _export,
                    'import': _import,
                    'yield': _yield
                };
                var _bracketL = {
                        type: '[',
                        beforeExpr: true
                    }, _bracketR = { type: ']' }, _braceL = {
                        type: '{',
                        beforeExpr: true
                    };
                var _braceR = { type: '}' }, _parenL = {
                        type: '(',
                        beforeExpr: true
                    }, _parenR = { type: ')' };
                var _comma = {
                        type: ',',
                        beforeExpr: true
                    }, _semi = {
                        type: ';',
                        beforeExpr: true
                    };
                var _colon = {
                        type: ':',
                        beforeExpr: true
                    }, _dot = { type: '.' }, _ellipsis = { type: '...' }, _question = {
                        type: '?',
                        beforeExpr: true
                    };
                var _arrow = {
                        type: '=>',
                        beforeExpr: true
                    }, _bquote = { type: '`' }, _dollarBraceL = {
                        type: '${',
                        beforeExpr: true
                    };
                var _slash = {
                        binop: 10,
                        beforeExpr: true
                    }, _eq = {
                        isAssign: true,
                        beforeExpr: true
                    };
                var _assign = {
                    isAssign: true,
                    beforeExpr: true
                };
                var _incDec = {
                        postfix: true,
                        prefix: true,
                        isUpdate: true
                    }, _prefix = {
                        prefix: true,
                        beforeExpr: true
                    };
                var _logicalOR = {
                    binop: 1,
                    beforeExpr: true
                };
                var _logicalAND = {
                    binop: 2,
                    beforeExpr: true
                };
                var _bitwiseOR = {
                    binop: 3,
                    beforeExpr: true
                };
                var _bitwiseXOR = {
                    binop: 4,
                    beforeExpr: true
                };
                var _bitwiseAND = {
                    binop: 5,
                    beforeExpr: true
                };
                var _equality = {
                    binop: 6,
                    beforeExpr: true
                };
                var _relational = {
                    binop: 7,
                    beforeExpr: true
                };
                var _bitShift = {
                    binop: 8,
                    beforeExpr: true
                };
                var _plusMin = {
                    binop: 9,
                    prefix: true,
                    beforeExpr: true
                };
                var _modulo = {
                    binop: 10,
                    beforeExpr: true
                };
                var _star = {
                    binop: 10,
                    beforeExpr: true
                };
                exports.tokTypes = {
                    bracketL: _bracketL,
                    bracketR: _bracketR,
                    braceL: _braceL,
                    braceR: _braceR,
                    parenL: _parenL,
                    parenR: _parenR,
                    comma: _comma,
                    semi: _semi,
                    colon: _colon,
                    dot: _dot,
                    ellipsis: _ellipsis,
                    question: _question,
                    slash: _slash,
                    eq: _eq,
                    name: _name,
                    eof: _eof,
                    num: _num,
                    regexp: _regexp,
                    string: _string,
                    arrow: _arrow,
                    bquote: _bquote,
                    dollarBraceL: _dollarBraceL
                };
                for (var kw in keywordTypes)
                    exports.tokTypes['_' + kw] = keywordTypes[kw];
                function makePredicate(words) {
                    words = words.split(' ');
                    var f = '', cats = [];
                    out:
                        for (var i = 0; i < words.length; ++i) {
                            for (var j = 0; j < cats.length; ++j)
                                if (cats[j][0].length == words[i].length) {
                                    cats[j].push(words[i]);
                                    continue out;
                                }
                            cats.push([words[i]]);
                        }
                    function compareTo(arr) {
                        if (arr.length == 1)
                            return f += 'return str === ' + JSON.stringify(arr[0]) + ';';
                        f += 'switch(str){';
                        for (var i = 0; i < arr.length; ++i)
                            f += 'case ' + JSON.stringify(arr[i]) + ':';
                        f += 'return true}return false;';
                    }
                    if (cats.length > 3) {
                        cats.sort(function (a, b) {
                            return b.length - a.length;
                        });
                        f += 'switch(str.length){';
                        for (var i = 0; i < cats.length; ++i) {
                            var cat = cats[i];
                            f += 'case ' + cat[0].length + ':';
                            compareTo(cat);
                        }
                        f += '}';
                    } else {
                        compareTo(words);
                    }
                    return new Function('str', f);
                }
                var isReservedWord3 = makePredicate('abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile');
                var isReservedWord5 = makePredicate('class enum extends super const export import');
                var isStrictReservedWord = makePredicate('implements interface let package private protected public static yield');
                var isStrictBadIdWord = makePredicate('eval arguments');
                var ecma5AndLessKeywords = 'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this';
                var isEcma5AndLessKeyword = makePredicate(ecma5AndLessKeywords);
                var isEcma6Keyword = makePredicate(ecma5AndLessKeywords + ' let const class extends export import yield');
                var isKeyword = isEcma5AndLessKeyword;
                var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
                var nonASCIIidentifierStartChars = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
                var nonASCIIidentifierChars = '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19B0-\u19C0\u19C8\u19C9\u19D0-\u19D9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F';
                var nonASCIIidentifierStart = new RegExp('[' + nonASCIIidentifierStartChars + ']');
                var nonASCIIidentifier = new RegExp('[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']');
                var newline = /[\n\r\u2028\u2029]/;
                var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
                var isIdentifierStart = exports.isIdentifierStart = function (code) {
                    if (code < 65)
                        return code === 36;
                    if (code < 91)
                        return true;
                    if (code < 97)
                        return code === 95;
                    if (code < 123)
                        return true;
                    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
                };
                var isIdentifierChar = exports.isIdentifierChar = function (code) {
                    if (code < 48)
                        return code === 36;
                    if (code < 58)
                        return true;
                    if (code < 65)
                        return false;
                    if (code < 91)
                        return true;
                    if (code < 97)
                        return code === 95;
                    if (code < 123)
                        return true;
                    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
                };
                function Position() {
                    this.line = tokCurLine;
                    this.column = tokPos - tokLineStart;
                }
                function initTokenState(pos) {
                    if (pos) {
                        tokPos = pos;
                        tokLineStart = Math.max(0, input.lastIndexOf('\n', pos));
                        tokCurLine = input.slice(0, tokLineStart).split(newline).length;
                    } else {
                        tokCurLine = 1;
                        tokPos = tokLineStart = 0;
                    }
                    tokRegexpAllowed = true;
                    metParenL = 0;
                    inTemplate = false;
                    skipSpace();
                }
                function finishToken(type, val, shouldSkipSpace) {
                    tokEnd = tokPos;
                    if (options.locations)
                        tokEndLoc = new Position();
                    tokType = type;
                    if (shouldSkipSpace !== false)
                        skipSpace();
                    tokVal = val;
                    tokRegexpAllowed = type.beforeExpr;
                    if (options.onToken) {
                        options.onToken(new Token());
                    }
                }
                function skipBlockComment() {
                    var startLoc = options.onComment && options.locations && new Position();
                    var start = tokPos, end = input.indexOf('*/', tokPos += 2);
                    if (end === -1)
                        raise(tokPos - 2, 'Unterminated comment');
                    tokPos = end + 2;
                    if (options.locations) {
                        lineBreak.lastIndex = start;
                        var match;
                        while ((match = lineBreak.exec(input)) && match.index < tokPos) {
                            ++tokCurLine;
                            tokLineStart = match.index + match[0].length;
                        }
                    }
                    if (options.onComment)
                        options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new Position());
                }
                function skipLineComment(startSkip) {
                    var start = tokPos;
                    var startLoc = options.onComment && options.locations && new Position();
                    var ch = input.charCodeAt(tokPos += startSkip);
                    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
                        ++tokPos;
                        ch = input.charCodeAt(tokPos);
                    }
                    if (options.onComment)
                        options.onComment(false, input.slice(start + startSkip, tokPos), start, tokPos, startLoc, options.locations && new Position());
                }
                function skipSpace() {
                    while (tokPos < inputLen) {
                        var ch = input.charCodeAt(tokPos);
                        if (ch === 32) {
                            ++tokPos;
                        } else if (ch === 13) {
                            ++tokPos;
                            var next = input.charCodeAt(tokPos);
                            if (next === 10) {
                                ++tokPos;
                            }
                            if (options.locations) {
                                ++tokCurLine;
                                tokLineStart = tokPos;
                            }
                        } else if (ch === 10 || ch === 8232 || ch === 8233) {
                            ++tokPos;
                            if (options.locations) {
                                ++tokCurLine;
                                tokLineStart = tokPos;
                            }
                        } else if (ch > 8 && ch < 14) {
                            ++tokPos;
                        } else if (ch === 47) {
                            var next = input.charCodeAt(tokPos + 1);
                            if (next === 42) {
                                skipBlockComment();
                            } else if (next === 47) {
                                skipLineComment(2);
                            } else
                                break;
                        } else if (ch === 160) {
                            ++tokPos;
                        } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                            ++tokPos;
                        } else {
                            break;
                        }
                    }
                }
                function readToken_dot() {
                    var next = input.charCodeAt(tokPos + 1);
                    if (next >= 48 && next <= 57)
                        return readNumber(true);
                    var next2 = input.charCodeAt(tokPos + 2);
                    if (options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
                        tokPos += 3;
                        return finishToken(_ellipsis);
                    } else {
                        ++tokPos;
                        return finishToken(_dot);
                    }
                }
                function readToken_slash() {
                    var next = input.charCodeAt(tokPos + 1);
                    if (tokRegexpAllowed) {
                        ++tokPos;
                        return readRegexp();
                    }
                    if (next === 61)
                        return finishOp(_assign, 2);
                    return finishOp(_slash, 1);
                }
                function readToken_mult_modulo(code) {
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === 61)
                        return finishOp(_assign, 2);
                    return finishOp(code === 42 ? _star : _modulo, 1);
                }
                function readToken_pipe_amp(code) {
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === code)
                        return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
                    if (next === 61)
                        return finishOp(_assign, 2);
                    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
                }
                function readToken_caret() {
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === 61)
                        return finishOp(_assign, 2);
                    return finishOp(_bitwiseXOR, 1);
                }
                function readToken_plus_min(code) {
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === code) {
                        if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {
                            skipLineComment(3);
                            skipSpace();
                            return readToken();
                        }
                        return finishOp(_incDec, 2);
                    }
                    if (next === 61)
                        return finishOp(_assign, 2);
                    return finishOp(_plusMin, 1);
                }
                function readToken_lt_gt(code) {
                    var next = input.charCodeAt(tokPos + 1);
                    var size = 1;
                    if (next === code) {
                        size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
                        if (input.charCodeAt(tokPos + size) === 61)
                            return finishOp(_assign, size + 1);
                        return finishOp(_bitShift, size);
                    }
                    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {
                        skipLineComment(4);
                        skipSpace();
                        return readToken();
                    }
                    if (next === 61)
                        size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
                    return finishOp(_relational, size);
                }
                function readToken_eq_excl(code) {
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === 61)
                        return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
                    if (code === 61 && next === 62 && options.ecmaVersion >= 6) {
                        tokPos += 2;
                        return finishToken(_arrow);
                    }
                    return finishOp(code === 61 ? _eq : _prefix, 1);
                }
                function getTemplateToken(code) {
                    if (tokType === _string) {
                        if (code === 96) {
                            ++tokPos;
                            return finishToken(_bquote);
                        } else if (code === 36 && input.charCodeAt(tokPos + 1) === 123) {
                            tokPos += 2;
                            return finishToken(_dollarBraceL);
                        }
                    }
                    if (code === 125) {
                        ++tokPos;
                        return finishToken(_braceR, undefined, false);
                    }
                    return readTmplString();
                }
                function getTokenFromCode(code) {
                    switch (code) {
                    case 46:
                        return readToken_dot();
                    case 40:
                        ++tokPos;
                        return finishToken(_parenL);
                    case 41:
                        ++tokPos;
                        return finishToken(_parenR);
                    case 59:
                        ++tokPos;
                        return finishToken(_semi);
                    case 44:
                        ++tokPos;
                        return finishToken(_comma);
                    case 91:
                        ++tokPos;
                        return finishToken(_bracketL);
                    case 93:
                        ++tokPos;
                        return finishToken(_bracketR);
                    case 123:
                        ++tokPos;
                        return finishToken(_braceL);
                    case 125:
                        ++tokPos;
                        return finishToken(_braceR);
                    case 58:
                        ++tokPos;
                        return finishToken(_colon);
                    case 63:
                        ++tokPos;
                        return finishToken(_question);
                    case 96:
                        if (options.ecmaVersion >= 6) {
                            ++tokPos;
                            return finishToken(_bquote, undefined, false);
                        }
                    case 48:
                        var next = input.charCodeAt(tokPos + 1);
                        if (next === 120 || next === 88)
                            return readRadixNumber(16);
                        if (options.ecmaVersion >= 6) {
                            if (next === 111 || next === 79)
                                return readRadixNumber(8);
                            if (next === 98 || next === 66)
                                return readRadixNumber(2);
                        }
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                        return readNumber(false);
                    case 34:
                    case 39:
                        return readString(code);
                    case 47:
                        return readToken_slash();
                    case 37:
                    case 42:
                        return readToken_mult_modulo(code);
                    case 124:
                    case 38:
                        return readToken_pipe_amp(code);
                    case 94:
                        return readToken_caret();
                    case 43:
                    case 45:
                        return readToken_plus_min(code);
                    case 60:
                    case 62:
                        return readToken_lt_gt(code);
                    case 61:
                    case 33:
                        return readToken_eq_excl(code);
                    case 126:
                        return finishOp(_prefix, 1);
                    }
                    return false;
                }
                function readToken(forceRegexp) {
                    if (!forceRegexp)
                        tokStart = tokPos;
                    else
                        tokPos = tokStart + 1;
                    if (options.locations)
                        tokStartLoc = new Position();
                    if (forceRegexp)
                        return readRegexp();
                    if (tokPos >= inputLen)
                        return finishToken(_eof);
                    var code = input.charCodeAt(tokPos);
                    if (inTemplate)
                        return getTemplateToken(code);
                    if (isIdentifierStart(code) || code === 92)
                        return readWord();
                    var tok = getTokenFromCode(code);
                    if (tok === false) {
                        var ch = String.fromCharCode(code);
                        if (ch === '\\' || nonASCIIidentifierStart.test(ch))
                            return readWord();
                        raise(tokPos, 'Unexpected character \'' + ch + '\'');
                    }
                    return tok;
                }
                function finishOp(type, size) {
                    var str = input.slice(tokPos, tokPos + size);
                    tokPos += size;
                    finishToken(type, str);
                }
                function readRegexp() {
                    var content = '', escaped, inClass, start = tokPos;
                    for (;;) {
                        if (tokPos >= inputLen)
                            raise(start, 'Unterminated regular expression');
                        var ch = input.charAt(tokPos);
                        if (newline.test(ch))
                            raise(start, 'Unterminated regular expression');
                        if (!escaped) {
                            if (ch === '[')
                                inClass = true;
                            else if (ch === ']' && inClass)
                                inClass = false;
                            else if (ch === '/' && !inClass)
                                break;
                            escaped = ch === '\\';
                        } else
                            escaped = false;
                        ++tokPos;
                    }
                    var content = input.slice(start, tokPos);
                    ++tokPos;
                    var mods = readWord1();
                    if (mods && !/^[gmsiy]*$/.test(mods))
                        raise(start, 'Invalid regular expression flag');
                    try {
                        var value = new RegExp(content, mods);
                    } catch (e) {
                        if (e instanceof SyntaxError)
                            raise(start, 'Error parsing regular expression: ' + e.message);
                        raise(e);
                    }
                    return finishToken(_regexp, value);
                }
                function readInt(radix, len) {
                    var start = tokPos, total = 0;
                    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                        var code = input.charCodeAt(tokPos), val;
                        if (code >= 97)
                            val = code - 97 + 10;
                        else if (code >= 65)
                            val = code - 65 + 10;
                        else if (code >= 48 && code <= 57)
                            val = code - 48;
                        else
                            val = Infinity;
                        if (val >= radix)
                            break;
                        ++tokPos;
                        total = total * radix + val;
                    }
                    if (tokPos === start || len != null && tokPos - start !== len)
                        return null;
                    return total;
                }
                function readRadixNumber(radix) {
                    tokPos += 2;
                    var val = readInt(radix);
                    if (val == null)
                        raise(tokStart + 2, 'Expected number in radix ' + radix);
                    if (isIdentifierStart(input.charCodeAt(tokPos)))
                        raise(tokPos, 'Identifier directly after number');
                    return finishToken(_num, val);
                }
                function readNumber(startsWithDot) {
                    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
                    if (!startsWithDot && readInt(10) === null)
                        raise(start, 'Invalid number');
                    if (input.charCodeAt(tokPos) === 46) {
                        ++tokPos;
                        readInt(10);
                        isFloat = true;
                    }
                    var next = input.charCodeAt(tokPos);
                    if (next === 69 || next === 101) {
                        next = input.charCodeAt(++tokPos);
                        if (next === 43 || next === 45)
                            ++tokPos;
                        if (readInt(10) === null)
                            raise(start, 'Invalid number');
                        isFloat = true;
                    }
                    if (isIdentifierStart(input.charCodeAt(tokPos)))
                        raise(tokPos, 'Identifier directly after number');
                    var str = input.slice(start, tokPos), val;
                    if (isFloat)
                        val = parseFloat(str);
                    else if (!octal || str.length === 1)
                        val = parseInt(str, 10);
                    else if (/[89]/.test(str) || strict)
                        raise(start, 'Invalid number');
                    else
                        val = parseInt(str, 8);
                    return finishToken(_num, val);
                }
                function readCodePoint() {
                    var ch = input.charCodeAt(tokPos), code;
                    if (ch === 123) {
                        if (options.ecmaVersion < 6)
                            unexpected();
                        ++tokPos;
                        code = readHexChar(input.indexOf('}', tokPos) - tokPos);
                        ++tokPos;
                        if (code > 1114111)
                            unexpected();
                    } else {
                        code = readHexChar(4);
                    }
                    if (code <= 65535) {
                        return String.fromCharCode(code);
                    }
                    var cu1 = (code - 65536 >> 10) + 55296;
                    var cu2 = (code - 65536 & 1023) + 56320;
                    return String.fromCharCode(cu1, cu2);
                }
                function readString(quote) {
                    ++tokPos;
                    var out = '';
                    for (;;) {
                        if (tokPos >= inputLen)
                            raise(tokStart, 'Unterminated string constant');
                        var ch = input.charCodeAt(tokPos);
                        if (ch === quote) {
                            ++tokPos;
                            return finishToken(_string, out);
                        }
                        if (ch === 92) {
                            out += readEscapedChar();
                        } else {
                            ++tokPos;
                            if (newline.test(String.fromCharCode(ch))) {
                                raise(tokStart, 'Unterminated string constant');
                            }
                            out += String.fromCharCode(ch);
                        }
                    }
                }
                function readTmplString() {
                    var out = '';
                    for (;;) {
                        if (tokPos >= inputLen)
                            raise(tokStart, 'Unterminated string constant');
                        var ch = input.charCodeAt(tokPos);
                        if (ch === 96 || ch === 36 && input.charCodeAt(tokPos + 1) === 123)
                            return finishToken(_string, out);
                        if (ch === 92) {
                            out += readEscapedChar();
                        } else {
                            ++tokPos;
                            if (newline.test(String.fromCharCode(ch))) {
                                if (ch === 13 && input.charCodeAt(tokPos) === 10) {
                                    ++tokPos;
                                    ch = 10;
                                }
                                if (options.locations) {
                                    ++tokCurLine;
                                    tokLineStart = tokPos;
                                }
                            }
                            out += String.fromCharCode(ch);
                        }
                    }
                }
                function readEscapedChar() {
                    var ch = input.charCodeAt(++tokPos);
                    var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
                    if (octal)
                        octal = octal[0];
                    while (octal && parseInt(octal, 8) > 255)
                        octal = octal.slice(0, -1);
                    if (octal === '0')
                        octal = null;
                    ++tokPos;
                    if (octal) {
                        if (strict)
                            raise(tokPos - 2, 'Octal literal in strict mode');
                        tokPos += octal.length - 1;
                        return String.fromCharCode(parseInt(octal, 8));
                    } else {
                        switch (ch) {
                        case 110:
                            return '\n';
                        case 114:
                            return '\r';
                        case 120:
                            return String.fromCharCode(readHexChar(2));
                        case 117:
                            return readCodePoint();
                        case 85:
                            return String.fromCharCode(readHexChar(8));
                        case 116:
                            return '\t';
                        case 98:
                            return '\b';
                        case 118:
                            return '\x0B';
                        case 102:
                            return '\f';
                        case 48:
                            return '\0';
                        case 13:
                            if (input.charCodeAt(tokPos) === 10)
                                ++tokPos;
                        case 10:
                            if (options.locations) {
                                tokLineStart = tokPos;
                                ++tokCurLine;
                            }
                            return '';
                        default:
                            return String.fromCharCode(ch);
                        }
                    }
                }
                function readHexChar(len) {
                    var n = readInt(16, len);
                    if (n === null)
                        raise(tokStart, 'Bad character escape sequence');
                    return n;
                }
                var containsEsc;
                function readWord1() {
                    containsEsc = false;
                    var word, first = true, start = tokPos;
                    for (;;) {
                        var ch = input.charCodeAt(tokPos);
                        if (isIdentifierChar(ch)) {
                            if (containsEsc)
                                word += input.charAt(tokPos);
                            ++tokPos;
                        } else if (ch === 92) {
                            if (!containsEsc)
                                word = input.slice(start, tokPos);
                            containsEsc = true;
                            if (input.charCodeAt(++tokPos) != 117)
                                raise(tokPos, 'Expecting Unicode escape sequence \\uXXXX');
                            ++tokPos;
                            var esc = readHexChar(4);
                            var escStr = String.fromCharCode(esc);
                            if (!escStr)
                                raise(tokPos - 1, 'Invalid Unicode escape');
                            if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
                                raise(tokPos - 4, 'Invalid Unicode escape');
                            word += escStr;
                        } else {
                            break;
                        }
                        first = false;
                    }
                    return containsEsc ? word : input.slice(start, tokPos);
                }
                function readWord() {
                    var word = readWord1();
                    var type = _name;
                    if (!containsEsc && isKeyword(word))
                        type = keywordTypes[word];
                    return finishToken(type, word);
                }
                function next() {
                    lastStart = tokStart;
                    lastEnd = tokEnd;
                    lastEndLoc = tokEndLoc;
                    readToken();
                }
                function setStrict(strct) {
                    strict = strct;
                    tokPos = tokStart;
                    if (options.locations) {
                        while (tokPos < tokLineStart) {
                            tokLineStart = input.lastIndexOf('\n', tokLineStart - 2) + 1;
                            --tokCurLine;
                        }
                    }
                    skipSpace();
                    readToken();
                }
                function Node() {
                    this.type = null;
                    this.start = tokStart;
                    this.end = null;
                }
                exports.Node = Node;
                function SourceLocation() {
                    this.start = tokStartLoc;
                    this.end = null;
                    if (sourceFile !== null)
                        this.source = sourceFile;
                }
                function startNode() {
                    var node = new Node();
                    if (options.locations)
                        node.loc = new SourceLocation();
                    if (options.directSourceFile)
                        node.sourceFile = options.directSourceFile;
                    if (options.ranges)
                        node.range = [
                            tokStart,
                            0
                        ];
                    return node;
                }
                function startNodeFrom(other) {
                    var node = new Node();
                    node.start = other.start;
                    if (options.locations) {
                        node.loc = new SourceLocation();
                        node.loc.start = other.loc.start;
                    }
                    if (options.ranges)
                        node.range = [
                            other.range[0],
                            0
                        ];
                    return node;
                }
                function finishNode(node, type) {
                    node.type = type;
                    node.end = lastEnd;
                    if (options.locations)
                        node.loc.end = lastEndLoc;
                    if (options.ranges)
                        node.range[1] = lastEnd;
                    return node;
                }
                function isUseStrict(stmt) {
                    return options.ecmaVersion >= 5 && stmt.type === 'ExpressionStatement' && stmt.expression.type === 'Literal' && stmt.expression.value === 'use strict';
                }
                function eat(type) {
                    if (tokType === type) {
                        next();
                        return true;
                    } else {
                        return false;
                    }
                }
                function canInsertSemicolon() {
                    return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
                }
                function semicolon() {
                    if (!eat(_semi) && !canInsertSemicolon())
                        unexpected();
                }
                function expect(type) {
                    eat(type) || unexpected();
                }
                function unexpected(pos) {
                    raise(pos != null ? pos : tokStart, 'Unexpected token');
                }
                function has(obj, propName) {
                    return Object.prototype.hasOwnProperty.call(obj, propName);
                }
                function toAssignable(node, allowSpread, checkType) {
                    if (options.ecmaVersion >= 6 && node) {
                        switch (node.type) {
                        case 'Identifier':
                        case 'MemberExpression':
                            break;
                        case 'ObjectExpression':
                            node.type = 'ObjectPattern';
                            for (var i = 0; i < node.properties.length; i++) {
                                var prop = node.properties[i];
                                if (prop.kind !== 'init')
                                    unexpected(prop.key.start);
                                toAssignable(prop.value, false, checkType);
                            }
                            break;
                        case 'ArrayExpression':
                            node.type = 'ArrayPattern';
                            for (var i = 0, lastI = node.elements.length - 1; i <= lastI; i++) {
                                toAssignable(node.elements[i], i === lastI, checkType);
                            }
                            break;
                        case 'SpreadElement':
                            if (allowSpread) {
                                toAssignable(node.argument, false, checkType);
                                checkSpreadAssign(node.argument);
                            } else {
                                unexpected(node.start);
                            }
                            break;
                        default:
                            if (checkType)
                                unexpected(node.start);
                        }
                    }
                    return node;
                }
                function checkSpreadAssign(node) {
                    if (node.type !== 'Identifier' && node.type !== 'ArrayPattern')
                        unexpected(node.start);
                }
                function checkFunctionParam(param, nameHash) {
                    switch (param.type) {
                    case 'Identifier':
                        if (isStrictReservedWord(param.name) || isStrictBadIdWord(param.name))
                            raise(param.start, 'Defining \'' + param.name + '\' in strict mode');
                        if (has(nameHash, param.name))
                            raise(param.start, 'Argument name clash in strict mode');
                        nameHash[param.name] = true;
                        break;
                    case 'ObjectPattern':
                        for (var i = 0; i < param.properties.length; i++)
                            checkFunctionParam(param.properties[i].value, nameHash);
                        break;
                    case 'ArrayPattern':
                        for (var i = 0; i < param.elements.length; i++)
                            checkFunctionParam(param.elements[i], nameHash);
                        break;
                    }
                }
                function checkPropClash(prop, propHash) {
                    if (prop.computed)
                        return;
                    var key = prop.key, name;
                    switch (key.type) {
                    case 'Identifier':
                        name = key.name;
                        break;
                    case 'Literal':
                        name = String(key.value);
                        break;
                    default:
                        return;
                    }
                    var kind = prop.kind || 'init', other;
                    if (has(propHash, name)) {
                        other = propHash[name];
                        var isGetSet = kind !== 'init';
                        if ((strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
                            raise(key.start, 'Redefinition of property');
                    } else {
                        other = propHash[name] = {
                            init: false,
                            get: false,
                            set: false
                        };
                    }
                    other[kind] = true;
                }
                function checkLVal(expr, isBinding) {
                    switch (expr.type) {
                    case 'Identifier':
                        if (strict && (isStrictBadIdWord(expr.name) || isStrictReservedWord(expr.name)))
                            raise(expr.start, isBinding ? 'Binding ' + expr.name + ' in strict mode' : 'Assigning to ' + expr.name + ' in strict mode');
                        break;
                    case 'MemberExpression':
                        if (!isBinding)
                            break;
                    case 'ObjectPattern':
                        for (var i = 0; i < expr.properties.length; i++)
                            checkLVal(expr.properties[i].value, isBinding);
                        break;
                    case 'ArrayPattern':
                        for (var i = 0; i < expr.elements.length; i++) {
                            var elem = expr.elements[i];
                            if (elem)
                                checkLVal(elem, isBinding);
                        }
                        break;
                    case 'SpreadElement':
                        break;
                    default:
                        raise(expr.start, 'Assigning to rvalue');
                    }
                }
                function parseTopLevel(program) {
                    var node = program || startNode(), first = true;
                    if (!program)
                        node.body = [];
                    while (tokType !== _eof) {
                        var stmt = parseStatement();
                        node.body.push(stmt);
                        if (first && isUseStrict(stmt))
                            setStrict(true);
                        first = false;
                    }
                    return finishNode(node, 'Program');
                }
                var loopLabel = { kind: 'loop' }, switchLabel = { kind: 'switch' };
                function parseStatement() {
                    if (tokType === _slash || tokType === _assign && tokVal == '/=')
                        readToken(true);
                    var starttype = tokType, node = startNode();
                    switch (starttype) {
                    case _break:
                    case _continue:
                        return parseBreakContinueStatement(node, starttype.keyword);
                    case _debugger:
                        return parseDebuggerStatement(node);
                    case _do:
                        return parseDoStatement(node);
                    case _for:
                        return parseForStatement(node);
                    case _function:
                        return parseFunctionStatement(node);
                    case _class:
                        return parseClass(node, true);
                    case _if:
                        return parseIfStatement(node);
                    case _return:
                        return parseReturnStatement(node);
                    case _switch:
                        return parseSwitchStatement(node);
                    case _throw:
                        return parseThrowStatement(node);
                    case _try:
                        return parseTryStatement(node);
                    case _var:
                    case _let:
                    case _const:
                        return parseVarStatement(node, starttype.keyword);
                    case _while:
                        return parseWhileStatement(node);
                    case _with:
                        return parseWithStatement(node);
                    case _braceL:
                        return parseBlock();
                    case _semi:
                        return parseEmptyStatement(node);
                    case _export:
                        return parseExport(node);
                    case _import:
                        return parseImport(node);
                    default:
                        var maybeName = tokVal, expr = parseExpression();
                        if (starttype === _name && expr.type === 'Identifier' && eat(_colon))
                            return parseLabeledStatement(node, maybeName, expr);
                        else
                            return parseExpressionStatement(node, expr);
                    }
                }
                function parseBreakContinueStatement(node, keyword) {
                    var isBreak = keyword == 'break';
                    next();
                    if (eat(_semi) || canInsertSemicolon())
                        node.label = null;
                    else if (tokType !== _name)
                        unexpected();
                    else {
                        node.label = parseIdent();
                        semicolon();
                    }
                    for (var i = 0; i < labels.length; ++i) {
                        var lab = labels[i];
                        if (node.label == null || lab.name === node.label.name) {
                            if (lab.kind != null && (isBreak || lab.kind === 'loop'))
                                break;
                            if (node.label && isBreak)
                                break;
                        }
                    }
                    if (i === labels.length)
                        raise(node.start, 'Unsyntactic ' + keyword);
                    return finishNode(node, isBreak ? 'BreakStatement' : 'ContinueStatement');
                }
                function parseDebuggerStatement(node) {
                    next();
                    semicolon();
                    return finishNode(node, 'DebuggerStatement');
                }
                function parseDoStatement(node) {
                    next();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    expect(_while);
                    node.test = parseParenExpression();
                    semicolon();
                    return finishNode(node, 'DoWhileStatement');
                }
                function parseForStatement(node) {
                    next();
                    labels.push(loopLabel);
                    expect(_parenL);
                    if (tokType === _semi)
                        return parseFor(node, null);
                    if (tokType === _var || tokType === _let) {
                        var init = startNode(), varKind = tokType.keyword, isLet = tokType === _let;
                        next();
                        parseVar(init, true, varKind);
                        finishNode(init, 'VariableDeclaration');
                        if ((tokType === _in || options.ecmaVersion >= 6 && tokType === _name && tokVal === 'of') && init.declarations.length === 1 && !(isLet && init.declarations[0].init))
                            return parseForIn(node, init);
                        return parseFor(node, init);
                    }
                    var init = parseExpression(false, true);
                    if (tokType === _in || options.ecmaVersion >= 6 && tokType === _name && tokVal === 'of') {
                        checkLVal(init);
                        return parseForIn(node, init);
                    }
                    return parseFor(node, init);
                }
                function parseFunctionStatement(node) {
                    next();
                    return parseFunction(node, true);
                }
                function parseIfStatement(node) {
                    next();
                    node.test = parseParenExpression();
                    node.consequent = parseStatement();
                    node.alternate = eat(_else) ? parseStatement() : null;
                    return finishNode(node, 'IfStatement');
                }
                function parseReturnStatement(node) {
                    if (!inFunction && !options.allowReturnOutsideFunction)
                        raise(tokStart, '\'return\' outside of function');
                    next();
                    if (eat(_semi) || canInsertSemicolon())
                        node.argument = null;
                    else {
                        node.argument = parseExpression();
                        semicolon();
                    }
                    return finishNode(node, 'ReturnStatement');
                }
                function parseSwitchStatement(node) {
                    next();
                    node.discriminant = parseParenExpression();
                    node.cases = [];
                    expect(_braceL);
                    labels.push(switchLabel);
                    for (var cur, sawDefault; tokType != _braceR;) {
                        if (tokType === _case || tokType === _default) {
                            var isCase = tokType === _case;
                            if (cur)
                                finishNode(cur, 'SwitchCase');
                            node.cases.push(cur = startNode());
                            cur.consequent = [];
                            next();
                            if (isCase)
                                cur.test = parseExpression();
                            else {
                                if (sawDefault)
                                    raise(lastStart, 'Multiple default clauses');
                                sawDefault = true;
                                cur.test = null;
                            }
                            expect(_colon);
                        } else {
                            if (!cur)
                                unexpected();
                            cur.consequent.push(parseStatement());
                        }
                    }
                    if (cur)
                        finishNode(cur, 'SwitchCase');
                    next();
                    labels.pop();
                    return finishNode(node, 'SwitchStatement');
                }
                function parseThrowStatement(node) {
                    next();
                    if (newline.test(input.slice(lastEnd, tokStart)))
                        raise(lastEnd, 'Illegal newline after throw');
                    node.argument = parseExpression();
                    semicolon();
                    return finishNode(node, 'ThrowStatement');
                }
                function parseTryStatement(node) {
                    next();
                    node.block = parseBlock();
                    node.handler = null;
                    if (tokType === _catch) {
                        var clause = startNode();
                        next();
                        expect(_parenL);
                        clause.param = parseIdent();
                        if (strict && isStrictBadIdWord(clause.param.name))
                            raise(clause.param.start, 'Binding ' + clause.param.name + ' in strict mode');
                        expect(_parenR);
                        clause.guard = null;
                        clause.body = parseBlock();
                        node.handler = finishNode(clause, 'CatchClause');
                    }
                    node.guardedHandlers = empty;
                    node.finalizer = eat(_finally) ? parseBlock() : null;
                    if (!node.handler && !node.finalizer)
                        raise(node.start, 'Missing catch or finally clause');
                    return finishNode(node, 'TryStatement');
                }
                function parseVarStatement(node, kind) {
                    next();
                    parseVar(node, false, kind);
                    semicolon();
                    return finishNode(node, 'VariableDeclaration');
                }
                function parseWhileStatement(node) {
                    next();
                    node.test = parseParenExpression();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    return finishNode(node, 'WhileStatement');
                }
                function parseWithStatement(node) {
                    if (strict)
                        raise(tokStart, '\'with\' in strict mode');
                    next();
                    node.object = parseParenExpression();
                    node.body = parseStatement();
                    return finishNode(node, 'WithStatement');
                }
                function parseEmptyStatement(node) {
                    next();
                    return finishNode(node, 'EmptyStatement');
                }
                function parseLabeledStatement(node, maybeName, expr) {
                    for (var i = 0; i < labels.length; ++i)
                        if (labels[i].name === maybeName)
                            raise(expr.start, 'Label \'' + maybeName + '\' is already declared');
                    var kind = tokType.isLoop ? 'loop' : tokType === _switch ? 'switch' : null;
                    labels.push({
                        name: maybeName,
                        kind: kind
                    });
                    node.body = parseStatement();
                    labels.pop();
                    node.label = expr;
                    return finishNode(node, 'LabeledStatement');
                }
                function parseExpressionStatement(node, expr) {
                    node.expression = expr;
                    semicolon();
                    return finishNode(node, 'ExpressionStatement');
                }
                function parseParenExpression() {
                    expect(_parenL);
                    var val = parseExpression();
                    expect(_parenR);
                    return val;
                }
                function parseBlock(allowStrict) {
                    var node = startNode(), first = true, oldStrict;
                    node.body = [];
                    expect(_braceL);
                    while (!eat(_braceR)) {
                        var stmt = parseStatement();
                        node.body.push(stmt);
                        if (first && allowStrict && isUseStrict(stmt)) {
                            oldStrict = strict;
                            setStrict(strict = true);
                        }
                        first = false;
                    }
                    if (oldStrict === false)
                        setStrict(false);
                    return finishNode(node, 'BlockStatement');
                }
                function parseFor(node, init) {
                    node.init = init;
                    expect(_semi);
                    node.test = tokType === _semi ? null : parseExpression();
                    expect(_semi);
                    node.update = tokType === _parenR ? null : parseExpression();
                    expect(_parenR);
                    node.body = parseStatement();
                    labels.pop();
                    return finishNode(node, 'ForStatement');
                }
                function parseForIn(node, init) {
                    var type = tokType === _in ? 'ForInStatement' : 'ForOfStatement';
                    next();
                    node.left = init;
                    node.right = parseExpression();
                    expect(_parenR);
                    node.body = parseStatement();
                    labels.pop();
                    return finishNode(node, type);
                }
                function parseVar(node, noIn, kind) {
                    node.declarations = [];
                    node.kind = kind;
                    for (;;) {
                        var decl = startNode();
                        decl.id = options.ecmaVersion >= 6 ? toAssignable(parseExprAtom()) : parseIdent();
                        checkLVal(decl.id, true);
                        decl.init = eat(_eq) ? parseExpression(true, noIn) : kind === _const.keyword ? unexpected() : null;
                        node.declarations.push(finishNode(decl, 'VariableDeclarator'));
                        if (!eat(_comma))
                            break;
                    }
                    return node;
                }
                function parseExpression(noComma, noIn) {
                    var expr = parseMaybeAssign(noIn);
                    if (!noComma && tokType === _comma) {
                        var node = startNodeFrom(expr);
                        node.expressions = [expr];
                        while (eat(_comma))
                            node.expressions.push(parseMaybeAssign(noIn));
                        return finishNode(node, 'SequenceExpression');
                    }
                    return expr;
                }
                function parseMaybeAssign(noIn) {
                    var left = parseMaybeConditional(noIn);
                    if (tokType.isAssign) {
                        var node = startNodeFrom(left);
                        node.operator = tokVal;
                        node.left = tokType === _eq ? toAssignable(left) : left;
                        checkLVal(left);
                        next();
                        node.right = parseMaybeAssign(noIn);
                        return finishNode(node, 'AssignmentExpression');
                    }
                    return left;
                }
                function parseMaybeConditional(noIn) {
                    var expr = parseExprOps(noIn);
                    if (eat(_question)) {
                        var node = startNodeFrom(expr);
                        node.test = expr;
                        node.consequent = parseExpression(true);
                        expect(_colon);
                        node.alternate = parseExpression(true, noIn);
                        return finishNode(node, 'ConditionalExpression');
                    }
                    return expr;
                }
                function parseExprOps(noIn) {
                    return parseExprOp(parseMaybeUnary(), -1, noIn);
                }
                function parseExprOp(left, minPrec, noIn) {
                    var prec = tokType.binop;
                    if (prec != null && (!noIn || tokType !== _in)) {
                        if (prec > minPrec) {
                            var node = startNodeFrom(left);
                            node.left = left;
                            node.operator = tokVal;
                            var op = tokType;
                            next();
                            node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
                            var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? 'LogicalExpression' : 'BinaryExpression');
                            return parseExprOp(exprNode, minPrec, noIn);
                        }
                    }
                    return left;
                }
                function parseMaybeUnary() {
                    if (tokType.prefix) {
                        var node = startNode(), update = tokType.isUpdate;
                        node.operator = tokVal;
                        node.prefix = true;
                        tokRegexpAllowed = true;
                        next();
                        node.argument = parseMaybeUnary();
                        if (update)
                            checkLVal(node.argument);
                        else if (strict && node.operator === 'delete' && node.argument.type === 'Identifier')
                            raise(node.start, 'Deleting local variable in strict mode');
                        return finishNode(node, update ? 'UpdateExpression' : 'UnaryExpression');
                    }
                    var expr = parseExprSubscripts();
                    while (tokType.postfix && !canInsertSemicolon()) {
                        var node = startNodeFrom(expr);
                        node.operator = tokVal;
                        node.prefix = false;
                        node.argument = expr;
                        checkLVal(expr);
                        next();
                        expr = finishNode(node, 'UpdateExpression');
                    }
                    return expr;
                }
                function parseExprSubscripts() {
                    return parseSubscripts(parseExprAtom());
                }
                function parseSubscripts(base, noCalls) {
                    if (eat(_dot)) {
                        var node = startNodeFrom(base);
                        node.object = base;
                        node.property = parseIdent(true);
                        node.computed = false;
                        return parseSubscripts(finishNode(node, 'MemberExpression'), noCalls);
                    } else if (eat(_bracketL)) {
                        var node = startNodeFrom(base);
                        node.object = base;
                        node.property = parseExpression();
                        node.computed = true;
                        expect(_bracketR);
                        return parseSubscripts(finishNode(node, 'MemberExpression'), noCalls);
                    } else if (!noCalls && eat(_parenL)) {
                        var node = startNodeFrom(base);
                        node.callee = base;
                        node.arguments = parseExprList(_parenR, false);
                        return parseSubscripts(finishNode(node, 'CallExpression'), noCalls);
                    } else if (tokType === _bquote) {
                        var node = startNodeFrom(base);
                        node.tag = base;
                        node.quasi = parseTemplate();
                        return parseSubscripts(finishNode(node, 'TaggedTemplateExpression'), noCalls);
                    }
                    return base;
                }
                function parseExprAtom() {
                    switch (tokType) {
                    case _this:
                        var node = startNode();
                        next();
                        return finishNode(node, 'ThisExpression');
                    case _yield:
                        if (inGenerator)
                            return parseYield();
                    case _name:
                        var id = parseIdent(tokType !== _name);
                        if (eat(_arrow)) {
                            return parseArrowExpression(startNodeFrom(id), [id]);
                        }
                        return id;
                    case _num:
                    case _string:
                    case _regexp:
                        var node = startNode();
                        node.value = tokVal;
                        node.raw = input.slice(tokStart, tokEnd);
                        next();
                        return finishNode(node, 'Literal');
                    case _null:
                    case _true:
                    case _false:
                        var node = startNode();
                        node.value = tokType.atomValue;
                        node.raw = tokType.keyword;
                        next();
                        return finishNode(node, 'Literal');
                    case _parenL:
                        var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart, val, exprList;
                        next();
                        if (options.ecmaVersion >= 6 && tokType === _for) {
                            val = parseComprehension(startNode(), true);
                        } else {
                            var oldParenL = ++metParenL;
                            if (tokType !== _parenR) {
                                val = parseExpression();
                                exprList = val.type === 'SequenceExpression' ? val.expressions : [val];
                            } else {
                                exprList = [];
                            }
                            expect(_parenR);
                            if (metParenL === oldParenL && eat(_arrow)) {
                                val = parseArrowExpression(startNode(), exprList);
                            } else {
                                if (!val)
                                    unexpected(lastStart);
                                if (options.ecmaVersion >= 6) {
                                    for (var i = 0; i < exprList.length; i++) {
                                        if (exprList[i].type === 'SpreadElement')
                                            unexpected();
                                    }
                                }
                            }
                        }
                        val.start = tokStart1;
                        val.end = lastEnd;
                        if (options.locations) {
                            val.loc.start = tokStartLoc1;
                            val.loc.end = lastEndLoc;
                        }
                        if (options.ranges) {
                            val.range = [
                                tokStart1,
                                lastEnd
                            ];
                        }
                        return val;
                    case _bracketL:
                        var node = startNode();
                        next();
                        if (options.ecmaVersion >= 6 && tokType === _for) {
                            return parseComprehension(node, false);
                        }
                        node.elements = parseExprList(_bracketR, true, true);
                        return finishNode(node, 'ArrayExpression');
                    case _braceL:
                        return parseObj();
                    case _function:
                        var node = startNode();
                        next();
                        return parseFunction(node, false);
                    case _class:
                        return parseClass(startNode(), false);
                    case _new:
                        return parseNew();
                    case _ellipsis:
                        return parseSpread();
                    case _bquote:
                        return parseTemplate();
                    default:
                        unexpected();
                    }
                }
                function parseNew() {
                    var node = startNode();
                    next();
                    node.callee = parseSubscripts(parseExprAtom(), true);
                    if (eat(_parenL))
                        node.arguments = parseExprList(_parenR, false);
                    else
                        node.arguments = empty;
                    return finishNode(node, 'NewExpression');
                }
                function parseSpread() {
                    var node = startNode();
                    next();
                    node.argument = parseExpression(true);
                    return finishNode(node, 'SpreadElement');
                }
                function parseTemplate() {
                    var node = startNode();
                    node.expressions = [];
                    node.quasis = [];
                    inTemplate = true;
                    next();
                    for (;;) {
                        var elem = startNode();
                        elem.value = {
                            cooked: tokVal,
                            raw: input.slice(tokStart, tokEnd)
                        };
                        elem.tail = false;
                        next();
                        node.quasis.push(finishNode(elem, 'TemplateElement'));
                        if (tokType === _bquote) {
                            elem.tail = true;
                            break;
                        }
                        inTemplate = false;
                        expect(_dollarBraceL);
                        node.expressions.push(parseExpression());
                        inTemplate = true;
                        tokPos = tokEnd;
                        expect(_braceR);
                    }
                    inTemplate = false;
                    next();
                    return finishNode(node, 'TemplateLiteral');
                }
                function parseObj() {
                    var node = startNode(), first = true, propHash = {};
                    node.properties = [];
                    next();
                    while (!eat(_braceR)) {
                        if (!first) {
                            expect(_comma);
                            if (options.allowTrailingCommas && eat(_braceR))
                                break;
                        } else
                            first = false;
                        var prop = startNode(), isGenerator;
                        if (options.ecmaVersion >= 6) {
                            prop.method = false;
                            prop.shorthand = false;
                            isGenerator = eat(_star);
                        }
                        parsePropertyName(prop);
                        if (eat(_colon)) {
                            prop.value = parseExpression(true);
                            prop.kind = 'init';
                        } else if (options.ecmaVersion >= 6 && tokType === _parenL) {
                            prop.kind = 'init';
                            prop.method = true;
                            prop.value = parseMethod(isGenerator);
                        } else if (options.ecmaVersion >= 5 && !prop.computed && prop.key.type === 'Identifier' && (prop.key.name === 'get' || prop.key.name === 'set')) {
                            if (isGenerator)
                                unexpected();
                            prop.kind = prop.key.name;
                            parsePropertyName(prop);
                            prop.value = parseMethod(false);
                        } else if (options.ecmaVersion >= 6 && !prop.computed && prop.key.type === 'Identifier') {
                            prop.kind = 'init';
                            prop.value = prop.key;
                            prop.shorthand = true;
                        } else
                            unexpected();
                        checkPropClash(prop, propHash);
                        node.properties.push(finishNode(prop, 'Property'));
                    }
                    return finishNode(node, 'ObjectExpression');
                }
                function parsePropertyName(prop) {
                    if (options.ecmaVersion >= 6) {
                        if (eat(_bracketL)) {
                            prop.computed = true;
                            prop.key = parseExpression();
                            expect(_bracketR);
                            return;
                        } else {
                            prop.computed = false;
                        }
                    }
                    prop.key = tokType === _num || tokType === _string ? parseExprAtom() : parseIdent(true);
                }
                function initFunction(node) {
                    node.id = null;
                    node.params = [];
                    if (options.ecmaVersion >= 6) {
                        node.defaults = [];
                        node.rest = null;
                        node.generator = false;
                    }
                }
                function parseFunction(node, isStatement, allowExpressionBody) {
                    initFunction(node);
                    if (options.ecmaVersion >= 6) {
                        node.generator = eat(_star);
                    }
                    if (isStatement || tokType === _name) {
                        node.id = parseIdent();
                    }
                    parseFunctionParams(node);
                    parseFunctionBody(node, allowExpressionBody);
                    return finishNode(node, isStatement ? 'FunctionDeclaration' : 'FunctionExpression');
                }
                function parseMethod(isGenerator) {
                    var node = startNode();
                    initFunction(node);
                    parseFunctionParams(node);
                    var allowExpressionBody;
                    if (options.ecmaVersion >= 6) {
                        node.generator = isGenerator;
                        allowExpressionBody = true;
                    } else {
                        allowExpressionBody = false;
                    }
                    parseFunctionBody(node, allowExpressionBody);
                    return finishNode(node, 'FunctionExpression');
                }
                function parseArrowExpression(node, params) {
                    initFunction(node);
                    var defaults = node.defaults, hasDefaults = false;
                    for (var i = 0, lastI = params.length - 1; i <= lastI; i++) {
                        var param = params[i];
                        if (param.type === 'AssignmentExpression' && param.operator === '=') {
                            hasDefaults = true;
                            params[i] = param.left;
                            defaults.push(param.right);
                        } else {
                            toAssignable(param, i === lastI, true);
                            defaults.push(null);
                            if (param.type === 'SpreadElement') {
                                params.length--;
                                node.rest = param.argument;
                                break;
                            }
                        }
                    }
                    node.params = params;
                    if (!hasDefaults)
                        node.defaults = [];
                    parseFunctionBody(node, true);
                    return finishNode(node, 'ArrowFunctionExpression');
                }
                function parseFunctionParams(node) {
                    var defaults = [], hasDefaults = false;
                    expect(_parenL);
                    for (;;) {
                        if (eat(_parenR)) {
                            break;
                        } else if (options.ecmaVersion >= 6 && eat(_ellipsis)) {
                            node.rest = toAssignable(parseExprAtom(), false, true);
                            checkSpreadAssign(node.rest);
                            expect(_parenR);
                            defaults.push(null);
                            break;
                        } else {
                            node.params.push(options.ecmaVersion >= 6 ? toAssignable(parseExprAtom(), false, true) : parseIdent());
                            if (options.ecmaVersion >= 6) {
                                if (eat(_eq)) {
                                    hasDefaults = true;
                                    defaults.push(parseExpression(true));
                                } else {
                                    defaults.push(null);
                                }
                            }
                            if (!eat(_comma)) {
                                expect(_parenR);
                                break;
                            }
                        }
                    }
                    if (hasDefaults)
                        node.defaults = defaults;
                }
                function parseFunctionBody(node, allowExpression) {
                    var isExpression = allowExpression && tokType !== _braceL;
                    if (isExpression) {
                        node.body = parseExpression(true);
                        node.expression = true;
                    } else {
                        var oldInFunc = inFunction, oldInGen = inGenerator, oldLabels = labels;
                        inFunction = true;
                        inGenerator = node.generator;
                        labels = [];
                        node.body = parseBlock(true);
                        node.expression = false;
                        inFunction = oldInFunc;
                        inGenerator = oldInGen;
                        labels = oldLabels;
                    }
                    if (strict || !isExpression && node.body.body.length && isUseStrict(node.body.body[0])) {
                        var nameHash = {};
                        if (node.id)
                            checkFunctionParam(node.id, {});
                        for (var i = 0; i < node.params.length; i++)
                            checkFunctionParam(node.params[i], nameHash);
                        if (node.rest)
                            checkFunctionParam(node.rest, nameHash);
                    }
                }
                function parseClass(node, isStatement) {
                    next();
                    node.id = tokType === _name ? parseIdent() : isStatement ? unexpected() : null;
                    node.superClass = eat(_extends) ? parseExpression() : null;
                    var classBody = startNode(), methodHash = {}, staticMethodHash = {};
                    classBody.body = [];
                    expect(_braceL);
                    while (!eat(_braceR)) {
                        var method = startNode();
                        if (tokType === _name && tokVal === 'static') {
                            next();
                            method['static'] = true;
                        } else {
                            method['static'] = false;
                        }
                        var isGenerator = eat(_star);
                        parsePropertyName(method);
                        if (tokType === _name && !method.computed && method.key.type === 'Identifier' && (method.key.name === 'get' || method.key.name === 'set')) {
                            if (isGenerator)
                                unexpected();
                            method.kind = method.key.name;
                            parsePropertyName(method);
                        } else {
                            method.kind = '';
                        }
                        method.value = parseMethod(isGenerator);
                        checkPropClash(method, method['static'] ? staticMethodHash : methodHash);
                        classBody.body.push(finishNode(method, 'MethodDefinition'));
                        eat(_semi);
                    }
                    node.body = finishNode(classBody, 'ClassBody');
                    return finishNode(node, isStatement ? 'ClassDeclaration' : 'ClassExpression');
                }
                function parseExprList(close, allowTrailingComma, allowEmpty) {
                    var elts = [], first = true;
                    while (!eat(close)) {
                        if (!first) {
                            expect(_comma);
                            if (allowTrailingComma && options.allowTrailingCommas && eat(close))
                                break;
                        } else
                            first = false;
                        if (allowEmpty && tokType === _comma)
                            elts.push(null);
                        else
                            elts.push(parseExpression(true));
                    }
                    return elts;
                }
                function parseIdent(liberal) {
                    var node = startNode();
                    if (liberal && options.forbidReserved == 'everywhere')
                        liberal = false;
                    if (tokType === _name) {
                        if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf('\\') == -1)
                            raise(tokStart, 'The keyword \'' + tokVal + '\' is reserved');
                        node.name = tokVal;
                    } else if (liberal && tokType.keyword) {
                        node.name = tokType.keyword;
                    } else {
                        unexpected();
                    }
                    tokRegexpAllowed = false;
                    next();
                    return finishNode(node, 'Identifier');
                }
                function parseExport(node) {
                    next();
                    if (tokType === _var || tokType === _const || tokType === _let || tokType === _function || tokType === _class) {
                        node.declaration = parseStatement();
                        node['default'] = false;
                        node.specifiers = null;
                        node.source = null;
                    } else if (eat(_default)) {
                        node.declaration = parseExpression(true);
                        node['default'] = true;
                        node.specifiers = null;
                        node.source = null;
                        semicolon();
                    } else {
                        var isBatch = tokType === _star;
                        node.declaration = null;
                        node['default'] = false;
                        node.specifiers = parseExportSpecifiers();
                        if (tokType === _name && tokVal === 'from') {
                            next();
                            node.source = tokType === _string ? parseExprAtom() : unexpected();
                        } else {
                            if (isBatch)
                                unexpected();
                            node.source = null;
                        }
                    }
                    return finishNode(node, 'ExportDeclaration');
                }
                function parseExportSpecifiers() {
                    var nodes = [], first = true;
                    if (tokType === _star) {
                        var node = startNode();
                        next();
                        nodes.push(finishNode(node, 'ExportBatchSpecifier'));
                    } else {
                        expect(_braceL);
                        while (!eat(_braceR)) {
                            if (!first) {
                                expect(_comma);
                                if (options.allowTrailingCommas && eat(_braceR))
                                    break;
                            } else
                                first = false;
                            var node = startNode();
                            node.id = parseIdent();
                            if (tokType === _name && tokVal === 'as') {
                                next();
                                node.name = parseIdent(true);
                            } else {
                                node.name = null;
                            }
                            nodes.push(finishNode(node, 'ExportSpecifier'));
                        }
                    }
                    return nodes;
                }
                function parseImport(node) {
                    next();
                    if (tokType === _string) {
                        node.specifiers = [];
                        node.source = parseExprAtom();
                        node.kind = '';
                    } else {
                        node.specifiers = parseImportSpecifiers();
                        if (tokType !== _name || tokVal !== 'from')
                            unexpected();
                        next();
                        node.source = tokType === _string ? parseExprAtom() : unexpected();
                        node.kind = node.specifiers[0]['default'] ? 'default' : 'named';
                    }
                    return finishNode(node, 'ImportDeclaration');
                }
                function parseImportSpecifiers() {
                    var nodes = [], first = true;
                    if (tokType === _star) {
                        var node = startNode();
                        next();
                        if (tokType !== _name || tokVal !== 'as')
                            unexpected();
                        next();
                        node.name = parseIdent();
                        checkLVal(node.name, true);
                        nodes.push(finishNode(node, 'ImportBatchSpecifier'));
                        return nodes;
                    }
                    if (tokType === _name) {
                        var node = startNode();
                        node.id = parseIdent();
                        checkLVal(node.id, true);
                        node.name = null;
                        node['default'] = true;
                        nodes.push(finishNode(node, 'ImportSpecifier'));
                        if (!eat(_comma))
                            return nodes;
                    }
                    expect(_braceL);
                    while (!eat(_braceR)) {
                        if (!first) {
                            expect(_comma);
                            if (options.allowTrailingCommas && eat(_braceR))
                                break;
                        } else
                            first = false;
                        var node = startNode();
                        node.id = parseIdent(true);
                        if (tokType === _name && tokVal === 'as') {
                            next();
                            node.name = parseIdent();
                        } else {
                            node.name = null;
                        }
                        checkLVal(node.name || node.id, true);
                        node['default'] = false;
                        nodes.push(finishNode(node, 'ImportSpecifier'));
                    }
                    return nodes;
                }
                function parseYield() {
                    var node = startNode();
                    next();
                    if (eat(_semi) || canInsertSemicolon()) {
                        node.delegate = false;
                        node.argument = null;
                    } else {
                        node.delegate = eat(_star);
                        node.argument = parseExpression(true);
                    }
                    return finishNode(node, 'YieldExpression');
                }
                function parseComprehension(node, isGenerator) {
                    node.blocks = [];
                    while (tokType === _for) {
                        var block = startNode();
                        next();
                        expect(_parenL);
                        block.left = toAssignable(parseExprAtom());
                        checkLVal(block.left, true);
                        if (tokType !== _name || tokVal !== 'of')
                            unexpected();
                        next();
                        block.of = true;
                        block.right = parseExpression();
                        expect(_parenR);
                        node.blocks.push(finishNode(block, 'ComprehensionBlock'));
                    }
                    node.filter = eat(_if) ? parseParenExpression() : null;
                    node.body = parseExpression();
                    expect(isGenerator ? _parenR : _bracketR);
                    node.generator = isGenerator;
                    return finishNode(node, 'ComprehensionExpression');
                }
            }));
        });
        _define(21, function (module, exports) {
            module.exports = require(38);
        });
        _define(22, function (module, exports) {
            module.exports = extend;
            function extend() {
                var target = {};
                for (var i = 0; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) {
                        if (source.hasOwnProperty(key)) {
                            target[key] = source[key];
                        }
                    }
                }
                return target;
            }
        });
        _define(23, function (module, exports) {
            'use strict';
            var Promise = require(39)();
            module.exports = Promise;
        });
        _define(24, function (module, exports) {
            var core = require(41);
            exports = module.exports = require(43);
            exports.core = core;
            exports.isCore = function (x) {
                return core[x];
            };
            exports.sync = require(45);
        });
        _define(25, function (module, exports) {
            'use strict';
            var through = require(6);
            module.exports = function () {
                var sources = [];
                var output = through.obj();
                output.setMaxListeners(0);
                output.add = add;
                output.on('unpipe', remove);
                Array.prototype.slice.call(arguments).forEach(add);
                return output;
                function add(source) {
                    if (Array.isArray(source)) {
                        source.forEach(add);
                        return this;
                    }
                    sources.push(source);
                    source.once('end', remove.bind(null, source));
                    source.pipe(output, { end: false });
                    return this;
                }
                function remove(source) {
                    sources = sources.filter(function (it) {
                        return it !== source;
                    });
                    if (!sources.length && output.readable) {
                        output.emit('end');
                    }
                }
            };
        });
        _define(26, function (module, exports) {
            'use strict';
            var defaults = require(51);
            var through = require(6);
            var gs = require(52);
            var File = require(19);
            var getContents = require(50);
            var getStats = require(49);
            function createFile(globFile, enc, cb) {
                cb(null, new File(globFile));
            }
            function src(glob, opt) {
                opt = opt || {};
                var pass = through.obj();
                if (!isValidGlob(glob)) {
                    throw new Error('Invalid glob argument: ' + glob);
                }
                if (Array.isArray(glob) && glob.length === 0) {
                    process.nextTick(pass.end.bind(pass));
                    return pass;
                }
                var options = defaults(opt, {
                    read: true,
                    buffer: true
                });
                var globStream = gs.create(glob, options);
                var outputStream = globStream.pipe(through.obj(createFile)).pipe(getStats(options));
                if (options.read !== false) {
                    outputStream = outputStream.pipe(getContents(options));
                }
                return outputStream.pipe(pass);
            }
            function isValidGlob(glob) {
                if (typeof glob === 'string') {
                    return true;
                }
                if (Array.isArray(glob) && glob.length !== 0) {
                    return glob.every(isValidGlob);
                }
                if (Array.isArray(glob) && glob.length === 0) {
                    return true;
                }
                return false;
            }
            module.exports = src;
        });
        _define(27, function (module, exports) {
            'use strict';
            var defaults = require(51);
            var path = require('path');
            var through2 = require(6);
            var mkdirp = require(55);
            var fs = require(54);
            var writeContents = require(53);
            function dest(outFolder, opt) {
                opt = opt || {};
                if (typeof outFolder !== 'string' && typeof outFolder !== 'function') {
                    throw new Error('Invalid output folder');
                }
                var options = defaults(opt, { cwd: process.cwd() });
                if (typeof options.mode === 'string') {
                    options.mode = parseInt(options.mode, 8);
                }
                var cwd = path.resolve(options.cwd);
                function saveFile(file, enc, cb) {
                    var basePath;
                    if (typeof outFolder === 'string') {
                        basePath = path.resolve(cwd, outFolder);
                    }
                    if (typeof outFolder === 'function') {
                        basePath = path.resolve(cwd, outFolder(file));
                    }
                    var writePath = path.resolve(basePath, file.relative);
                    var writeFolder = path.dirname(writePath);
                    file.stat = file.stat ? file.stat : new fs.Stats();
                    file.stat.mode = options.mode || file.stat.mode;
                    file.cwd = cwd;
                    file.base = basePath;
                    file.path = writePath;
                    mkdirp(writeFolder, function (err) {
                        if (err) {
                            return cb(err);
                        }
                        writeContents(writePath, file, cb);
                    });
                }
                var stream = through2.obj(saveFile);
                stream.resume();
                return stream;
            }
            module.exports = dest;
        });
        _define(28, function (module, exports) {
            var gaze = require(56);
            var EventEmitter = require('events').EventEmitter;
            module.exports = function (glob, opts, cb) {
                var out = new EventEmitter();
                if (typeof opts === 'function') {
                    cb = opts;
                    opts = {};
                }
                var watcher = gaze(glob, opts, function (err, rwatcher) {
                    if (err)
                        out.emit('error', err);
                    rwatcher.on('all', function (evt, path, old) {
                        var outEvt = {
                            type: evt,
                            path: path
                        };
                        if (old)
                            outEvt.old = old;
                        out.emit('change', outEvt);
                        if (cb)
                            cb(outEvt);
                    });
                });
                watcher.on('end', out.emit.bind(out, 'end'));
                watcher.on('error', out.emit.bind(out, 'error'));
                watcher.on('ready', out.emit.bind(out, 'ready'));
                watcher.on('nomatch', out.emit.bind(out, 'nomatch'));
                out.end = function () {
                    return watcher.close();
                };
                out.add = function () {
                    return watcher.add.apply(watcher, arguments);
                };
                out.remove = function () {
                    return watcher.remove();
                };
                out._watcher = watcher;
                return out;
            };
        });
        _define(29, function (module, exports) {
            module.exports = {
                'name': 'escodegen',
                'description': 'ECMAScript code generator',
                'homepage': 'http://github.com/Constellation/escodegen',
                'main': 'escodegen.js',
                'bin': {
                    'esgenerate': './bin/esgenerate.js',
                    'escodegen': './bin/escodegen.js'
                },
                'version': '1.4.1',
                'engines': { 'node': '>=0.10.0' },
                'maintainers': [{
                        'name': 'Yusuke Suzuki',
                        'email': 'utatane.tea@gmail.com',
                        'url': 'http://github.com/Constellation'
                    }],
                'repository': {
                    'type': 'git',
                    'url': 'http://github.com/Constellation/escodegen.git'
                },
                'dependencies': {
                    'estraverse': '^1.5.1',
                    'esutils': '^1.1.4',
                    'esprima': '^1.2.2',
                    'source-map': '~0.1.37'
                },
                'optionalDependencies': { 'source-map': '~0.1.37' },
                'devDependencies': {
                    'esprima-moz': '*',
                    'semver': '^3.0.1',
                    'bluebird': '^2.2.2',
                    'jshint-stylish': '^0.4.0',
                    'chai': '^1.9.1',
                    'gulp-mocha': '^1.0.0',
                    'gulp-eslint': '^0.1.8',
                    'gulp': '^3.8.6',
                    'bower-registry-client': '^0.2.1',
                    'gulp-jshint': '^1.8.0',
                    'commonjs-everywhere': '^0.9.7'
                },
                'licenses': [{
                        'type': 'BSD',
                        'url': 'http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD'
                    }],
                'scripts': {
                    'test': 'gulp travis',
                    'unit-test': 'gulp test',
                    'lint': 'gulp lint',
                    'release': 'node tools/release.js',
                    'build-min': './node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js',
                    'build': './node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js'
                },
                'readme': '### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.svg)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest) [![devDependency Status](https://david-dm.org/Constellation/escodegen/dev-status.svg)](https://david-dm.org/Constellation/escodegen#info=devDependencies)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is an\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Mozilla\'ss Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API)\nAST. See the [online generator](https://constellation.github.io/escodegen/demo/index.html)\nfor a demo.\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src="escodegen.browser.js"></script>\n\nescodegen.browser.js can be found in tagged revisions on GitHub.\n\nOr in a Node.js application via npm:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: \'BinaryExpression\',\n        operator: \'+\',\n        left: { type: \'Literal\', value: 40 },\n        right: { type: \'Literal\', value: 2 }\n    });\n\nproduces the string `\'40 + 2\'`.\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### Building browser bundle / minified browser bundle\n\nAt first, execute `npm install` to install the all dev dependencies.\nAfter that,\n\n    npm run-script build\n\nwill generate `escodegen.browser.js`, which can be used in browser environments.\n\nAnd,\n\n    npm run-script build-min\n\nwill generate the minified file `escodegen.browser.min.js`.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n',
                'readmeFilename': 'README.md',
                'bugs': { 'url': 'https://github.com/Constellation/escodegen/issues' },
                '_id': 'escodegen@1.4.1',
                'dist': { 'shasum': 'e45b7be1026937544535cccf882fc14e5c0e0f2c' },
                '_from': 'escodegen@',
                '_resolved': 'http://registry.npmjs.org/escodegen/-/escodegen-1.4.1.tgz'
            };
        });
        _define(30, function (module, exports) {
            (function (root, factory) {
                'use strict';
                if (typeof define === 'function' && define.amd) {
                    define(['exports'], factory);
                } else if (typeof exports !== 'undefined') {
                    factory(exports);
                } else {
                    factory(root.estraverse = {});
                }
            }(this, function (exports) {
                'use strict';
                var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;
                function ignoreJSHintError() {
                }
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                function deepCopy(obj) {
                    var ret = {}, key, val;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            val = obj[key];
                            if (typeof val === 'object' && val !== null) {
                                ret[key] = deepCopy(val);
                            } else {
                                ret[key] = val;
                            }
                        }
                    }
                    return ret;
                }
                function shallowCopy(obj) {
                    var ret = {}, key;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            ret[key] = obj[key];
                        }
                    }
                    return ret;
                }
                ignoreJSHintError(shallowCopy);
                function upperBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            len = diff;
                        } else {
                            i = current + 1;
                            len -= diff + 1;
                        }
                    }
                    return i;
                }
                function lowerBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            i = current + 1;
                            len -= diff + 1;
                        } else {
                            len = diff;
                        }
                    }
                    return i;
                }
                ignoreJSHintError(lowerBound);
                objectCreate = Object.create || function () {
                    function F() {
                    }
                    return function (o) {
                        F.prototype = o;
                        return new F();
                    };
                }();
                objectKeys = Object.keys || function (o) {
                    var keys = [], key;
                    for (key in o) {
                        keys.push(key);
                    }
                    return keys;
                };
                function extend(to, from) {
                    objectKeys(from).forEach(function (key) {
                        to[key] = from[key];
                    });
                    return to;
                }
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    ArrayPattern: 'ArrayPattern',
                    ArrowFunctionExpression: 'ArrowFunctionExpression',
                    AwaitExpression: 'AwaitExpression',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ClassBody: 'ClassBody',
                    ClassDeclaration: 'ClassDeclaration',
                    ClassExpression: 'ClassExpression',
                    ComprehensionBlock: 'ComprehensionBlock',
                    ComprehensionExpression: 'ComprehensionExpression',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExportBatchSpecifier: 'ExportBatchSpecifier',
                    ExportDeclaration: 'ExportDeclaration',
                    ExportSpecifier: 'ExportSpecifier',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    ForOfStatement: 'ForOfStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    GeneratorExpression: 'GeneratorExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    ImportDeclaration: 'ImportDeclaration',
                    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
                    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
                    ImportSpecifier: 'ImportSpecifier',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    MethodDefinition: 'MethodDefinition',
                    ModuleSpecifier: 'ModuleSpecifier',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    ObjectPattern: 'ObjectPattern',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SpreadElement: 'SpreadElement',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    TaggedTemplateExpression: 'TaggedTemplateExpression',
                    TemplateElement: 'TemplateElement',
                    TemplateLiteral: 'TemplateLiteral',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement',
                    YieldExpression: 'YieldExpression'
                };
                VisitorKeys = {
                    AssignmentExpression: [
                        'left',
                        'right'
                    ],
                    ArrayExpression: ['elements'],
                    ArrayPattern: ['elements'],
                    ArrowFunctionExpression: [
                        'params',
                        'defaults',
                        'rest',
                        'body'
                    ],
                    AwaitExpression: ['argument'],
                    BlockStatement: ['body'],
                    BinaryExpression: [
                        'left',
                        'right'
                    ],
                    BreakStatement: ['label'],
                    CallExpression: [
                        'callee',
                        'arguments'
                    ],
                    CatchClause: [
                        'param',
                        'body'
                    ],
                    ClassBody: ['body'],
                    ClassDeclaration: [
                        'id',
                        'body',
                        'superClass'
                    ],
                    ClassExpression: [
                        'id',
                        'body',
                        'superClass'
                    ],
                    ComprehensionBlock: [
                        'left',
                        'right'
                    ],
                    ComprehensionExpression: [
                        'blocks',
                        'filter',
                        'body'
                    ],
                    ConditionalExpression: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ContinueStatement: ['label'],
                    DebuggerStatement: [],
                    DirectiveStatement: [],
                    DoWhileStatement: [
                        'body',
                        'test'
                    ],
                    EmptyStatement: [],
                    ExportBatchSpecifier: [],
                    ExportDeclaration: [
                        'declaration',
                        'specifiers',
                        'source'
                    ],
                    ExportSpecifier: [
                        'id',
                        'name'
                    ],
                    ExpressionStatement: ['expression'],
                    ForStatement: [
                        'init',
                        'test',
                        'update',
                        'body'
                    ],
                    ForInStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    ForOfStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    FunctionDeclaration: [
                        'id',
                        'params',
                        'defaults',
                        'rest',
                        'body'
                    ],
                    FunctionExpression: [
                        'id',
                        'params',
                        'defaults',
                        'rest',
                        'body'
                    ],
                    GeneratorExpression: [
                        'blocks',
                        'filter',
                        'body'
                    ],
                    Identifier: [],
                    IfStatement: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ImportDeclaration: [
                        'specifiers',
                        'source'
                    ],
                    ImportDefaultSpecifier: ['id'],
                    ImportNamespaceSpecifier: ['id'],
                    ImportSpecifier: [
                        'id',
                        'name'
                    ],
                    Literal: [],
                    LabeledStatement: [
                        'label',
                        'body'
                    ],
                    LogicalExpression: [
                        'left',
                        'right'
                    ],
                    MemberExpression: [
                        'object',
                        'property'
                    ],
                    MethodDefinition: [
                        'key',
                        'value'
                    ],
                    ModuleSpecifier: [],
                    NewExpression: [
                        'callee',
                        'arguments'
                    ],
                    ObjectExpression: ['properties'],
                    ObjectPattern: ['properties'],
                    Program: ['body'],
                    Property: [
                        'key',
                        'value'
                    ],
                    ReturnStatement: ['argument'],
                    SequenceExpression: ['expressions'],
                    SpreadElement: ['argument'],
                    SwitchStatement: [
                        'discriminant',
                        'cases'
                    ],
                    SwitchCase: [
                        'test',
                        'consequent'
                    ],
                    TaggedTemplateExpression: [
                        'tag',
                        'quasi'
                    ],
                    TemplateElement: [],
                    TemplateLiteral: [
                        'quasis',
                        'expressions'
                    ],
                    ThisExpression: [],
                    ThrowStatement: ['argument'],
                    TryStatement: [
                        'block',
                        'handlers',
                        'handler',
                        'guardedHandlers',
                        'finalizer'
                    ],
                    UnaryExpression: ['argument'],
                    UpdateExpression: ['argument'],
                    VariableDeclaration: ['declarations'],
                    VariableDeclarator: [
                        'id',
                        'init'
                    ],
                    WhileStatement: [
                        'test',
                        'body'
                    ],
                    WithStatement: [
                        'object',
                        'body'
                    ],
                    YieldExpression: ['argument']
                };
                BREAK = {};
                SKIP = {};
                REMOVE = {};
                VisitorOption = {
                    Break: BREAK,
                    Skip: SKIP,
                    Remove: REMOVE
                };
                function Reference(parent, key) {
                    this.parent = parent;
                    this.key = key;
                }
                Reference.prototype.replace = function replace(node) {
                    this.parent[this.key] = node;
                };
                Reference.prototype.remove = function remove() {
                    if (isArray(this.parent)) {
                        this.parent.splice(this.key, 1);
                        return true;
                    } else {
                        this.replace(null);
                        return false;
                    }
                };
                function Element(node, path, wrap, ref) {
                    this.node = node;
                    this.path = path;
                    this.wrap = wrap;
                    this.ref = ref;
                }
                function Controller() {
                }
                Controller.prototype.path = function path() {
                    var i, iz, j, jz, result, element;
                    function addToPath(result, path) {
                        if (isArray(path)) {
                            for (j = 0, jz = path.length; j < jz; ++j) {
                                result.push(path[j]);
                            }
                        } else {
                            result.push(path);
                        }
                    }
                    if (!this.__current.path) {
                        return null;
                    }
                    result = [];
                    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
                        element = this.__leavelist[i];
                        addToPath(result, element.path);
                    }
                    addToPath(result, this.__current.path);
                    return result;
                };
                Controller.prototype.type = function () {
                    var node = this.current();
                    return node.type || this.__current.wrap;
                };
                Controller.prototype.parents = function parents() {
                    var i, iz, result;
                    result = [];
                    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
                        result.push(this.__leavelist[i].node);
                    }
                    return result;
                };
                Controller.prototype.current = function current() {
                    return this.__current.node;
                };
                Controller.prototype.__execute = function __execute(callback, element) {
                    var previous, result;
                    result = undefined;
                    previous = this.__current;
                    this.__current = element;
                    this.__state = null;
                    if (callback) {
                        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
                    }
                    this.__current = previous;
                    return result;
                };
                Controller.prototype.notify = function notify(flag) {
                    this.__state = flag;
                };
                Controller.prototype.skip = function () {
                    this.notify(SKIP);
                };
                Controller.prototype['break'] = function () {
                    this.notify(BREAK);
                };
                Controller.prototype.remove = function () {
                    this.notify(REMOVE);
                };
                Controller.prototype.__initialize = function (root, visitor) {
                    this.visitor = visitor;
                    this.root = root;
                    this.__worklist = [];
                    this.__leavelist = [];
                    this.__current = null;
                    this.__state = null;
                    this.__fallback = visitor.fallback === 'iteration';
                    this.__keys = VisitorKeys;
                    if (visitor.keys) {
                        this.__keys = extend(objectCreate(this.__keys), visitor.keys);
                    }
                };
                function isNode(node) {
                    if (node == null) {
                        return false;
                    }
                    return typeof node === 'object' && typeof node.type === 'string';
                }
                function isProperty(nodeType, key) {
                    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
                }
                Controller.prototype.traverse = function traverse(root, visitor) {
                    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
                    this.__initialize(root, visitor);
                    sentinel = {};
                    worklist = this.__worklist;
                    leavelist = this.__leavelist;
                    worklist.push(new Element(root, null, null, null));
                    leavelist.push(new Element(null, null, null, null));
                    while (worklist.length) {
                        element = worklist.pop();
                        if (element === sentinel) {
                            element = leavelist.pop();
                            ret = this.__execute(visitor.leave, element);
                            if (this.__state === BREAK || ret === BREAK) {
                                return;
                            }
                            continue;
                        }
                        if (element.node) {
                            ret = this.__execute(visitor.enter, element);
                            if (this.__state === BREAK || ret === BREAK) {
                                return;
                            }
                            worklist.push(sentinel);
                            leavelist.push(element);
                            if (this.__state === SKIP || ret === SKIP) {
                                continue;
                            }
                            node = element.node;
                            nodeType = element.wrap || node.type;
                            candidates = this.__keys[nodeType];
                            if (!candidates) {
                                if (this.__fallback) {
                                    candidates = objectKeys(node);
                                } else {
                                    throw new Error('Unknown node type ' + nodeType + '.');
                                }
                            }
                            current = candidates.length;
                            while ((current -= 1) >= 0) {
                                key = candidates[current];
                                candidate = node[key];
                                if (!candidate) {
                                    continue;
                                }
                                if (isArray(candidate)) {
                                    current2 = candidate.length;
                                    while ((current2 -= 1) >= 0) {
                                        if (!candidate[current2]) {
                                            continue;
                                        }
                                        if (isProperty(nodeType, candidates[current])) {
                                            element = new Element(candidate[current2], [
                                                key,
                                                current2
                                            ], 'Property', null);
                                        } else if (isNode(candidate[current2])) {
                                            element = new Element(candidate[current2], [
                                                key,
                                                current2
                                            ], null, null);
                                        } else {
                                            continue;
                                        }
                                        worklist.push(element);
                                    }
                                } else if (isNode(candidate)) {
                                    worklist.push(new Element(candidate, key, null, null));
                                }
                            }
                        }
                    }
                };
                Controller.prototype.replace = function replace(root, visitor) {
                    function removeElem(element) {
                        var i, key, nextElem, parent;
                        if (element.ref.remove()) {
                            key = element.ref.key;
                            parent = element.ref.parent;
                            i = worklist.length;
                            while (i--) {
                                nextElem = worklist[i];
                                if (nextElem.ref && nextElem.ref.parent === parent) {
                                    if (nextElem.ref.key < key) {
                                        break;
                                    }
                                    --nextElem.ref.key;
                                }
                            }
                        }
                    }
                    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
                    this.__initialize(root, visitor);
                    sentinel = {};
                    worklist = this.__worklist;
                    leavelist = this.__leavelist;
                    outer = { root: root };
                    element = new Element(root, null, null, new Reference(outer, 'root'));
                    worklist.push(element);
                    leavelist.push(element);
                    while (worklist.length) {
                        element = worklist.pop();
                        if (element === sentinel) {
                            element = leavelist.pop();
                            target = this.__execute(visitor.leave, element);
                            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                                element.ref.replace(target);
                            }
                            if (this.__state === REMOVE || target === REMOVE) {
                                removeElem(element);
                            }
                            if (this.__state === BREAK || target === BREAK) {
                                return outer.root;
                            }
                            continue;
                        }
                        target = this.__execute(visitor.enter, element);
                        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                            element.ref.replace(target);
                            element.node = target;
                        }
                        if (this.__state === REMOVE || target === REMOVE) {
                            removeElem(element);
                            element.node = null;
                        }
                        if (this.__state === BREAK || target === BREAK) {
                            return outer.root;
                        }
                        node = element.node;
                        if (!node) {
                            continue;
                        }
                        worklist.push(sentinel);
                        leavelist.push(element);
                        if (this.__state === SKIP || target === SKIP) {
                            continue;
                        }
                        nodeType = element.wrap || node.type;
                        candidates = this.__keys[nodeType];
                        if (!candidates) {
                            if (this.__fallback) {
                                candidates = objectKeys(node);
                            } else {
                                throw new Error('Unknown node type ' + nodeType + '.');
                            }
                        }
                        current = candidates.length;
                        while ((current -= 1) >= 0) {
                            key = candidates[current];
                            candidate = node[key];
                            if (!candidate) {
                                continue;
                            }
                            if (isArray(candidate)) {
                                current2 = candidate.length;
                                while ((current2 -= 1) >= 0) {
                                    if (!candidate[current2]) {
                                        continue;
                                    }
                                    if (isProperty(nodeType, candidates[current])) {
                                        element = new Element(candidate[current2], [
                                            key,
                                            current2
                                        ], 'Property', new Reference(candidate, current2));
                                    } else if (isNode(candidate[current2])) {
                                        element = new Element(candidate[current2], [
                                            key,
                                            current2
                                        ], null, new Reference(candidate, current2));
                                    } else {
                                        continue;
                                    }
                                    worklist.push(element);
                                }
                            } else if (isNode(candidate)) {
                                worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                            }
                        }
                    }
                    return outer.root;
                };
                function traverse(root, visitor) {
                    var controller = new Controller();
                    return controller.traverse(root, visitor);
                }
                function replace(root, visitor) {
                    var controller = new Controller();
                    return controller.replace(root, visitor);
                }
                function extendCommentRange(comment, tokens) {
                    var target;
                    target = upperBound(tokens, function search(token) {
                        return token.range[0] > comment.range[0];
                    });
                    comment.extendedRange = [
                        comment.range[0],
                        comment.range[1]
                    ];
                    if (target !== tokens.length) {
                        comment.extendedRange[1] = tokens[target].range[0];
                    }
                    target -= 1;
                    if (target >= 0) {
                        comment.extendedRange[0] = tokens[target].range[1];
                    }
                    return comment;
                }
                function attachComments(tree, providedComments, tokens) {
                    var comments = [], comment, len, i, cursor;
                    if (!tree.range) {
                        throw new Error('attachComments needs range information');
                    }
                    if (!tokens.length) {
                        if (providedComments.length) {
                            for (i = 0, len = providedComments.length; i < len; i += 1) {
                                comment = deepCopy(providedComments[i]);
                                comment.extendedRange = [
                                    0,
                                    tree.range[0]
                                ];
                                comments.push(comment);
                            }
                            tree.leadingComments = comments;
                        }
                        return tree;
                    }
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
                    }
                    cursor = 0;
                    traverse(tree, {
                        enter: function (node) {
                            var comment;
                            while (cursor < comments.length) {
                                comment = comments[cursor];
                                if (comment.extendedRange[1] > node.range[0]) {
                                    break;
                                }
                                if (comment.extendedRange[1] === node.range[0]) {
                                    if (!node.leadingComments) {
                                        node.leadingComments = [];
                                    }
                                    node.leadingComments.push(comment);
                                    comments.splice(cursor, 1);
                                } else {
                                    cursor += 1;
                                }
                            }
                            if (cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    cursor = 0;
                    traverse(tree, {
                        leave: function (node) {
                            var comment;
                            while (cursor < comments.length) {
                                comment = comments[cursor];
                                if (node.range[1] < comment.extendedRange[0]) {
                                    break;
                                }
                                if (node.range[1] === comment.extendedRange[0]) {
                                    if (!node.trailingComments) {
                                        node.trailingComments = [];
                                    }
                                    node.trailingComments.push(comment);
                                    comments.splice(cursor, 1);
                                } else {
                                    cursor += 1;
                                }
                            }
                            if (cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    return tree;
                }
                exports.version = '1.8.1-dev';
                exports.Syntax = Syntax;
                exports.traverse = traverse;
                exports.replace = replace;
                exports.attachComments = attachComments;
                exports.VisitorKeys = VisitorKeys;
                exports.VisitorOption = VisitorOption;
                exports.Controller = Controller;
            }));
        });
        _define(31, function (module, exports) {
            (function () {
                'use strict';
                exports.ast = require(57);
                exports.code = require(60);
                exports.keyword = require(63);
            }());
        });
        _define(32, function (module, exports) {
            exports = module.exports = require(58);
            exports.Stream = require('stream');
            exports.Readable = exports;
            exports.Writable = require(61);
            exports.Duplex = require(64);
            exports.Transform = require(66);
            exports.PassThrough = require(68);
        });
        _define(33, function (module, exports) {
            exports.Statement = exports.Expression = skip;
            exports.Literal = exports.Identifier = exports.EmptyStatement = exports.ThisExpression = exports.BreakStatement = exports.ContinueStatement = exports.DebuggerStatement = ignore;
            exports.Program = exports.BlockStatement = function (node, fn) {
                for (var i = 0; i < node.body.length; ++i) {
                    node.body[i].parentNode = node;
                    fn(node.body[i], 'Statement');
                    delete node.body[i].parentNode;
                }
            };
            exports.ExpressionStatement = function (node, fn) {
                node.expression.parentNode = node;
                fn(node.expression, 'Expression');
                delete node.expression.parentNode;
            };
            exports.IfStatement = function (node, fn) {
                node.test.parentNode = node;
                fn(node.test, 'Expression');
                delete node.test.parentNode;
                node.consequent.parentNode = node;
                fn(node.consequent, 'Statement');
                delete node.consequent.parentNode;
                if (node.alternate) {
                    node.alternate.parentNode = node;
                    fn(node.alternate, 'Statement');
                    delete node.alternate.parentNode;
                }
            };
            exports.LabeledStatement = function (node, fn) {
                node.body.parentNode = node;
                fn(node.body, 'Statement');
                delete node.body.parentNode;
            };
            exports.WithStatement = function (node, fn) {
                node.object.parentNode = node;
                fn(node.object, 'Expression');
                delete node.object.parentNode;
                node.body.parentNode = node;
                fn(node.body, 'Statement');
                delete node.body.parentNode;
            };
            exports.SwitchStatement = function (node, fn) {
                node.discriminant.parentNode = node;
                fn(node.discriminant, 'Expression');
                delete node.discriminant.parentNode;
                for (var i = 0; i < node.cases.length; ++i) {
                    var cs = node.cases[i];
                    if (cs.test) {
                        cs.test.parentNode = node;
                        fn(cs.test, 'Expression');
                        delete cs.test.parentNode;
                    }
                    for (var j = 0; j < cs.consequent.length; ++j) {
                        cs.consequent[j].parentNode = node;
                        fn(cs.consequent[j], 'Statement');
                        delete cs.consequent[j].parentNode;
                    }
                }
            };
            exports.ReturnStatement = function (node, fn) {
                if (node.argument) {
                    node.argument.parentNode = node;
                    fn(node.argument, 'Expression');
                    delete node.argument.parentNode;
                }
            };
            exports.ThrowStatement = function (node, fn) {
                node.argument.parentNode = node;
                fn(node.argument, 'Expression');
                delete node.argument.parentNode;
            };
            exports.TryStatement = function (node, fn) {
                node.block.parentNode = node;
                fn(node.block, 'Statement');
                delete node.block.parentNode;
                if (node.handler) {
                    node.handler.body.parentNode = node;
                    fn(node.handler.body, 'ScopeBody');
                    delete node.handler.body.parentNode;
                }
                if (node.finalizer) {
                    node.finalizer.parentNode = node;
                    fn(node.finalizer, 'Statement');
                    delete node.finalizer.parentNode;
                }
            };
            exports.WhileStatement = exports.DoWhileStatement = function (node, fn) {
                node.test.parentNode = node;
                fn(node.test, 'Expression');
                delete node.test.parentNode;
                node.body.parentNode = node;
                fn(node.body, 'Statement');
                delete node.body.parentNode;
            };
            exports.ForStatement = function (node, fn) {
                if (node.init) {
                    node.init.parentNode = node;
                    fn(node.init, 'ForInit');
                    delete node.init.parentNode;
                }
                if (node.test) {
                    node.test.parentNode = node;
                    fn(node.test, 'Expression');
                    delete node.test.parentNode;
                }
                if (node.update) {
                    node.update.parentNode = node;
                    fn(node.update, 'Expression');
                    delete node.update.parentNode;
                }
                node.body.parentNode = node;
                fn(node.body, 'Statement');
                delete node.body.parentNode;
            };
            exports.ForInStatement = function (node, fn) {
                node.left.parentNode = node;
                fn(node.left, 'ForInit');
                delete node.left.parentNode;
                node.right.parentNode = node;
                fn(node.right, 'Expression');
                delete node.right.parentNode;
                node.body.parentNode = node;
                fn(node.body, 'Statement');
                delete node.body.parentNode;
            };
            exports.ForInit = function (node, fn) {
                if (node.type == 'VariableDeclaration')
                    fn(node);
                else
                    fn(node, 'Expression');
            };
            exports.Function = function (node, fn) {
                node.body.parentNode = node;
                fn(node.body, 'ScopeBody');
                delete node.body.parentNode;
            };
            exports.FunctionExpression = exports.FunctionDeclaration = function (node, fn) {
                fn(node, 'Function');
            };
            exports.VariableDeclaration = function (node, fn) {
                for (var i = 0; i < node.declarations.length; ++i) {
                    var decl = node.declarations[i];
                    if (decl.init) {
                        decl.init.parentNode = node;
                        fn(decl.init, 'Expression');
                        delete decl.init.parentNode;
                    }
                }
            };
            exports.ScopeBody = function (node, fn) {
                fn(node, 'Statement');
            };
            exports.ArrayExpression = function (node, fn) {
                for (var i = 0; i < node.elements.length; ++i) {
                    var elt = node.elements[i];
                    if (elt) {
                        elt.parentNode = node;
                        fn(elt, 'Expression');
                        delete elt.parentNode;
                    }
                }
            };
            exports.ObjectExpression = function (node, fn) {
                for (var i = 0; i < node.properties.length; ++i) {
                    node.properties[i].value.parentNode = node;
                    fn(node.properties[i].value, 'Expression');
                    delete node.properties[i].value.parentNode;
                }
            };
            exports.SequenceExpression = function (node, fn) {
                for (var i = 0; i < node.expressions.length; ++i) {
                    node.expressions[i].parentNode = node;
                    fn(node.expressions[i], 'Expression');
                    delete node.expressions[i].parentNode;
                }
            };
            exports.UnaryExpression = exports.UpdateExpression = function (node, fn) {
                node.argument.parentNode = node;
                fn(node.argument, 'Expression');
                delete node.argument.parentNode;
            };
            exports.BinaryExpression = exports.LogicalExpression = exports.AssignmentExpression = function (node, fn) {
                node.left.parentNode = node;
                fn(node.left, 'Expression');
                delete node.left.parentNode;
                node.right.parentNode = node;
                fn(node.right, 'Expression');
                delete node.right.parentNode;
            };
            exports.ConditionalExpression = function (node, fn) {
                node.test.parentNode = node;
                fn(node.test, 'Expression');
                delete node.test.parentNode;
                node.consequent.parentNode = node;
                fn(node.consequent, 'Expression');
                delete node.consequent.parentNode;
                node.alternate.parentNode = node;
                fn(node.alternate, 'Expression');
                delete node.alternate.parentNode;
            };
            exports.NewExpression = exports.CallExpression = function (node, fn) {
                node.callee.parentNode = node;
                fn(node.callee, 'Expression');
                delete node.callee.parentNode;
                if (!node.arguments)
                    return;
                for (var i = 0; i < node.arguments.length; ++i) {
                    node.arguments[i].parentNode = node;
                    fn(node.arguments[i], 'Expression');
                    delete node.arguments[i].parentNode;
                }
            };
            exports.MemberExpression = function (node, fn) {
                node.object.parentNode = node;
                fn(node.object, 'Expression');
                delete node.object.parentNode;
                if (node.computed) {
                    node.property.parentNode = node;
                    fn(node.property, 'Expression');
                    delete node.property.parentNode;
                }
            };
            function skip(node, fn) {
                fn(node, false);
            }
            function ignore(node, fn) {
            }
        });
        _define(34, function (module, exports) {
            exports.SourceMapGenerator = require(59).SourceMapGenerator;
            exports.SourceMapConsumer = require(62).SourceMapConsumer;
            exports.SourceNode = require(65).SourceNode;
        });
        _define(35, function (module, exports) {
            (function (root, factory) {
                'use strict';
                if (typeof define === 'function' && define.amd) {
                    define(['exports'], factory);
                } else if (typeof exports !== 'undefined') {
                    factory(exports);
                } else {
                    factory(root.esprima = {});
                }
            }(this, function (exports) {
                'use strict';
                var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;
                Token = {
                    BooleanLiteral: 1,
                    EOF: 2,
                    Identifier: 3,
                    Keyword: 4,
                    NullLiteral: 5,
                    NumericLiteral: 6,
                    Punctuator: 7,
                    StringLiteral: 8,
                    RegularExpression: 9
                };
                TokenName = {};
                TokenName[Token.BooleanLiteral] = 'Boolean';
                TokenName[Token.EOF] = '<end>';
                TokenName[Token.Identifier] = 'Identifier';
                TokenName[Token.Keyword] = 'Keyword';
                TokenName[Token.NullLiteral] = 'Null';
                TokenName[Token.NumericLiteral] = 'Numeric';
                TokenName[Token.Punctuator] = 'Punctuator';
                TokenName[Token.StringLiteral] = 'String';
                TokenName[Token.RegularExpression] = 'RegularExpression';
                FnExprTokens = [
                    '(',
                    '{',
                    '[',
                    'in',
                    'typeof',
                    'instanceof',
                    'new',
                    'return',
                    'case',
                    'delete',
                    'throw',
                    'void',
                    '=',
                    '+=',
                    '-=',
                    '*=',
                    '/=',
                    '%=',
                    '<<=',
                    '>>=',
                    '>>>=',
                    '&=',
                    '|=',
                    '^=',
                    ',',
                    '+',
                    '-',
                    '*',
                    '/',
                    '%',
                    '++',
                    '--',
                    '<<',
                    '>>',
                    '>>>',
                    '&',
                    '|',
                    '^',
                    '!',
                    '~',
                    '&&',
                    '||',
                    '?',
                    ':',
                    '===',
                    '==',
                    '>=',
                    '<=',
                    '<',
                    '>',
                    '!=',
                    '!=='
                ];
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement'
                };
                PropertyKind = {
                    Data: 1,
                    Get: 2,
                    Set: 4
                };
                Messages = {
                    UnexpectedToken: 'Unexpected token %0',
                    UnexpectedNumber: 'Unexpected number',
                    UnexpectedString: 'Unexpected string',
                    UnexpectedIdentifier: 'Unexpected identifier',
                    UnexpectedReserved: 'Unexpected reserved word',
                    UnexpectedEOS: 'Unexpected end of input',
                    NewlineAfterThrow: 'Illegal newline after throw',
                    InvalidRegExp: 'Invalid regular expression',
                    UnterminatedRegExp: 'Invalid regular expression: missing /',
                    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
                    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
                    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
                    NoCatchOrFinally: 'Missing catch or finally after try',
                    UnknownLabel: 'Undefined label \'%0\'',
                    Redeclaration: '%0 \'%1\' has already been declared',
                    IllegalContinue: 'Illegal continue statement',
                    IllegalBreak: 'Illegal break statement',
                    IllegalReturn: 'Illegal return statement',
                    StrictModeWith: 'Strict mode code may not include a with statement',
                    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
                    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
                    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
                    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
                    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
                    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
                    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
                    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
                    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
                    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
                    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
                    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
                    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
                    StrictReservedWord: 'Use of future reserved word in strict mode'
                };
                Regex = {
                    NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
                    NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
                };
                function assert(condition, message) {
                    if (!condition) {
                        throw new Error('ASSERT: ' + message);
                    }
                }
                function isDecimalDigit(ch) {
                    return ch >= 48 && ch <= 57;
                }
                function isHexDigit(ch) {
                    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
                }
                function isOctalDigit(ch) {
                    return '01234567'.indexOf(ch) >= 0;
                }
                function isWhiteSpace(ch) {
                    return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [
                        5760,
                        6158,
                        8192,
                        8193,
                        8194,
                        8195,
                        8196,
                        8197,
                        8198,
                        8199,
                        8200,
                        8201,
                        8202,
                        8239,
                        8287,
                        12288,
                        65279
                    ].indexOf(ch) >= 0;
                }
                function isLineTerminator(ch) {
                    return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
                }
                function isIdentifierStart(ch) {
                    return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
                }
                function isIdentifierPart(ch) {
                    return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
                }
                function isFutureReservedWord(id) {
                    switch (id) {
                    case 'class':
                    case 'enum':
                    case 'export':
                    case 'extends':
                    case 'import':
                    case 'super':
                        return true;
                    default:
                        return false;
                    }
                }
                function isStrictModeReservedWord(id) {
                    switch (id) {
                    case 'implements':
                    case 'interface':
                    case 'package':
                    case 'private':
                    case 'protected':
                    case 'public':
                    case 'static':
                    case 'yield':
                    case 'let':
                        return true;
                    default:
                        return false;
                    }
                }
                function isRestrictedWord(id) {
                    return id === 'eval' || id === 'arguments';
                }
                function isKeyword(id) {
                    if (strict && isStrictModeReservedWord(id)) {
                        return true;
                    }
                    switch (id.length) {
                    case 2:
                        return id === 'if' || id === 'in' || id === 'do';
                    case 3:
                        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
                    case 4:
                        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
                    case 5:
                        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
                    case 6:
                        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
                    case 7:
                        return id === 'default' || id === 'finally' || id === 'extends';
                    case 8:
                        return id === 'function' || id === 'continue' || id === 'debugger';
                    case 10:
                        return id === 'instanceof';
                    default:
                        return false;
                    }
                }
                function addComment(type, value, start, end, loc) {
                    var comment, attacher;
                    assert(typeof start === 'number', 'Comment must have valid position');
                    if (state.lastCommentStart >= start) {
                        return;
                    }
                    state.lastCommentStart = start;
                    comment = {
                        type: type,
                        value: value
                    };
                    if (extra.range) {
                        comment.range = [
                            start,
                            end
                        ];
                    }
                    if (extra.loc) {
                        comment.loc = loc;
                    }
                    extra.comments.push(comment);
                    if (extra.attachComment) {
                        extra.leadingComments.push(comment);
                        extra.trailingComments.push(comment);
                    }
                }
                function skipSingleLineComment(offset) {
                    var start, loc, ch, comment;
                    start = index - offset;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart - offset
                        }
                    };
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        ++index;
                        if (isLineTerminator(ch)) {
                            if (extra.comments) {
                                comment = source.slice(start + offset, index - 1);
                                loc.end = {
                                    line: lineNumber,
                                    column: index - lineStart - 1
                                };
                                addComment('Line', comment, start, index - 1, loc);
                            }
                            if (ch === 13 && source.charCodeAt(index) === 10) {
                                ++index;
                            }
                            ++lineNumber;
                            lineStart = index;
                            return;
                        }
                    }
                    if (extra.comments) {
                        comment = source.slice(start + offset, index);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Line', comment, start, index, loc);
                    }
                }
                function skipMultiLineComment() {
                    var start, loc, ch, comment;
                    if (extra.comments) {
                        start = index - 2;
                        loc = {
                            start: {
                                line: lineNumber,
                                column: index - lineStart - 2
                            }
                        };
                    }
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (isLineTerminator(ch)) {
                            if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                                ++index;
                            }
                            ++lineNumber;
                            ++index;
                            lineStart = index;
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                            }
                        } else if (ch === 42) {
                            if (source.charCodeAt(index + 1) === 47) {
                                ++index;
                                ++index;
                                if (extra.comments) {
                                    comment = source.slice(start + 2, index - 2);
                                    loc.end = {
                                        line: lineNumber,
                                        column: index - lineStart
                                    };
                                    addComment('Block', comment, start, index, loc);
                                }
                                return;
                            }
                            ++index;
                        } else {
                            ++index;
                        }
                    }
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                function skipComment() {
                    var ch, start;
                    start = index === 0;
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (isWhiteSpace(ch)) {
                            ++index;
                        } else if (isLineTerminator(ch)) {
                            ++index;
                            if (ch === 13 && source.charCodeAt(index) === 10) {
                                ++index;
                            }
                            ++lineNumber;
                            lineStart = index;
                            start = true;
                        } else if (ch === 47) {
                            ch = source.charCodeAt(index + 1);
                            if (ch === 47) {
                                ++index;
                                ++index;
                                skipSingleLineComment(2);
                                start = true;
                            } else if (ch === 42) {
                                ++index;
                                ++index;
                                skipMultiLineComment();
                            } else {
                                break;
                            }
                        } else if (start && ch === 45) {
                            if (source.charCodeAt(index + 1) === 45 && source.charCodeAt(index + 2) === 62) {
                                index += 3;
                                skipSingleLineComment(3);
                            } else {
                                break;
                            }
                        } else if (ch === 60) {
                            if (source.slice(index + 1, index + 4) === '!--') {
                                ++index;
                                ++index;
                                ++index;
                                ++index;
                                skipSingleLineComment(4);
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
                function scanHexEscape(prefix) {
                    var i, len, ch, code = 0;
                    len = prefix === 'u' ? 4 : 2;
                    for (i = 0; i < len; ++i) {
                        if (index < length && isHexDigit(source[index])) {
                            ch = source[index++];
                            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                        } else {
                            return '';
                        }
                    }
                    return String.fromCharCode(code);
                }
                function getEscapedIdentifier() {
                    var ch, id;
                    ch = source.charCodeAt(index++);
                    id = String.fromCharCode(ch);
                    if (ch === 92) {
                        if (source.charCodeAt(index) !== 117) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                        ++index;
                        ch = scanHexEscape('u');
                        if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                        id = ch;
                    }
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (!isIdentifierPart(ch)) {
                            break;
                        }
                        ++index;
                        id += String.fromCharCode(ch);
                        if (ch === 92) {
                            id = id.substr(0, id.length - 1);
                            if (source.charCodeAt(index) !== 117) {
                                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                            }
                            ++index;
                            ch = scanHexEscape('u');
                            if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                            }
                            id += ch;
                        }
                    }
                    return id;
                }
                function getIdentifier() {
                    var start, ch;
                    start = index++;
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (ch === 92) {
                            index = start;
                            return getEscapedIdentifier();
                        }
                        if (isIdentifierPart(ch)) {
                            ++index;
                        } else {
                            break;
                        }
                    }
                    return source.slice(start, index);
                }
                function scanIdentifier() {
                    var start, id, type;
                    start = index;
                    id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
                    if (id.length === 1) {
                        type = Token.Identifier;
                    } else if (isKeyword(id)) {
                        type = Token.Keyword;
                    } else if (id === 'null') {
                        type = Token.NullLiteral;
                    } else if (id === 'true' || id === 'false') {
                        type = Token.BooleanLiteral;
                    } else {
                        type = Token.Identifier;
                    }
                    return {
                        type: type,
                        value: id,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
                function scanPunctuator() {
                    var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
                    switch (code) {
                    case 46:
                    case 40:
                    case 41:
                    case 59:
                    case 44:
                    case 123:
                    case 125:
                    case 91:
                    case 93:
                    case 58:
                    case 63:
                    case 126:
                        ++index;
                        if (extra.tokenize) {
                            if (code === 40) {
                                extra.openParenToken = extra.tokens.length;
                            } else if (code === 123) {
                                extra.openCurlyToken = extra.tokens.length;
                            }
                        }
                        return {
                            type: Token.Punctuator,
                            value: String.fromCharCode(code),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    default:
                        code2 = source.charCodeAt(index + 1);
                        if (code2 === 61) {
                            switch (code) {
                            case 43:
                            case 45:
                            case 47:
                            case 60:
                            case 62:
                            case 94:
                            case 124:
                            case 37:
                            case 38:
                            case 42:
                                index += 2;
                                return {
                                    type: Token.Punctuator,
                                    value: String.fromCharCode(code) + String.fromCharCode(code2),
                                    lineNumber: lineNumber,
                                    lineStart: lineStart,
                                    start: start,
                                    end: index
                                };
                            case 33:
                            case 61:
                                index += 2;
                                if (source.charCodeAt(index) === 61) {
                                    ++index;
                                }
                                return {
                                    type: Token.Punctuator,
                                    value: source.slice(start, index),
                                    lineNumber: lineNumber,
                                    lineStart: lineStart,
                                    start: start,
                                    end: index
                                };
                            }
                        }
                    }
                    ch4 = source.substr(index, 4);
                    if (ch4 === '>>>=') {
                        index += 4;
                        return {
                            type: Token.Punctuator,
                            value: ch4,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }
                    ch3 = ch4.substr(0, 3);
                    if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
                        index += 3;
                        return {
                            type: Token.Punctuator,
                            value: ch3,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }
                    ch2 = ch3.substr(0, 2);
                    if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
                        index += 2;
                        return {
                            type: Token.Punctuator,
                            value: ch2,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }
                    if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                        ++index;
                        return {
                            type: Token.Punctuator,
                            value: ch1,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                function scanHexLiteral(start) {
                    var number = '';
                    while (index < length) {
                        if (!isHexDigit(source[index])) {
                            break;
                        }
                        number += source[index++];
                    }
                    if (number.length === 0) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    if (isIdentifierStart(source.charCodeAt(index))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt('0x' + number, 16),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
                function scanOctalLiteral(start) {
                    var number = '0' + source[index++];
                    while (index < length) {
                        if (!isOctalDigit(source[index])) {
                            break;
                        }
                        number += source[index++];
                    }
                    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 8),
                        octal: true,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
                function scanNumericLiteral() {
                    var number, start, ch;
                    ch = source[index];
                    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
                    start = index;
                    number = '';
                    if (ch !== '.') {
                        number = source[index++];
                        ch = source[index];
                        if (number === '0') {
                            if (ch === 'x' || ch === 'X') {
                                ++index;
                                return scanHexLiteral(start);
                            }
                            if (isOctalDigit(ch)) {
                                return scanOctalLiteral(start);
                            }
                            if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                            }
                        }
                        while (isDecimalDigit(source.charCodeAt(index))) {
                            number += source[index++];
                        }
                        ch = source[index];
                    }
                    if (ch === '.') {
                        number += source[index++];
                        while (isDecimalDigit(source.charCodeAt(index))) {
                            number += source[index++];
                        }
                        ch = source[index];
                    }
                    if (ch === 'e' || ch === 'E') {
                        number += source[index++];
                        ch = source[index];
                        if (ch === '+' || ch === '-') {
                            number += source[index++];
                        }
                        if (isDecimalDigit(source.charCodeAt(index))) {
                            while (isDecimalDigit(source.charCodeAt(index))) {
                                number += source[index++];
                            }
                        } else {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    if (isIdentifierStart(source.charCodeAt(index))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseFloat(number),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
                function scanStringLiteral() {
                    var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
                    startLineNumber = lineNumber;
                    startLineStart = lineStart;
                    quote = source[index];
                    assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
                    start = index;
                    ++index;
                    while (index < length) {
                        ch = source[index++];
                        if (ch === quote) {
                            quote = '';
                            break;
                        } else if (ch === '\\') {
                            ch = source[index++];
                            if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                                switch (ch) {
                                case 'u':
                                case 'x':
                                    restore = index;
                                    unescaped = scanHexEscape(ch);
                                    if (unescaped) {
                                        str += unescaped;
                                    } else {
                                        index = restore;
                                        str += ch;
                                    }
                                    break;
                                case 'n':
                                    str += '\n';
                                    break;
                                case 'r':
                                    str += '\r';
                                    break;
                                case 't':
                                    str += '\t';
                                    break;
                                case 'b':
                                    str += '\b';
                                    break;
                                case 'f':
                                    str += '\f';
                                    break;
                                case 'v':
                                    str += '\x0B';
                                    break;
                                default:
                                    if (isOctalDigit(ch)) {
                                        code = '01234567'.indexOf(ch);
                                        if (code !== 0) {
                                            octal = true;
                                        }
                                        if (index < length && isOctalDigit(source[index])) {
                                            octal = true;
                                            code = code * 8 + '01234567'.indexOf(source[index++]);
                                            if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                                                code = code * 8 + '01234567'.indexOf(source[index++]);
                                            }
                                        }
                                        str += String.fromCharCode(code);
                                    } else {
                                        str += ch;
                                    }
                                    break;
                                }
                            } else {
                                ++lineNumber;
                                if (ch === '\r' && source[index] === '\n') {
                                    ++index;
                                }
                                lineStart = index;
                            }
                        } else if (isLineTerminator(ch.charCodeAt(0))) {
                            break;
                        } else {
                            str += ch;
                        }
                    }
                    if (quote !== '') {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    return {
                        type: Token.StringLiteral,
                        value: str,
                        octal: octal,
                        startLineNumber: startLineNumber,
                        startLineStart: startLineStart,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
                function testRegExp(pattern, flags) {
                    var value;
                    try {
                        value = new RegExp(pattern, flags);
                    } catch (e) {
                        throwError({}, Messages.InvalidRegExp);
                    }
                    return value;
                }
                function scanRegExpBody() {
                    var ch, str, classMarker, terminated, body;
                    ch = source[index];
                    assert(ch === '/', 'Regular expression literal must start with a slash');
                    str = source[index++];
                    classMarker = false;
                    terminated = false;
                    while (index < length) {
                        ch = source[index++];
                        str += ch;
                        if (ch === '\\') {
                            ch = source[index++];
                            if (isLineTerminator(ch.charCodeAt(0))) {
                                throwError({}, Messages.UnterminatedRegExp);
                            }
                            str += ch;
                        } else if (isLineTerminator(ch.charCodeAt(0))) {
                            throwError({}, Messages.UnterminatedRegExp);
                        } else if (classMarker) {
                            if (ch === ']') {
                                classMarker = false;
                            }
                        } else {
                            if (ch === '/') {
                                terminated = true;
                                break;
                            } else if (ch === '[') {
                                classMarker = true;
                            }
                        }
                    }
                    if (!terminated) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    body = str.substr(1, str.length - 2);
                    return {
                        value: body,
                        literal: str
                    };
                }
                function scanRegExpFlags() {
                    var ch, str, flags, restore;
                    str = '';
                    flags = '';
                    while (index < length) {
                        ch = source[index];
                        if (!isIdentifierPart(ch.charCodeAt(0))) {
                            break;
                        }
                        ++index;
                        if (ch === '\\' && index < length) {
                            ch = source[index];
                            if (ch === 'u') {
                                ++index;
                                restore = index;
                                ch = scanHexEscape('u');
                                if (ch) {
                                    flags += ch;
                                    for (str += '\\u'; restore < index; ++restore) {
                                        str += source[restore];
                                    }
                                } else {
                                    index = restore;
                                    flags += 'u';
                                    str += '\\u';
                                }
                                throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                            } else {
                                str += '\\';
                                throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                            }
                        } else {
                            flags += ch;
                            str += ch;
                        }
                    }
                    return {
                        value: flags,
                        literal: str
                    };
                }
                function scanRegExp() {
                    var start, body, flags, pattern, value;
                    lookahead = null;
                    skipComment();
                    start = index;
                    body = scanRegExpBody();
                    flags = scanRegExpFlags();
                    value = testRegExp(body.value, flags.value);
                    if (extra.tokenize) {
                        return {
                            type: Token.RegularExpression,
                            value: value,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: start,
                            end: index
                        };
                    }
                    return {
                        literal: body.literal + flags.literal,
                        value: value,
                        start: start,
                        end: index
                    };
                }
                function collectRegex() {
                    var pos, loc, regex, token;
                    skipComment();
                    pos = index;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    regex = scanRegExp();
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart
                    };
                    if (!extra.tokenize) {
                        if (extra.tokens.length > 0) {
                            token = extra.tokens[extra.tokens.length - 1];
                            if (token.range[0] === pos && token.type === 'Punctuator') {
                                if (token.value === '/' || token.value === '/=') {
                                    extra.tokens.pop();
                                }
                            }
                        }
                        extra.tokens.push({
                            type: 'RegularExpression',
                            value: regex.literal,
                            range: [
                                pos,
                                index
                            ],
                            loc: loc
                        });
                    }
                    return regex;
                }
                function isIdentifierName(token) {
                    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
                }
                function advanceSlash() {
                    var prevToken, checkToken;
                    prevToken = extra.tokens[extra.tokens.length - 1];
                    if (!prevToken) {
                        return collectRegex();
                    }
                    if (prevToken.type === 'Punctuator') {
                        if (prevToken.value === ']') {
                            return scanPunctuator();
                        }
                        if (prevToken.value === ')') {
                            checkToken = extra.tokens[extra.openParenToken - 1];
                            if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
                                return collectRegex();
                            }
                            return scanPunctuator();
                        }
                        if (prevToken.value === '}') {
                            if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                                checkToken = extra.tokens[extra.openCurlyToken - 4];
                                if (!checkToken) {
                                    return scanPunctuator();
                                }
                            } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                                checkToken = extra.tokens[extra.openCurlyToken - 5];
                                if (!checkToken) {
                                    return collectRegex();
                                }
                            } else {
                                return scanPunctuator();
                            }
                            if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                                return scanPunctuator();
                            }
                            return collectRegex();
                        }
                        return collectRegex();
                    }
                    if (prevToken.type === 'Keyword') {
                        return collectRegex();
                    }
                    return scanPunctuator();
                }
                function advance() {
                    var ch;
                    skipComment();
                    if (index >= length) {
                        return {
                            type: Token.EOF,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            start: index,
                            end: index
                        };
                    }
                    ch = source.charCodeAt(index);
                    if (isIdentifierStart(ch)) {
                        return scanIdentifier();
                    }
                    if (ch === 40 || ch === 41 || ch === 59) {
                        return scanPunctuator();
                    }
                    if (ch === 39 || ch === 34) {
                        return scanStringLiteral();
                    }
                    if (ch === 46) {
                        if (isDecimalDigit(source.charCodeAt(index + 1))) {
                            return scanNumericLiteral();
                        }
                        return scanPunctuator();
                    }
                    if (isDecimalDigit(ch)) {
                        return scanNumericLiteral();
                    }
                    if (extra.tokenize && ch === 47) {
                        return advanceSlash();
                    }
                    return scanPunctuator();
                }
                function collectToken() {
                    var loc, token, range, value;
                    skipComment();
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    token = advance();
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart
                    };
                    if (token.type !== Token.EOF) {
                        value = source.slice(token.start, token.end);
                        extra.tokens.push({
                            type: TokenName[token.type],
                            value: value,
                            range: [
                                token.start,
                                token.end
                            ],
                            loc: loc
                        });
                    }
                    return token;
                }
                function lex() {
                    var token;
                    token = lookahead;
                    index = token.end;
                    lineNumber = token.lineNumber;
                    lineStart = token.lineStart;
                    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
                    index = token.end;
                    lineNumber = token.lineNumber;
                    lineStart = token.lineStart;
                    return token;
                }
                function peek() {
                    var pos, line, start;
                    pos = index;
                    line = lineNumber;
                    start = lineStart;
                    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
                    index = pos;
                    lineNumber = line;
                    lineStart = start;
                }
                function Position(line, column) {
                    this.line = line;
                    this.column = column;
                }
                function SourceLocation(startLine, startColumn, line, column) {
                    this.start = new Position(startLine, startColumn);
                    this.end = new Position(line, column);
                }
                SyntaxTreeDelegate = {
                    name: 'SyntaxTree',
                    processComment: function (node) {
                        var lastChild, trailingComments;
                        if (node.type === Syntax.Program) {
                            if (node.body.length > 0) {
                                return;
                            }
                        }
                        if (extra.trailingComments.length > 0) {
                            if (extra.trailingComments[0].range[0] >= node.range[1]) {
                                trailingComments = extra.trailingComments;
                                extra.trailingComments = [];
                            } else {
                                extra.trailingComments.length = 0;
                            }
                        } else {
                            if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
                                trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                                delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                            }
                        }
                        while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
                            lastChild = extra.bottomRightStack.pop();
                        }
                        if (lastChild) {
                            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                                node.leadingComments = lastChild.leadingComments;
                                delete lastChild.leadingComments;
                            }
                        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                            node.leadingComments = extra.leadingComments;
                            extra.leadingComments = [];
                        }
                        if (trailingComments) {
                            node.trailingComments = trailingComments;
                        }
                        extra.bottomRightStack.push(node);
                    },
                    markEnd: function (node, startToken) {
                        if (extra.range) {
                            node.range = [
                                startToken.start,
                                index
                            ];
                        }
                        if (extra.loc) {
                            node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);
                            this.postProcess(node);
                        }
                        if (extra.attachComment) {
                            this.processComment(node);
                        }
                        return node;
                    },
                    postProcess: function (node) {
                        if (extra.source) {
                            node.loc.source = extra.source;
                        }
                        return node;
                    },
                    createArrayExpression: function (elements) {
                        return {
                            type: Syntax.ArrayExpression,
                            elements: elements
                        };
                    },
                    createAssignmentExpression: function (operator, left, right) {
                        return {
                            type: Syntax.AssignmentExpression,
                            operator: operator,
                            left: left,
                            right: right
                        };
                    },
                    createBinaryExpression: function (operator, left, right) {
                        var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;
                        return {
                            type: type,
                            operator: operator,
                            left: left,
                            right: right
                        };
                    },
                    createBlockStatement: function (body) {
                        return {
                            type: Syntax.BlockStatement,
                            body: body
                        };
                    },
                    createBreakStatement: function (label) {
                        return {
                            type: Syntax.BreakStatement,
                            label: label
                        };
                    },
                    createCallExpression: function (callee, args) {
                        return {
                            type: Syntax.CallExpression,
                            callee: callee,
                            'arguments': args
                        };
                    },
                    createCatchClause: function (param, body) {
                        return {
                            type: Syntax.CatchClause,
                            param: param,
                            body: body
                        };
                    },
                    createConditionalExpression: function (test, consequent, alternate) {
                        return {
                            type: Syntax.ConditionalExpression,
                            test: test,
                            consequent: consequent,
                            alternate: alternate
                        };
                    },
                    createContinueStatement: function (label) {
                        return {
                            type: Syntax.ContinueStatement,
                            label: label
                        };
                    },
                    createDebuggerStatement: function () {
                        return { type: Syntax.DebuggerStatement };
                    },
                    createDoWhileStatement: function (body, test) {
                        return {
                            type: Syntax.DoWhileStatement,
                            body: body,
                            test: test
                        };
                    },
                    createEmptyStatement: function () {
                        return { type: Syntax.EmptyStatement };
                    },
                    createExpressionStatement: function (expression) {
                        return {
                            type: Syntax.ExpressionStatement,
                            expression: expression
                        };
                    },
                    createForStatement: function (init, test, update, body) {
                        return {
                            type: Syntax.ForStatement,
                            init: init,
                            test: test,
                            update: update,
                            body: body
                        };
                    },
                    createForInStatement: function (left, right, body) {
                        return {
                            type: Syntax.ForInStatement,
                            left: left,
                            right: right,
                            body: body,
                            each: false
                        };
                    },
                    createFunctionDeclaration: function (id, params, defaults, body) {
                        return {
                            type: Syntax.FunctionDeclaration,
                            id: id,
                            params: params,
                            defaults: defaults,
                            body: body,
                            rest: null,
                            generator: false,
                            expression: false
                        };
                    },
                    createFunctionExpression: function (id, params, defaults, body) {
                        return {
                            type: Syntax.FunctionExpression,
                            id: id,
                            params: params,
                            defaults: defaults,
                            body: body,
                            rest: null,
                            generator: false,
                            expression: false
                        };
                    },
                    createIdentifier: function (name) {
                        return {
                            type: Syntax.Identifier,
                            name: name
                        };
                    },
                    createIfStatement: function (test, consequent, alternate) {
                        return {
                            type: Syntax.IfStatement,
                            test: test,
                            consequent: consequent,
                            alternate: alternate
                        };
                    },
                    createLabeledStatement: function (label, body) {
                        return {
                            type: Syntax.LabeledStatement,
                            label: label,
                            body: body
                        };
                    },
                    createLiteral: function (token) {
                        return {
                            type: Syntax.Literal,
                            value: token.value,
                            raw: source.slice(token.start, token.end)
                        };
                    },
                    createMemberExpression: function (accessor, object, property) {
                        return {
                            type: Syntax.MemberExpression,
                            computed: accessor === '[',
                            object: object,
                            property: property
                        };
                    },
                    createNewExpression: function (callee, args) {
                        return {
                            type: Syntax.NewExpression,
                            callee: callee,
                            'arguments': args
                        };
                    },
                    createObjectExpression: function (properties) {
                        return {
                            type: Syntax.ObjectExpression,
                            properties: properties
                        };
                    },
                    createPostfixExpression: function (operator, argument) {
                        return {
                            type: Syntax.UpdateExpression,
                            operator: operator,
                            argument: argument,
                            prefix: false
                        };
                    },
                    createProgram: function (body) {
                        return {
                            type: Syntax.Program,
                            body: body
                        };
                    },
                    createProperty: function (kind, key, value) {
                        return {
                            type: Syntax.Property,
                            key: key,
                            value: value,
                            kind: kind
                        };
                    },
                    createReturnStatement: function (argument) {
                        return {
                            type: Syntax.ReturnStatement,
                            argument: argument
                        };
                    },
                    createSequenceExpression: function (expressions) {
                        return {
                            type: Syntax.SequenceExpression,
                            expressions: expressions
                        };
                    },
                    createSwitchCase: function (test, consequent) {
                        return {
                            type: Syntax.SwitchCase,
                            test: test,
                            consequent: consequent
                        };
                    },
                    createSwitchStatement: function (discriminant, cases) {
                        return {
                            type: Syntax.SwitchStatement,
                            discriminant: discriminant,
                            cases: cases
                        };
                    },
                    createThisExpression: function () {
                        return { type: Syntax.ThisExpression };
                    },
                    createThrowStatement: function (argument) {
                        return {
                            type: Syntax.ThrowStatement,
                            argument: argument
                        };
                    },
                    createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
                        return {
                            type: Syntax.TryStatement,
                            block: block,
                            guardedHandlers: guardedHandlers,
                            handlers: handlers,
                            finalizer: finalizer
                        };
                    },
                    createUnaryExpression: function (operator, argument) {
                        if (operator === '++' || operator === '--') {
                            return {
                                type: Syntax.UpdateExpression,
                                operator: operator,
                                argument: argument,
                                prefix: true
                            };
                        }
                        return {
                            type: Syntax.UnaryExpression,
                            operator: operator,
                            argument: argument,
                            prefix: true
                        };
                    },
                    createVariableDeclaration: function (declarations, kind) {
                        return {
                            type: Syntax.VariableDeclaration,
                            declarations: declarations,
                            kind: kind
                        };
                    },
                    createVariableDeclarator: function (id, init) {
                        return {
                            type: Syntax.VariableDeclarator,
                            id: id,
                            init: init
                        };
                    },
                    createWhileStatement: function (test, body) {
                        return {
                            type: Syntax.WhileStatement,
                            test: test,
                            body: body
                        };
                    },
                    createWithStatement: function (object, body) {
                        return {
                            type: Syntax.WithStatement,
                            object: object,
                            body: body
                        };
                    }
                };
                function peekLineTerminator() {
                    var pos, line, start, found;
                    pos = index;
                    line = lineNumber;
                    start = lineStart;
                    skipComment();
                    found = lineNumber !== line;
                    index = pos;
                    lineNumber = line;
                    lineStart = start;
                    return found;
                }
                function throwError(token, messageFormat) {
                    var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function (whole, index) {
                            assert(index < args.length, 'Message reference must be in range');
                            return args[index];
                        });
                    if (typeof token.lineNumber === 'number') {
                        error = new Error('Line ' + token.lineNumber + ': ' + msg);
                        error.index = token.start;
                        error.lineNumber = token.lineNumber;
                        error.column = token.start - lineStart + 1;
                    } else {
                        error = new Error('Line ' + lineNumber + ': ' + msg);
                        error.index = index;
                        error.lineNumber = lineNumber;
                        error.column = index - lineStart + 1;
                    }
                    error.description = msg;
                    throw error;
                }
                function throwErrorTolerant() {
                    try {
                        throwError.apply(null, arguments);
                    } catch (e) {
                        if (extra.errors) {
                            extra.errors.push(e);
                        } else {
                            throw e;
                        }
                    }
                }
                function throwUnexpected(token) {
                    if (token.type === Token.EOF) {
                        throwError(token, Messages.UnexpectedEOS);
                    }
                    if (token.type === Token.NumericLiteral) {
                        throwError(token, Messages.UnexpectedNumber);
                    }
                    if (token.type === Token.StringLiteral) {
                        throwError(token, Messages.UnexpectedString);
                    }
                    if (token.type === Token.Identifier) {
                        throwError(token, Messages.UnexpectedIdentifier);
                    }
                    if (token.type === Token.Keyword) {
                        if (isFutureReservedWord(token.value)) {
                            throwError(token, Messages.UnexpectedReserved);
                        } else if (strict && isStrictModeReservedWord(token.value)) {
                            throwErrorTolerant(token, Messages.StrictReservedWord);
                            return;
                        }
                        throwError(token, Messages.UnexpectedToken, token.value);
                    }
                    throwError(token, Messages.UnexpectedToken, token.value);
                }
                function expect(value) {
                    var token = lex();
                    if (token.type !== Token.Punctuator || token.value !== value) {
                        throwUnexpected(token);
                    }
                }
                function expectKeyword(keyword) {
                    var token = lex();
                    if (token.type !== Token.Keyword || token.value !== keyword) {
                        throwUnexpected(token);
                    }
                }
                function match(value) {
                    return lookahead.type === Token.Punctuator && lookahead.value === value;
                }
                function matchKeyword(keyword) {
                    return lookahead.type === Token.Keyword && lookahead.value === keyword;
                }
                function matchAssign() {
                    var op;
                    if (lookahead.type !== Token.Punctuator) {
                        return false;
                    }
                    op = lookahead.value;
                    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
                }
                function consumeSemicolon() {
                    var line;
                    if (source.charCodeAt(index) === 59 || match(';')) {
                        lex();
                        return;
                    }
                    line = lineNumber;
                    skipComment();
                    if (lineNumber !== line) {
                        return;
                    }
                    if (lookahead.type !== Token.EOF && !match('}')) {
                        throwUnexpected(lookahead);
                    }
                }
                function isLeftHandSide(expr) {
                    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
                }
                function parseArrayInitialiser() {
                    var elements = [], startToken;
                    startToken = lookahead;
                    expect('[');
                    while (!match(']')) {
                        if (match(',')) {
                            lex();
                            elements.push(null);
                        } else {
                            elements.push(parseAssignmentExpression());
                            if (!match(']')) {
                                expect(',');
                            }
                        }
                    }
                    lex();
                    return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
                }
                function parsePropertyFunction(param, first) {
                    var previousStrict, body, startToken;
                    previousStrict = strict;
                    startToken = lookahead;
                    body = parseFunctionSourceElements();
                    if (first && strict && isRestrictedWord(param[0].name)) {
                        throwErrorTolerant(first, Messages.StrictParamName);
                    }
                    strict = previousStrict;
                    return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
                }
                function parseObjectPropertyKey() {
                    var token, startToken;
                    startToken = lookahead;
                    token = lex();
                    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
                        if (strict && token.octal) {
                            throwErrorTolerant(token, Messages.StrictOctalLiteral);
                        }
                        return delegate.markEnd(delegate.createLiteral(token), startToken);
                    }
                    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
                }
                function parseObjectProperty() {
                    var token, key, id, value, param, startToken;
                    token = lookahead;
                    startToken = lookahead;
                    if (token.type === Token.Identifier) {
                        id = parseObjectPropertyKey();
                        if (token.value === 'get' && !match(':')) {
                            key = parseObjectPropertyKey();
                            expect('(');
                            expect(')');
                            value = parsePropertyFunction([]);
                            return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
                        }
                        if (token.value === 'set' && !match(':')) {
                            key = parseObjectPropertyKey();
                            expect('(');
                            token = lookahead;
                            if (token.type !== Token.Identifier) {
                                expect(')');
                                throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                                value = parsePropertyFunction([]);
                            } else {
                                param = [parseVariableIdentifier()];
                                expect(')');
                                value = parsePropertyFunction(param, token);
                            }
                            return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
                        }
                        expect(':');
                        value = parseAssignmentExpression();
                        return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
                    }
                    if (token.type === Token.EOF || token.type === Token.Punctuator) {
                        throwUnexpected(token);
                    } else {
                        key = parseObjectPropertyKey();
                        expect(':');
                        value = parseAssignmentExpression();
                        return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
                    }
                }
                function parseObjectInitialiser() {
                    var properties = [], property, name, key, kind, map = {}, toString = String, startToken;
                    startToken = lookahead;
                    expect('{');
                    while (!match('}')) {
                        property = parseObjectProperty();
                        if (property.key.type === Syntax.Identifier) {
                            name = property.key.name;
                        } else {
                            name = toString(property.key.value);
                        }
                        kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;
                        key = '$' + name;
                        if (Object.prototype.hasOwnProperty.call(map, key)) {
                            if (map[key] === PropertyKind.Data) {
                                if (strict && kind === PropertyKind.Data) {
                                    throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                                } else if (kind !== PropertyKind.Data) {
                                    throwErrorTolerant({}, Messages.AccessorDataProperty);
                                }
                            } else {
                                if (kind === PropertyKind.Data) {
                                    throwErrorTolerant({}, Messages.AccessorDataProperty);
                                } else if (map[key] & kind) {
                                    throwErrorTolerant({}, Messages.AccessorGetSet);
                                }
                            }
                            map[key] |= kind;
                        } else {
                            map[key] = kind;
                        }
                        properties.push(property);
                        if (!match('}')) {
                            expect(',');
                        }
                    }
                    expect('}');
                    return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
                }
                function parseGroupExpression() {
                    var expr;
                    expect('(');
                    expr = parseExpression();
                    expect(')');
                    return expr;
                }
                function parsePrimaryExpression() {
                    var type, token, expr, startToken;
                    if (match('(')) {
                        return parseGroupExpression();
                    }
                    if (match('[')) {
                        return parseArrayInitialiser();
                    }
                    if (match('{')) {
                        return parseObjectInitialiser();
                    }
                    type = lookahead.type;
                    startToken = lookahead;
                    if (type === Token.Identifier) {
                        expr = delegate.createIdentifier(lex().value);
                    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                        if (strict && lookahead.octal) {
                            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
                        }
                        expr = delegate.createLiteral(lex());
                    } else if (type === Token.Keyword) {
                        if (matchKeyword('function')) {
                            return parseFunctionExpression();
                        }
                        if (matchKeyword('this')) {
                            lex();
                            expr = delegate.createThisExpression();
                        } else {
                            throwUnexpected(lex());
                        }
                    } else if (type === Token.BooleanLiteral) {
                        token = lex();
                        token.value = token.value === 'true';
                        expr = delegate.createLiteral(token);
                    } else if (type === Token.NullLiteral) {
                        token = lex();
                        token.value = null;
                        expr = delegate.createLiteral(token);
                    } else if (match('/') || match('/=')) {
                        if (typeof extra.tokens !== 'undefined') {
                            expr = delegate.createLiteral(collectRegex());
                        } else {
                            expr = delegate.createLiteral(scanRegExp());
                        }
                        peek();
                    } else {
                        throwUnexpected(lex());
                    }
                    return delegate.markEnd(expr, startToken);
                }
                function parseArguments() {
                    var args = [];
                    expect('(');
                    if (!match(')')) {
                        while (index < length) {
                            args.push(parseAssignmentExpression());
                            if (match(')')) {
                                break;
                            }
                            expect(',');
                        }
                    }
                    expect(')');
                    return args;
                }
                function parseNonComputedProperty() {
                    var token, startToken;
                    startToken = lookahead;
                    token = lex();
                    if (!isIdentifierName(token)) {
                        throwUnexpected(token);
                    }
                    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
                }
                function parseNonComputedMember() {
                    expect('.');
                    return parseNonComputedProperty();
                }
                function parseComputedMember() {
                    var expr;
                    expect('[');
                    expr = parseExpression();
                    expect(']');
                    return expr;
                }
                function parseNewExpression() {
                    var callee, args, startToken;
                    startToken = lookahead;
                    expectKeyword('new');
                    callee = parseLeftHandSideExpression();
                    args = match('(') ? parseArguments() : [];
                    return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
                }
                function parseLeftHandSideExpressionAllowCall() {
                    var previousAllowIn, expr, args, property, startToken;
                    startToken = lookahead;
                    previousAllowIn = state.allowIn;
                    state.allowIn = true;
                    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
                    state.allowIn = previousAllowIn;
                    for (;;) {
                        if (match('.')) {
                            property = parseNonComputedMember();
                            expr = delegate.createMemberExpression('.', expr, property);
                        } else if (match('(')) {
                            args = parseArguments();
                            expr = delegate.createCallExpression(expr, args);
                        } else if (match('[')) {
                            property = parseComputedMember();
                            expr = delegate.createMemberExpression('[', expr, property);
                        } else {
                            break;
                        }
                        delegate.markEnd(expr, startToken);
                    }
                    return expr;
                }
                function parseLeftHandSideExpression() {
                    var previousAllowIn, expr, property, startToken;
                    startToken = lookahead;
                    previousAllowIn = state.allowIn;
                    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
                    state.allowIn = previousAllowIn;
                    while (match('.') || match('[')) {
                        if (match('[')) {
                            property = parseComputedMember();
                            expr = delegate.createMemberExpression('[', expr, property);
                        } else {
                            property = parseNonComputedMember();
                            expr = delegate.createMemberExpression('.', expr, property);
                        }
                        delegate.markEnd(expr, startToken);
                    }
                    return expr;
                }
                function parsePostfixExpression() {
                    var expr, token, startToken = lookahead;
                    expr = parseLeftHandSideExpressionAllowCall();
                    if (lookahead.type === Token.Punctuator) {
                        if ((match('++') || match('--')) && !peekLineTerminator()) {
                            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                                throwErrorTolerant({}, Messages.StrictLHSPostfix);
                            }
                            if (!isLeftHandSide(expr)) {
                                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                            }
                            token = lex();
                            expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
                        }
                    }
                    return expr;
                }
                function parseUnaryExpression() {
                    var token, expr, startToken;
                    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
                        expr = parsePostfixExpression();
                    } else if (match('++') || match('--')) {
                        startToken = lookahead;
                        token = lex();
                        expr = parseUnaryExpression();
                        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                            throwErrorTolerant({}, Messages.StrictLHSPrefix);
                        }
                        if (!isLeftHandSide(expr)) {
                            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                        }
                        expr = delegate.createUnaryExpression(token.value, expr);
                        expr = delegate.markEnd(expr, startToken);
                    } else if (match('+') || match('-') || match('~') || match('!')) {
                        startToken = lookahead;
                        token = lex();
                        expr = parseUnaryExpression();
                        expr = delegate.createUnaryExpression(token.value, expr);
                        expr = delegate.markEnd(expr, startToken);
                    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
                        startToken = lookahead;
                        token = lex();
                        expr = parseUnaryExpression();
                        expr = delegate.createUnaryExpression(token.value, expr);
                        expr = delegate.markEnd(expr, startToken);
                        if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                            throwErrorTolerant({}, Messages.StrictDelete);
                        }
                    } else {
                        expr = parsePostfixExpression();
                    }
                    return expr;
                }
                function binaryPrecedence(token, allowIn) {
                    var prec = 0;
                    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                        return 0;
                    }
                    switch (token.value) {
                    case '||':
                        prec = 1;
                        break;
                    case '&&':
                        prec = 2;
                        break;
                    case '|':
                        prec = 3;
                        break;
                    case '^':
                        prec = 4;
                        break;
                    case '&':
                        prec = 5;
                        break;
                    case '==':
                    case '!=':
                    case '===':
                    case '!==':
                        prec = 6;
                        break;
                    case '<':
                    case '>':
                    case '<=':
                    case '>=':
                    case 'instanceof':
                        prec = 7;
                        break;
                    case 'in':
                        prec = allowIn ? 7 : 0;
                        break;
                    case '<<':
                    case '>>':
                    case '>>>':
                        prec = 8;
                        break;
                    case '+':
                    case '-':
                        prec = 9;
                        break;
                    case '*':
                    case '/':
                    case '%':
                        prec = 11;
                        break;
                    default:
                        break;
                    }
                    return prec;
                }
                function parseBinaryExpression() {
                    var marker, markers, expr, token, prec, stack, right, operator, left, i;
                    marker = lookahead;
                    left = parseUnaryExpression();
                    token = lookahead;
                    prec = binaryPrecedence(token, state.allowIn);
                    if (prec === 0) {
                        return left;
                    }
                    token.prec = prec;
                    lex();
                    markers = [
                        marker,
                        lookahead
                    ];
                    right = parseUnaryExpression();
                    stack = [
                        left,
                        token,
                        right
                    ];
                    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
                        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                            right = stack.pop();
                            operator = stack.pop().value;
                            left = stack.pop();
                            expr = delegate.createBinaryExpression(operator, left, right);
                            markers.pop();
                            marker = markers[markers.length - 1];
                            delegate.markEnd(expr, marker);
                            stack.push(expr);
                        }
                        token = lex();
                        token.prec = prec;
                        stack.push(token);
                        markers.push(lookahead);
                        expr = parseUnaryExpression();
                        stack.push(expr);
                    }
                    i = stack.length - 1;
                    expr = stack[i];
                    markers.pop();
                    while (i > 1) {
                        expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
                        i -= 2;
                        marker = markers.pop();
                        delegate.markEnd(expr, marker);
                    }
                    return expr;
                }
                function parseConditionalExpression() {
                    var expr, previousAllowIn, consequent, alternate, startToken;
                    startToken = lookahead;
                    expr = parseBinaryExpression();
                    if (match('?')) {
                        lex();
                        previousAllowIn = state.allowIn;
                        state.allowIn = true;
                        consequent = parseAssignmentExpression();
                        state.allowIn = previousAllowIn;
                        expect(':');
                        alternate = parseAssignmentExpression();
                        expr = delegate.createConditionalExpression(expr, consequent, alternate);
                        delegate.markEnd(expr, startToken);
                    }
                    return expr;
                }
                function parseAssignmentExpression() {
                    var token, left, right, node, startToken;
                    token = lookahead;
                    startToken = lookahead;
                    node = left = parseConditionalExpression();
                    if (matchAssign()) {
                        if (!isLeftHandSide(left)) {
                            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                        }
                        if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                            throwErrorTolerant(token, Messages.StrictLHSAssignment);
                        }
                        token = lex();
                        right = parseAssignmentExpression();
                        node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
                    }
                    return node;
                }
                function parseExpression() {
                    var expr, startToken = lookahead;
                    expr = parseAssignmentExpression();
                    if (match(',')) {
                        expr = delegate.createSequenceExpression([expr]);
                        while (index < length) {
                            if (!match(',')) {
                                break;
                            }
                            lex();
                            expr.expressions.push(parseAssignmentExpression());
                        }
                        delegate.markEnd(expr, startToken);
                    }
                    return expr;
                }
                function parseStatementList() {
                    var list = [], statement;
                    while (index < length) {
                        if (match('}')) {
                            break;
                        }
                        statement = parseSourceElement();
                        if (typeof statement === 'undefined') {
                            break;
                        }
                        list.push(statement);
                    }
                    return list;
                }
                function parseBlock() {
                    var block, startToken;
                    startToken = lookahead;
                    expect('{');
                    block = parseStatementList();
                    expect('}');
                    return delegate.markEnd(delegate.createBlockStatement(block), startToken);
                }
                function parseVariableIdentifier() {
                    var token, startToken;
                    startToken = lookahead;
                    token = lex();
                    if (token.type !== Token.Identifier) {
                        throwUnexpected(token);
                    }
                    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
                }
                function parseVariableDeclaration(kind) {
                    var init = null, id, startToken;
                    startToken = lookahead;
                    id = parseVariableIdentifier();
                    if (strict && isRestrictedWord(id.name)) {
                        throwErrorTolerant({}, Messages.StrictVarName);
                    }
                    if (kind === 'const') {
                        expect('=');
                        init = parseAssignmentExpression();
                    } else if (match('=')) {
                        lex();
                        init = parseAssignmentExpression();
                    }
                    return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
                }
                function parseVariableDeclarationList(kind) {
                    var list = [];
                    do {
                        list.push(parseVariableDeclaration(kind));
                        if (!match(',')) {
                            break;
                        }
                        lex();
                    } while (index < length);
                    return list;
                }
                function parseVariableStatement() {
                    var declarations;
                    expectKeyword('var');
                    declarations = parseVariableDeclarationList();
                    consumeSemicolon();
                    return delegate.createVariableDeclaration(declarations, 'var');
                }
                function parseConstLetDeclaration(kind) {
                    var declarations, startToken;
                    startToken = lookahead;
                    expectKeyword(kind);
                    declarations = parseVariableDeclarationList(kind);
                    consumeSemicolon();
                    return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
                }
                function parseEmptyStatement() {
                    expect(';');
                    return delegate.createEmptyStatement();
                }
                function parseExpressionStatement() {
                    var expr = parseExpression();
                    consumeSemicolon();
                    return delegate.createExpressionStatement(expr);
                }
                function parseIfStatement() {
                    var test, consequent, alternate;
                    expectKeyword('if');
                    expect('(');
                    test = parseExpression();
                    expect(')');
                    consequent = parseStatement();
                    if (matchKeyword('else')) {
                        lex();
                        alternate = parseStatement();
                    } else {
                        alternate = null;
                    }
                    return delegate.createIfStatement(test, consequent, alternate);
                }
                function parseDoWhileStatement() {
                    var body, test, oldInIteration;
                    expectKeyword('do');
                    oldInIteration = state.inIteration;
                    state.inIteration = true;
                    body = parseStatement();
                    state.inIteration = oldInIteration;
                    expectKeyword('while');
                    expect('(');
                    test = parseExpression();
                    expect(')');
                    if (match(';')) {
                        lex();
                    }
                    return delegate.createDoWhileStatement(body, test);
                }
                function parseWhileStatement() {
                    var test, body, oldInIteration;
                    expectKeyword('while');
                    expect('(');
                    test = parseExpression();
                    expect(')');
                    oldInIteration = state.inIteration;
                    state.inIteration = true;
                    body = parseStatement();
                    state.inIteration = oldInIteration;
                    return delegate.createWhileStatement(test, body);
                }
                function parseForVariableDeclaration() {
                    var token, declarations, startToken;
                    startToken = lookahead;
                    token = lex();
                    declarations = parseVariableDeclarationList();
                    return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
                }
                function parseForStatement() {
                    var init, test, update, left, right, body, oldInIteration;
                    init = test = update = null;
                    expectKeyword('for');
                    expect('(');
                    if (match(';')) {
                        lex();
                    } else {
                        if (matchKeyword('var') || matchKeyword('let')) {
                            state.allowIn = false;
                            init = parseForVariableDeclaration();
                            state.allowIn = true;
                            if (init.declarations.length === 1 && matchKeyword('in')) {
                                lex();
                                left = init;
                                right = parseExpression();
                                init = null;
                            }
                        } else {
                            state.allowIn = false;
                            init = parseExpression();
                            state.allowIn = true;
                            if (matchKeyword('in')) {
                                if (!isLeftHandSide(init)) {
                                    throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                                }
                                lex();
                                left = init;
                                right = parseExpression();
                                init = null;
                            }
                        }
                        if (typeof left === 'undefined') {
                            expect(';');
                        }
                    }
                    if (typeof left === 'undefined') {
                        if (!match(';')) {
                            test = parseExpression();
                        }
                        expect(';');
                        if (!match(')')) {
                            update = parseExpression();
                        }
                    }
                    expect(')');
                    oldInIteration = state.inIteration;
                    state.inIteration = true;
                    body = parseStatement();
                    state.inIteration = oldInIteration;
                    return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
                }
                function parseContinueStatement() {
                    var label = null, key;
                    expectKeyword('continue');
                    if (source.charCodeAt(index) === 59) {
                        lex();
                        if (!state.inIteration) {
                            throwError({}, Messages.IllegalContinue);
                        }
                        return delegate.createContinueStatement(null);
                    }
                    if (peekLineTerminator()) {
                        if (!state.inIteration) {
                            throwError({}, Messages.IllegalContinue);
                        }
                        return delegate.createContinueStatement(null);
                    }
                    if (lookahead.type === Token.Identifier) {
                        label = parseVariableIdentifier();
                        key = '$' + label.name;
                        if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                            throwError({}, Messages.UnknownLabel, label.name);
                        }
                    }
                    consumeSemicolon();
                    if (label === null && !state.inIteration) {
                        throwError({}, Messages.IllegalContinue);
                    }
                    return delegate.createContinueStatement(label);
                }
                function parseBreakStatement() {
                    var label = null, key;
                    expectKeyword('break');
                    if (source.charCodeAt(index) === 59) {
                        lex();
                        if (!(state.inIteration || state.inSwitch)) {
                            throwError({}, Messages.IllegalBreak);
                        }
                        return delegate.createBreakStatement(null);
                    }
                    if (peekLineTerminator()) {
                        if (!(state.inIteration || state.inSwitch)) {
                            throwError({}, Messages.IllegalBreak);
                        }
                        return delegate.createBreakStatement(null);
                    }
                    if (lookahead.type === Token.Identifier) {
                        label = parseVariableIdentifier();
                        key = '$' + label.name;
                        if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                            throwError({}, Messages.UnknownLabel, label.name);
                        }
                    }
                    consumeSemicolon();
                    if (label === null && !(state.inIteration || state.inSwitch)) {
                        throwError({}, Messages.IllegalBreak);
                    }
                    return delegate.createBreakStatement(label);
                }
                function parseReturnStatement() {
                    var argument = null;
                    expectKeyword('return');
                    if (!state.inFunctionBody) {
                        throwErrorTolerant({}, Messages.IllegalReturn);
                    }
                    if (source.charCodeAt(index) === 32) {
                        if (isIdentifierStart(source.charCodeAt(index + 1))) {
                            argument = parseExpression();
                            consumeSemicolon();
                            return delegate.createReturnStatement(argument);
                        }
                    }
                    if (peekLineTerminator()) {
                        return delegate.createReturnStatement(null);
                    }
                    if (!match(';')) {
                        if (!match('}') && lookahead.type !== Token.EOF) {
                            argument = parseExpression();
                        }
                    }
                    consumeSemicolon();
                    return delegate.createReturnStatement(argument);
                }
                function parseWithStatement() {
                    var object, body;
                    if (strict) {
                        skipComment();
                        throwErrorTolerant({}, Messages.StrictModeWith);
                    }
                    expectKeyword('with');
                    expect('(');
                    object = parseExpression();
                    expect(')');
                    body = parseStatement();
                    return delegate.createWithStatement(object, body);
                }
                function parseSwitchCase() {
                    var test, consequent = [], statement, startToken;
                    startToken = lookahead;
                    if (matchKeyword('default')) {
                        lex();
                        test = null;
                    } else {
                        expectKeyword('case');
                        test = parseExpression();
                    }
                    expect(':');
                    while (index < length) {
                        if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                            break;
                        }
                        statement = parseStatement();
                        consequent.push(statement);
                    }
                    return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
                }
                function parseSwitchStatement() {
                    var discriminant, cases, clause, oldInSwitch, defaultFound;
                    expectKeyword('switch');
                    expect('(');
                    discriminant = parseExpression();
                    expect(')');
                    expect('{');
                    cases = [];
                    if (match('}')) {
                        lex();
                        return delegate.createSwitchStatement(discriminant, cases);
                    }
                    oldInSwitch = state.inSwitch;
                    state.inSwitch = true;
                    defaultFound = false;
                    while (index < length) {
                        if (match('}')) {
                            break;
                        }
                        clause = parseSwitchCase();
                        if (clause.test === null) {
                            if (defaultFound) {
                                throwError({}, Messages.MultipleDefaultsInSwitch);
                            }
                            defaultFound = true;
                        }
                        cases.push(clause);
                    }
                    state.inSwitch = oldInSwitch;
                    expect('}');
                    return delegate.createSwitchStatement(discriminant, cases);
                }
                function parseThrowStatement() {
                    var argument;
                    expectKeyword('throw');
                    if (peekLineTerminator()) {
                        throwError({}, Messages.NewlineAfterThrow);
                    }
                    argument = parseExpression();
                    consumeSemicolon();
                    return delegate.createThrowStatement(argument);
                }
                function parseCatchClause() {
                    var param, body, startToken;
                    startToken = lookahead;
                    expectKeyword('catch');
                    expect('(');
                    if (match(')')) {
                        throwUnexpected(lookahead);
                    }
                    param = parseVariableIdentifier();
                    if (strict && isRestrictedWord(param.name)) {
                        throwErrorTolerant({}, Messages.StrictCatchVariable);
                    }
                    expect(')');
                    body = parseBlock();
                    return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
                }
                function parseTryStatement() {
                    var block, handlers = [], finalizer = null;
                    expectKeyword('try');
                    block = parseBlock();
                    if (matchKeyword('catch')) {
                        handlers.push(parseCatchClause());
                    }
                    if (matchKeyword('finally')) {
                        lex();
                        finalizer = parseBlock();
                    }
                    if (handlers.length === 0 && !finalizer) {
                        throwError({}, Messages.NoCatchOrFinally);
                    }
                    return delegate.createTryStatement(block, [], handlers, finalizer);
                }
                function parseDebuggerStatement() {
                    expectKeyword('debugger');
                    consumeSemicolon();
                    return delegate.createDebuggerStatement();
                }
                function parseStatement() {
                    var type = lookahead.type, expr, labeledBody, key, startToken;
                    if (type === Token.EOF) {
                        throwUnexpected(lookahead);
                    }
                    if (type === Token.Punctuator && lookahead.value === '{') {
                        return parseBlock();
                    }
                    startToken = lookahead;
                    if (type === Token.Punctuator) {
                        switch (lookahead.value) {
                        case ';':
                            return delegate.markEnd(parseEmptyStatement(), startToken);
                        case '(':
                            return delegate.markEnd(parseExpressionStatement(), startToken);
                        default:
                            break;
                        }
                    }
                    if (type === Token.Keyword) {
                        switch (lookahead.value) {
                        case 'break':
                            return delegate.markEnd(parseBreakStatement(), startToken);
                        case 'continue':
                            return delegate.markEnd(parseContinueStatement(), startToken);
                        case 'debugger':
                            return delegate.markEnd(parseDebuggerStatement(), startToken);
                        case 'do':
                            return delegate.markEnd(parseDoWhileStatement(), startToken);
                        case 'for':
                            return delegate.markEnd(parseForStatement(), startToken);
                        case 'function':
                            return delegate.markEnd(parseFunctionDeclaration(), startToken);
                        case 'if':
                            return delegate.markEnd(parseIfStatement(), startToken);
                        case 'return':
                            return delegate.markEnd(parseReturnStatement(), startToken);
                        case 'switch':
                            return delegate.markEnd(parseSwitchStatement(), startToken);
                        case 'throw':
                            return delegate.markEnd(parseThrowStatement(), startToken);
                        case 'try':
                            return delegate.markEnd(parseTryStatement(), startToken);
                        case 'var':
                            return delegate.markEnd(parseVariableStatement(), startToken);
                        case 'while':
                            return delegate.markEnd(parseWhileStatement(), startToken);
                        case 'with':
                            return delegate.markEnd(parseWithStatement(), startToken);
                        default:
                            break;
                        }
                    }
                    expr = parseExpression();
                    if (expr.type === Syntax.Identifier && match(':')) {
                        lex();
                        key = '$' + expr.name;
                        if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                            throwError({}, Messages.Redeclaration, 'Label', expr.name);
                        }
                        state.labelSet[key] = true;
                        labeledBody = parseStatement();
                        delete state.labelSet[key];
                        return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
                    }
                    consumeSemicolon();
                    return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
                }
                function parseFunctionSourceElements() {
                    var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;
                    startToken = lookahead;
                    expect('{');
                    while (index < length) {
                        if (lookahead.type !== Token.StringLiteral) {
                            break;
                        }
                        token = lookahead;
                        sourceElement = parseSourceElement();
                        sourceElements.push(sourceElement);
                        if (sourceElement.expression.type !== Syntax.Literal) {
                            break;
                        }
                        directive = source.slice(token.start + 1, token.end - 1);
                        if (directive === 'use strict') {
                            strict = true;
                            if (firstRestricted) {
                                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                            }
                        } else {
                            if (!firstRestricted && token.octal) {
                                firstRestricted = token;
                            }
                        }
                    }
                    oldLabelSet = state.labelSet;
                    oldInIteration = state.inIteration;
                    oldInSwitch = state.inSwitch;
                    oldInFunctionBody = state.inFunctionBody;
                    state.labelSet = {};
                    state.inIteration = false;
                    state.inSwitch = false;
                    state.inFunctionBody = true;
                    while (index < length) {
                        if (match('}')) {
                            break;
                        }
                        sourceElement = parseSourceElement();
                        if (typeof sourceElement === 'undefined') {
                            break;
                        }
                        sourceElements.push(sourceElement);
                    }
                    expect('}');
                    state.labelSet = oldLabelSet;
                    state.inIteration = oldInIteration;
                    state.inSwitch = oldInSwitch;
                    state.inFunctionBody = oldInFunctionBody;
                    return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
                }
                function parseParams(firstRestricted) {
                    var param, params = [], token, stricted, paramSet, key, message;
                    expect('(');
                    if (!match(')')) {
                        paramSet = {};
                        while (index < length) {
                            token = lookahead;
                            param = parseVariableIdentifier();
                            key = '$' + token.value;
                            if (strict) {
                                if (isRestrictedWord(token.value)) {
                                    stricted = token;
                                    message = Messages.StrictParamName;
                                }
                                if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                                    stricted = token;
                                    message = Messages.StrictParamDupe;
                                }
                            } else if (!firstRestricted) {
                                if (isRestrictedWord(token.value)) {
                                    firstRestricted = token;
                                    message = Messages.StrictParamName;
                                } else if (isStrictModeReservedWord(token.value)) {
                                    firstRestricted = token;
                                    message = Messages.StrictReservedWord;
                                } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                                    firstRestricted = token;
                                    message = Messages.StrictParamDupe;
                                }
                            }
                            params.push(param);
                            paramSet[key] = true;
                            if (match(')')) {
                                break;
                            }
                            expect(',');
                        }
                    }
                    expect(')');
                    return {
                        params: params,
                        stricted: stricted,
                        firstRestricted: firstRestricted,
                        message: message
                    };
                }
                function parseFunctionDeclaration() {
                    var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;
                    startToken = lookahead;
                    expectKeyword('function');
                    token = lookahead;
                    id = parseVariableIdentifier();
                    if (strict) {
                        if (isRestrictedWord(token.value)) {
                            throwErrorTolerant(token, Messages.StrictFunctionName);
                        }
                    } else {
                        if (isRestrictedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictFunctionName;
                        } else if (isStrictModeReservedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictReservedWord;
                        }
                    }
                    tmp = parseParams(firstRestricted);
                    params = tmp.params;
                    stricted = tmp.stricted;
                    firstRestricted = tmp.firstRestricted;
                    if (tmp.message) {
                        message = tmp.message;
                    }
                    previousStrict = strict;
                    body = parseFunctionSourceElements();
                    if (strict && firstRestricted) {
                        throwError(firstRestricted, message);
                    }
                    if (strict && stricted) {
                        throwErrorTolerant(stricted, message);
                    }
                    strict = previousStrict;
                    return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
                }
                function parseFunctionExpression() {
                    var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;
                    startToken = lookahead;
                    expectKeyword('function');
                    if (!match('(')) {
                        token = lookahead;
                        id = parseVariableIdentifier();
                        if (strict) {
                            if (isRestrictedWord(token.value)) {
                                throwErrorTolerant(token, Messages.StrictFunctionName);
                            }
                        } else {
                            if (isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictFunctionName;
                            } else if (isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictReservedWord;
                            }
                        }
                    }
                    tmp = parseParams(firstRestricted);
                    params = tmp.params;
                    stricted = tmp.stricted;
                    firstRestricted = tmp.firstRestricted;
                    if (tmp.message) {
                        message = tmp.message;
                    }
                    previousStrict = strict;
                    body = parseFunctionSourceElements();
                    if (strict && firstRestricted) {
                        throwError(firstRestricted, message);
                    }
                    if (strict && stricted) {
                        throwErrorTolerant(stricted, message);
                    }
                    strict = previousStrict;
                    return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
                }
                function parseSourceElement() {
                    if (lookahead.type === Token.Keyword) {
                        switch (lookahead.value) {
                        case 'const':
                        case 'let':
                            return parseConstLetDeclaration(lookahead.value);
                        case 'function':
                            return parseFunctionDeclaration();
                        default:
                            return parseStatement();
                        }
                    }
                    if (lookahead.type !== Token.EOF) {
                        return parseStatement();
                    }
                }
                function parseSourceElements() {
                    var sourceElement, sourceElements = [], token, directive, firstRestricted;
                    while (index < length) {
                        token = lookahead;
                        if (token.type !== Token.StringLiteral) {
                            break;
                        }
                        sourceElement = parseSourceElement();
                        sourceElements.push(sourceElement);
                        if (sourceElement.expression.type !== Syntax.Literal) {
                            break;
                        }
                        directive = source.slice(token.start + 1, token.end - 1);
                        if (directive === 'use strict') {
                            strict = true;
                            if (firstRestricted) {
                                throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                            }
                        } else {
                            if (!firstRestricted && token.octal) {
                                firstRestricted = token;
                            }
                        }
                    }
                    while (index < length) {
                        sourceElement = parseSourceElement();
                        if (typeof sourceElement === 'undefined') {
                            break;
                        }
                        sourceElements.push(sourceElement);
                    }
                    return sourceElements;
                }
                function parseProgram() {
                    var body, startToken;
                    skipComment();
                    peek();
                    startToken = lookahead;
                    strict = false;
                    body = parseSourceElements();
                    return delegate.markEnd(delegate.createProgram(body), startToken);
                }
                function filterTokenLocation() {
                    var i, entry, token, tokens = [];
                    for (i = 0; i < extra.tokens.length; ++i) {
                        entry = extra.tokens[i];
                        token = {
                            type: entry.type,
                            value: entry.value
                        };
                        if (extra.range) {
                            token.range = entry.range;
                        }
                        if (extra.loc) {
                            token.loc = entry.loc;
                        }
                        tokens.push(token);
                    }
                    extra.tokens = tokens;
                }
                function tokenize(code, options) {
                    var toString, token, tokens;
                    toString = String;
                    if (typeof code !== 'string' && !(code instanceof String)) {
                        code = toString(code);
                    }
                    delegate = SyntaxTreeDelegate;
                    source = code;
                    index = 0;
                    lineNumber = source.length > 0 ? 1 : 0;
                    lineStart = 0;
                    length = source.length;
                    lookahead = null;
                    state = {
                        allowIn: true,
                        labelSet: {},
                        inFunctionBody: false,
                        inIteration: false,
                        inSwitch: false,
                        lastCommentStart: -1
                    };
                    extra = {};
                    options = options || {};
                    options.tokens = true;
                    extra.tokens = [];
                    extra.tokenize = true;
                    extra.openParenToken = -1;
                    extra.openCurlyToken = -1;
                    extra.range = typeof options.range === 'boolean' && options.range;
                    extra.loc = typeof options.loc === 'boolean' && options.loc;
                    if (typeof options.comment === 'boolean' && options.comment) {
                        extra.comments = [];
                    }
                    if (typeof options.tolerant === 'boolean' && options.tolerant) {
                        extra.errors = [];
                    }
                    try {
                        peek();
                        if (lookahead.type === Token.EOF) {
                            return extra.tokens;
                        }
                        token = lex();
                        while (lookahead.type !== Token.EOF) {
                            try {
                                token = lex();
                            } catch (lexError) {
                                token = lookahead;
                                if (extra.errors) {
                                    extra.errors.push(lexError);
                                    break;
                                } else {
                                    throw lexError;
                                }
                            }
                        }
                        filterTokenLocation();
                        tokens = extra.tokens;
                        if (typeof extra.comments !== 'undefined') {
                            tokens.comments = extra.comments;
                        }
                        if (typeof extra.errors !== 'undefined') {
                            tokens.errors = extra.errors;
                        }
                    } catch (e) {
                        throw e;
                    } finally {
                        extra = {};
                    }
                    return tokens;
                }
                function parse(code, options) {
                    var program, toString;
                    toString = String;
                    if (typeof code !== 'string' && !(code instanceof String)) {
                        code = toString(code);
                    }
                    delegate = SyntaxTreeDelegate;
                    source = code;
                    index = 0;
                    lineNumber = source.length > 0 ? 1 : 0;
                    lineStart = 0;
                    length = source.length;
                    lookahead = null;
                    state = {
                        allowIn: true,
                        labelSet: {},
                        inFunctionBody: false,
                        inIteration: false,
                        inSwitch: false,
                        lastCommentStart: -1
                    };
                    extra = {};
                    if (typeof options !== 'undefined') {
                        extra.range = typeof options.range === 'boolean' && options.range;
                        extra.loc = typeof options.loc === 'boolean' && options.loc;
                        extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
                        if (extra.loc && options.source !== null && options.source !== undefined) {
                            extra.source = toString(options.source);
                        }
                        if (typeof options.tokens === 'boolean' && options.tokens) {
                            extra.tokens = [];
                        }
                        if (typeof options.comment === 'boolean' && options.comment) {
                            extra.comments = [];
                        }
                        if (typeof options.tolerant === 'boolean' && options.tolerant) {
                            extra.errors = [];
                        }
                        if (extra.attachComment) {
                            extra.range = true;
                            extra.comments = [];
                            extra.bottomRightStack = [];
                            extra.trailingComments = [];
                            extra.leadingComments = [];
                        }
                    }
                    try {
                        program = parseProgram();
                        if (typeof extra.comments !== 'undefined') {
                            program.comments = extra.comments;
                        }
                        if (typeof extra.tokens !== 'undefined') {
                            filterTokenLocation();
                            program.tokens = extra.tokens;
                        }
                        if (typeof extra.errors !== 'undefined') {
                            program.errors = extra.errors;
                        }
                    } catch (e) {
                        throw e;
                    } finally {
                        extra = {};
                    }
                    return program;
                }
                exports.version = '1.2.2';
                exports.tokenize = tokenize;
                exports.parse = parse;
                exports.Syntax = function () {
                    var name, types = {};
                    if (typeof Object.create === 'function') {
                        types = Object.create(null);
                    }
                    for (name in Syntax) {
                        if (Syntax.hasOwnProperty(name)) {
                            types[name] = Syntax[name];
                        }
                    }
                    if (typeof Object.freeze === 'function') {
                        Object.freeze(types);
                    }
                    return types;
                }();
            }));
        });
        _define(36, function (module, exports) {
            (function (root, factory) {
                'use strict';
                if (typeof define === 'function' && define.amd) {
                    define(['exports'], factory);
                } else if (typeof exports !== 'undefined') {
                    factory(exports);
                } else {
                    factory(root.estraverse = {});
                }
            }(this, function (exports) {
                'use strict';
                var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;
                function ignoreJSHintError() {
                }
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                function deepCopy(obj) {
                    var ret = {}, key, val;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            val = obj[key];
                            if (typeof val === 'object' && val !== null) {
                                ret[key] = deepCopy(val);
                            } else {
                                ret[key] = val;
                            }
                        }
                    }
                    return ret;
                }
                function shallowCopy(obj) {
                    var ret = {}, key;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            ret[key] = obj[key];
                        }
                    }
                    return ret;
                }
                ignoreJSHintError(shallowCopy);
                function upperBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            len = diff;
                        } else {
                            i = current + 1;
                            len -= diff + 1;
                        }
                    }
                    return i;
                }
                function lowerBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            i = current + 1;
                            len -= diff + 1;
                        } else {
                            len = diff;
                        }
                    }
                    return i;
                }
                ignoreJSHintError(lowerBound);
                objectCreate = Object.create || function () {
                    function F() {
                    }
                    return function (o) {
                        F.prototype = o;
                        return new F();
                    };
                }();
                objectKeys = Object.keys || function (o) {
                    var keys = [], key;
                    for (key in o) {
                        keys.push(key);
                    }
                    return keys;
                };
                function extend(to, from) {
                    objectKeys(from).forEach(function (key) {
                        to[key] = from[key];
                    });
                    return to;
                }
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    ArrayPattern: 'ArrayPattern',
                    ArrowFunctionExpression: 'ArrowFunctionExpression',
                    AwaitExpression: 'AwaitExpression',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ClassBody: 'ClassBody',
                    ClassDeclaration: 'ClassDeclaration',
                    ClassExpression: 'ClassExpression',
                    ComprehensionBlock: 'ComprehensionBlock',
                    ComprehensionExpression: 'ComprehensionExpression',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExportBatchSpecifier: 'ExportBatchSpecifier',
                    ExportDeclaration: 'ExportDeclaration',
                    ExportSpecifier: 'ExportSpecifier',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    ForOfStatement: 'ForOfStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    GeneratorExpression: 'GeneratorExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    ImportDeclaration: 'ImportDeclaration',
                    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
                    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
                    ImportSpecifier: 'ImportSpecifier',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    MethodDefinition: 'MethodDefinition',
                    ModuleSpecifier: 'ModuleSpecifier',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    ObjectPattern: 'ObjectPattern',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SpreadElement: 'SpreadElement',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    TaggedTemplateExpression: 'TaggedTemplateExpression',
                    TemplateElement: 'TemplateElement',
                    TemplateLiteral: 'TemplateLiteral',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement',
                    YieldExpression: 'YieldExpression'
                };
                VisitorKeys = {
                    AssignmentExpression: [
                        'left',
                        'right'
                    ],
                    ArrayExpression: ['elements'],
                    ArrayPattern: ['elements'],
                    ArrowFunctionExpression: [
                        'params',
                        'defaults',
                        'rest',
                        'body'
                    ],
                    AwaitExpression: ['argument'],
                    BlockStatement: ['body'],
                    BinaryExpression: [
                        'left',
                        'right'
                    ],
                    BreakStatement: ['label'],
                    CallExpression: [
                        'callee',
                        'arguments'
                    ],
                    CatchClause: [
                        'param',
                        'body'
                    ],
                    ClassBody: ['body'],
                    ClassDeclaration: [
                        'id',
                        'body',
                        'superClass'
                    ],
                    ClassExpression: [
                        'id',
                        'body',
                        'superClass'
                    ],
                    ComprehensionBlock: [
                        'left',
                        'right'
                    ],
                    ComprehensionExpression: [
                        'blocks',
                        'filter',
                        'body'
                    ],
                    ConditionalExpression: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ContinueStatement: ['label'],
                    DebuggerStatement: [],
                    DirectiveStatement: [],
                    DoWhileStatement: [
                        'body',
                        'test'
                    ],
                    EmptyStatement: [],
                    ExportBatchSpecifier: [],
                    ExportDeclaration: [
                        'declaration',
                        'specifiers',
                        'source'
                    ],
                    ExportSpecifier: [
                        'id',
                        'name'
                    ],
                    ExpressionStatement: ['expression'],
                    ForStatement: [
                        'init',
                        'test',
                        'update',
                        'body'
                    ],
                    ForInStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    ForOfStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    FunctionDeclaration: [
                        'id',
                        'params',
                        'defaults',
                        'rest',
                        'body'
                    ],
                    FunctionExpression: [
                        'id',
                        'params',
                        'defaults',
                        'rest',
                        'body'
                    ],
                    GeneratorExpression: [
                        'blocks',
                        'filter',
                        'body'
                    ],
                    Identifier: [],
                    IfStatement: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ImportDeclaration: [
                        'specifiers',
                        'source'
                    ],
                    ImportDefaultSpecifier: ['id'],
                    ImportNamespaceSpecifier: ['id'],
                    ImportSpecifier: [
                        'id',
                        'name'
                    ],
                    Literal: [],
                    LabeledStatement: [
                        'label',
                        'body'
                    ],
                    LogicalExpression: [
                        'left',
                        'right'
                    ],
                    MemberExpression: [
                        'object',
                        'property'
                    ],
                    MethodDefinition: [
                        'key',
                        'value'
                    ],
                    ModuleSpecifier: [],
                    NewExpression: [
                        'callee',
                        'arguments'
                    ],
                    ObjectExpression: ['properties'],
                    ObjectPattern: ['properties'],
                    Program: ['body'],
                    Property: [
                        'key',
                        'value'
                    ],
                    ReturnStatement: ['argument'],
                    SequenceExpression: ['expressions'],
                    SpreadElement: ['argument'],
                    SwitchStatement: [
                        'discriminant',
                        'cases'
                    ],
                    SwitchCase: [
                        'test',
                        'consequent'
                    ],
                    TaggedTemplateExpression: [
                        'tag',
                        'quasi'
                    ],
                    TemplateElement: [],
                    TemplateLiteral: [
                        'quasis',
                        'expressions'
                    ],
                    ThisExpression: [],
                    ThrowStatement: ['argument'],
                    TryStatement: [
                        'block',
                        'handlers',
                        'handler',
                        'guardedHandlers',
                        'finalizer'
                    ],
                    UnaryExpression: ['argument'],
                    UpdateExpression: ['argument'],
                    VariableDeclaration: ['declarations'],
                    VariableDeclarator: [
                        'id',
                        'init'
                    ],
                    WhileStatement: [
                        'test',
                        'body'
                    ],
                    WithStatement: [
                        'object',
                        'body'
                    ],
                    YieldExpression: ['argument']
                };
                BREAK = {};
                SKIP = {};
                REMOVE = {};
                VisitorOption = {
                    Break: BREAK,
                    Skip: SKIP,
                    Remove: REMOVE
                };
                function Reference(parent, key) {
                    this.parent = parent;
                    this.key = key;
                }
                Reference.prototype.replace = function replace(node) {
                    this.parent[this.key] = node;
                };
                Reference.prototype.remove = function remove() {
                    if (isArray(this.parent)) {
                        this.parent.splice(this.key, 1);
                        return true;
                    } else {
                        this.replace(null);
                        return false;
                    }
                };
                function Element(node, path, wrap, ref) {
                    this.node = node;
                    this.path = path;
                    this.wrap = wrap;
                    this.ref = ref;
                }
                function Controller() {
                }
                Controller.prototype.path = function path() {
                    var i, iz, j, jz, result, element;
                    function addToPath(result, path) {
                        if (isArray(path)) {
                            for (j = 0, jz = path.length; j < jz; ++j) {
                                result.push(path[j]);
                            }
                        } else {
                            result.push(path);
                        }
                    }
                    if (!this.__current.path) {
                        return null;
                    }
                    result = [];
                    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
                        element = this.__leavelist[i];
                        addToPath(result, element.path);
                    }
                    addToPath(result, this.__current.path);
                    return result;
                };
                Controller.prototype.type = function () {
                    var node = this.current();
                    return node.type || this.__current.wrap;
                };
                Controller.prototype.parents = function parents() {
                    var i, iz, result;
                    result = [];
                    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
                        result.push(this.__leavelist[i].node);
                    }
                    return result;
                };
                Controller.prototype.current = function current() {
                    return this.__current.node;
                };
                Controller.prototype.__execute = function __execute(callback, element) {
                    var previous, result;
                    result = undefined;
                    previous = this.__current;
                    this.__current = element;
                    this.__state = null;
                    if (callback) {
                        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
                    }
                    this.__current = previous;
                    return result;
                };
                Controller.prototype.notify = function notify(flag) {
                    this.__state = flag;
                };
                Controller.prototype.skip = function () {
                    this.notify(SKIP);
                };
                Controller.prototype['break'] = function () {
                    this.notify(BREAK);
                };
                Controller.prototype.remove = function () {
                    this.notify(REMOVE);
                };
                Controller.prototype.__initialize = function (root, visitor) {
                    this.visitor = visitor;
                    this.root = root;
                    this.__worklist = [];
                    this.__leavelist = [];
                    this.__current = null;
                    this.__state = null;
                    this.__fallback = visitor.fallback === 'iteration';
                    this.__keys = VisitorKeys;
                    if (visitor.keys) {
                        this.__keys = extend(objectCreate(this.__keys), visitor.keys);
                    }
                };
                function isNode(node) {
                    if (node == null) {
                        return false;
                    }
                    return typeof node === 'object' && typeof node.type === 'string';
                }
                function isProperty(nodeType, key) {
                    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
                }
                Controller.prototype.traverse = function traverse(root, visitor) {
                    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
                    this.__initialize(root, visitor);
                    sentinel = {};
                    worklist = this.__worklist;
                    leavelist = this.__leavelist;
                    worklist.push(new Element(root, null, null, null));
                    leavelist.push(new Element(null, null, null, null));
                    while (worklist.length) {
                        element = worklist.pop();
                        if (element === sentinel) {
                            element = leavelist.pop();
                            ret = this.__execute(visitor.leave, element);
                            if (this.__state === BREAK || ret === BREAK) {
                                return;
                            }
                            continue;
                        }
                        if (element.node) {
                            ret = this.__execute(visitor.enter, element);
                            if (this.__state === BREAK || ret === BREAK) {
                                return;
                            }
                            worklist.push(sentinel);
                            leavelist.push(element);
                            if (this.__state === SKIP || ret === SKIP) {
                                continue;
                            }
                            node = element.node;
                            nodeType = element.wrap || node.type;
                            candidates = this.__keys[nodeType];
                            if (!candidates) {
                                if (this.__fallback) {
                                    candidates = objectKeys(node);
                                } else {
                                    throw new Error('Unknown node type ' + nodeType + '.');
                                }
                            }
                            current = candidates.length;
                            while ((current -= 1) >= 0) {
                                key = candidates[current];
                                candidate = node[key];
                                if (!candidate) {
                                    continue;
                                }
                                if (isArray(candidate)) {
                                    current2 = candidate.length;
                                    while ((current2 -= 1) >= 0) {
                                        if (!candidate[current2]) {
                                            continue;
                                        }
                                        if (isProperty(nodeType, candidates[current])) {
                                            element = new Element(candidate[current2], [
                                                key,
                                                current2
                                            ], 'Property', null);
                                        } else if (isNode(candidate[current2])) {
                                            element = new Element(candidate[current2], [
                                                key,
                                                current2
                                            ], null, null);
                                        } else {
                                            continue;
                                        }
                                        worklist.push(element);
                                    }
                                } else if (isNode(candidate)) {
                                    worklist.push(new Element(candidate, key, null, null));
                                }
                            }
                        }
                    }
                };
                Controller.prototype.replace = function replace(root, visitor) {
                    function removeElem(element) {
                        var i, key, nextElem, parent;
                        if (element.ref.remove()) {
                            key = element.ref.key;
                            parent = element.ref.parent;
                            i = worklist.length;
                            while (i--) {
                                nextElem = worklist[i];
                                if (nextElem.ref && nextElem.ref.parent === parent) {
                                    if (nextElem.ref.key < key) {
                                        break;
                                    }
                                    --nextElem.ref.key;
                                }
                            }
                        }
                    }
                    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
                    this.__initialize(root, visitor);
                    sentinel = {};
                    worklist = this.__worklist;
                    leavelist = this.__leavelist;
                    outer = { root: root };
                    element = new Element(root, null, null, new Reference(outer, 'root'));
                    worklist.push(element);
                    leavelist.push(element);
                    while (worklist.length) {
                        element = worklist.pop();
                        if (element === sentinel) {
                            element = leavelist.pop();
                            target = this.__execute(visitor.leave, element);
                            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                                element.ref.replace(target);
                            }
                            if (this.__state === REMOVE || target === REMOVE) {
                                removeElem(element);
                            }
                            if (this.__state === BREAK || target === BREAK) {
                                return outer.root;
                            }
                            continue;
                        }
                        target = this.__execute(visitor.enter, element);
                        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                            element.ref.replace(target);
                            element.node = target;
                        }
                        if (this.__state === REMOVE || target === REMOVE) {
                            removeElem(element);
                            element.node = null;
                        }
                        if (this.__state === BREAK || target === BREAK) {
                            return outer.root;
                        }
                        node = element.node;
                        if (!node) {
                            continue;
                        }
                        worklist.push(sentinel);
                        leavelist.push(element);
                        if (this.__state === SKIP || target === SKIP) {
                            continue;
                        }
                        nodeType = element.wrap || node.type;
                        candidates = this.__keys[nodeType];
                        if (!candidates) {
                            if (this.__fallback) {
                                candidates = objectKeys(node);
                            } else {
                                throw new Error('Unknown node type ' + nodeType + '.');
                            }
                        }
                        current = candidates.length;
                        while ((current -= 1) >= 0) {
                            key = candidates[current];
                            candidate = node[key];
                            if (!candidate) {
                                continue;
                            }
                            if (isArray(candidate)) {
                                current2 = candidate.length;
                                while ((current2 -= 1) >= 0) {
                                    if (!candidate[current2]) {
                                        continue;
                                    }
                                    if (isProperty(nodeType, candidates[current])) {
                                        element = new Element(candidate[current2], [
                                            key,
                                            current2
                                        ], 'Property', new Reference(candidate, current2));
                                    } else if (isNode(candidate[current2])) {
                                        element = new Element(candidate[current2], [
                                            key,
                                            current2
                                        ], null, new Reference(candidate, current2));
                                    } else {
                                        continue;
                                    }
                                    worklist.push(element);
                                }
                            } else if (isNode(candidate)) {
                                worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                            }
                        }
                    }
                    return outer.root;
                };
                function traverse(root, visitor) {
                    var controller = new Controller();
                    return controller.traverse(root, visitor);
                }
                function replace(root, visitor) {
                    var controller = new Controller();
                    return controller.replace(root, visitor);
                }
                function extendCommentRange(comment, tokens) {
                    var target;
                    target = upperBound(tokens, function search(token) {
                        return token.range[0] > comment.range[0];
                    });
                    comment.extendedRange = [
                        comment.range[0],
                        comment.range[1]
                    ];
                    if (target !== tokens.length) {
                        comment.extendedRange[1] = tokens[target].range[0];
                    }
                    target -= 1;
                    if (target >= 0) {
                        comment.extendedRange[0] = tokens[target].range[1];
                    }
                    return comment;
                }
                function attachComments(tree, providedComments, tokens) {
                    var comments = [], comment, len, i, cursor;
                    if (!tree.range) {
                        throw new Error('attachComments needs range information');
                    }
                    if (!tokens.length) {
                        if (providedComments.length) {
                            for (i = 0, len = providedComments.length; i < len; i += 1) {
                                comment = deepCopy(providedComments[i]);
                                comment.extendedRange = [
                                    0,
                                    tree.range[0]
                                ];
                                comments.push(comment);
                            }
                            tree.leadingComments = comments;
                        }
                        return tree;
                    }
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
                    }
                    cursor = 0;
                    traverse(tree, {
                        enter: function (node) {
                            var comment;
                            while (cursor < comments.length) {
                                comment = comments[cursor];
                                if (comment.extendedRange[1] > node.range[0]) {
                                    break;
                                }
                                if (comment.extendedRange[1] === node.range[0]) {
                                    if (!node.leadingComments) {
                                        node.leadingComments = [];
                                    }
                                    node.leadingComments.push(comment);
                                    comments.splice(cursor, 1);
                                } else {
                                    cursor += 1;
                                }
                            }
                            if (cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    cursor = 0;
                    traverse(tree, {
                        leave: function (node) {
                            var comment;
                            while (cursor < comments.length) {
                                comment = comments[cursor];
                                if (node.range[1] < comment.extendedRange[0]) {
                                    break;
                                }
                                if (node.range[1] === comment.extendedRange[0]) {
                                    if (!node.trailingComments) {
                                        node.trailingComments = [];
                                    }
                                    node.trailingComments.push(comment);
                                    comments.splice(cursor, 1);
                                } else {
                                    cursor += 1;
                                }
                            }
                            if (cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    return tree;
                }
                exports.version = '1.8.1-dev';
                exports.Syntax = Syntax;
                exports.traverse = traverse;
                exports.replace = replace;
                exports.attachComments = attachComments;
                exports.VisitorKeys = VisitorKeys;
                exports.VisitorOption = VisitorOption;
                exports.Controller = Controller;
            }));
        });
        _define(37, function (module, exports) {
            var Buffer = require('buffer').Buffer;
            module.exports = function (buf) {
                var out = new Buffer(buf.length);
                buf.copy(out);
                return out;
            };
        });
        _define(38, function (module, exports) {
            module.exports = Transform;
            var Duplex = require(67);
            var util = require(71);
            util.inherits = require(74);
            util.inherits(Transform, Duplex);
            function TransformState(options, stream) {
                this.afterTransform = function (er, data) {
                    return afterTransform(stream, er, data);
                };
                this.needTransform = false;
                this.transforming = false;
                this.writecb = null;
                this.writechunk = null;
            }
            function afterTransform(stream, er, data) {
                var ts = stream._transformState;
                ts.transforming = false;
                var cb = ts.writecb;
                if (!cb)
                    return stream.emit('error', new Error('no writecb in Transform class'));
                ts.writechunk = null;
                ts.writecb = null;
                if (data !== null && data !== undefined)
                    stream.push(data);
                if (cb)
                    cb(er);
                var rs = stream._readableState;
                rs.reading = false;
                if (rs.needReadable || rs.length < rs.highWaterMark) {
                    stream._read(rs.highWaterMark);
                }
            }
            function Transform(options) {
                if (!(this instanceof Transform))
                    return new Transform(options);
                Duplex.call(this, options);
                var ts = this._transformState = new TransformState(options, this);
                var stream = this;
                this._readableState.needReadable = true;
                this._readableState.sync = false;
                this.once('finish', function () {
                    if ('function' === typeof this._flush)
                        this._flush(function (er) {
                            done(stream, er);
                        });
                    else
                        done(stream);
                });
            }
            Transform.prototype.push = function (chunk, encoding) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call(this, chunk, encoding);
            };
            Transform.prototype._transform = function (chunk, encoding, cb) {
                throw new Error('not implemented');
            };
            Transform.prototype._write = function (chunk, encoding, cb) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                        this._read(rs.highWaterMark);
                }
            };
            Transform.prototype._read = function (n) {
                var ts = this._transformState;
                if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                } else {
                    ts.needTransform = true;
                }
            };
            function done(stream, er) {
                if (er)
                    return stream.emit('error', er);
                var ws = stream._writableState;
                var rs = stream._readableState;
                var ts = stream._transformState;
                if (ws.length)
                    throw new Error('calling transform done when ws.length != 0');
                if (ts.transforming)
                    throw new Error('calling transform done when still transforming');
                return stream.push(null);
            }
        });
        _define(39, function (module, exports) {
            'use strict';
            var old;
            if (typeof Promise !== 'undefined')
                old = Promise;
            function noConflict(bluebird) {
                try {
                    if (Promise === bluebird)
                        Promise = old;
                } catch (e) {
                }
                return bluebird;
            }
            module.exports = function () {
                var util = require(69);
                var async = require(73);
                var errors = require(76);
                var INTERNAL = function () {
                };
                var APPLY = {};
                var NEXT_FILTER = { e: null };
                var cast = require(77)(Promise, INTERNAL);
                var PromiseArray = require(78)(Promise, INTERNAL, cast);
                var CapturedTrace = require(79)();
                var CatchFilter = require(80)(NEXT_FILTER);
                var PromiseResolver = require(81);
                var isArray = util.isArray;
                var errorObj = util.errorObj;
                var tryCatch1 = util.tryCatch1;
                var tryCatch2 = util.tryCatch2;
                var tryCatchApply = util.tryCatchApply;
                var RangeError = errors.RangeError;
                var TypeError = errors.TypeError;
                var CancellationError = errors.CancellationError;
                var TimeoutError = errors.TimeoutError;
                var OperationalError = errors.OperationalError;
                var originatesFromRejection = errors.originatesFromRejection;
                var markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;
                var canAttach = errors.canAttach;
                var thrower = util.thrower;
                var apiRejection = require(119)(Promise);
                var makeSelfResolutionError = function Promise$_makeSelfResolutionError() {
                    return new TypeError('circular promise resolution chain');
                };
                function Promise(resolver) {
                    if (typeof resolver !== 'function') {
                        throw new TypeError('the promise constructor requires a resolver function');
                    }
                    if (this.constructor !== Promise) {
                        throw new TypeError('the promise constructor cannot be invoked directly');
                    }
                    this._bitField = 0;
                    this._fulfillmentHandler0 = void 0;
                    this._rejectionHandler0 = void 0;
                    this._promise0 = void 0;
                    this._receiver0 = void 0;
                    this._settledValue = void 0;
                    this._boundTo = void 0;
                    if (resolver !== INTERNAL)
                        this._resolveFromResolver(resolver);
                }
                function returnFirstElement(elements) {
                    return elements[0];
                }
                Promise.prototype.bind = function Promise$bind(thisArg) {
                    var maybePromise = cast(thisArg, void 0);
                    var ret = new Promise(INTERNAL);
                    if (maybePromise instanceof Promise) {
                        var binder = maybePromise.then(function (thisArg) {
                            ret._setBoundTo(thisArg);
                        });
                        var p = Promise.all([
                            this,
                            binder
                        ]).then(returnFirstElement);
                        ret._follow(p);
                    } else {
                        ret._follow(this);
                        ret._setBoundTo(thisArg);
                    }
                    ret._propagateFrom(this, 2 | 1);
                    return ret;
                };
                Promise.prototype.toString = function Promise$toString() {
                    return '[object Promise]';
                };
                Promise.prototype.caught = Promise.prototype['catch'] = function Promise$catch(fn) {
                    var len = arguments.length;
                    if (len > 1) {
                        var catchInstances = new Array(len - 1), j = 0, i;
                        for (i = 0; i < len - 1; ++i) {
                            var item = arguments[i];
                            if (typeof item === 'function') {
                                catchInstances[j++] = item;
                            } else {
                                var catchFilterTypeError = new TypeError('A catch filter must be an error constructor ' + 'or a filter function');
                                this._attachExtraTrace(catchFilterTypeError);
                                return Promise.reject(catchFilterTypeError);
                            }
                        }
                        catchInstances.length = j;
                        fn = arguments[i];
                        this._resetTrace();
                        var catchFilter = new CatchFilter(catchInstances, fn, this);
                        return this._then(void 0, catchFilter.doFilter, void 0, catchFilter, void 0);
                    }
                    return this._then(void 0, fn, void 0, void 0, void 0);
                };
                function reflect() {
                    return new Promise.PromiseInspection(this);
                }
                Promise.prototype.reflect = function Promise$reflect() {
                    return this._then(reflect, reflect, void 0, this, void 0);
                };
                Promise.prototype.then = function Promise$then(didFulfill, didReject, didProgress) {
                    return this._then(didFulfill, didReject, didProgress, void 0, void 0);
                };
                Promise.prototype.done = function Promise$done(didFulfill, didReject, didProgress) {
                    var promise = this._then(didFulfill, didReject, didProgress, void 0, void 0);
                    promise._setIsFinal();
                };
                Promise.prototype.spread = function Promise$spread(didFulfill, didReject) {
                    return this._then(didFulfill, didReject, void 0, APPLY, void 0);
                };
                Promise.prototype.isCancellable = function Promise$isCancellable() {
                    return !this.isResolved() && this._cancellable();
                };
                Promise.prototype.toJSON = function Promise$toJSON() {
                    var ret = {
                        isFulfilled: false,
                        isRejected: false,
                        fulfillmentValue: void 0,
                        rejectionReason: void 0
                    };
                    if (this.isFulfilled()) {
                        ret.fulfillmentValue = this._settledValue;
                        ret.isFulfilled = true;
                    } else if (this.isRejected()) {
                        ret.rejectionReason = this._settledValue;
                        ret.isRejected = true;
                    }
                    return ret;
                };
                Promise.prototype.all = function Promise$all() {
                    return new PromiseArray(this).promise();
                };
                Promise.is = function Promise$Is(val) {
                    return val instanceof Promise;
                };
                Promise.all = function Promise$All(promises) {
                    return new PromiseArray(promises).promise();
                };
                Promise.prototype.error = function Promise$_error(fn) {
                    return this.caught(originatesFromRejection, fn);
                };
                Promise.prototype._resolveFromSyncValue = function Promise$_resolveFromSyncValue(value) {
                    if (value === errorObj) {
                        this._cleanValues();
                        this._setRejected();
                        var reason = value.e;
                        this._settledValue = reason;
                        this._tryAttachExtraTrace(reason);
                        this._ensurePossibleRejectionHandled();
                    } else {
                        var maybePromise = cast(value, void 0);
                        if (maybePromise instanceof Promise) {
                            this._follow(maybePromise);
                        } else {
                            this._cleanValues();
                            this._setFulfilled();
                            this._settledValue = value;
                        }
                    }
                };
                Promise.method = function Promise$_Method(fn) {
                    if (typeof fn !== 'function') {
                        throw new TypeError('fn must be a function');
                    }
                    return function Promise$_method() {
                        var value;
                        switch (arguments.length) {
                        case 0:
                            value = tryCatch1(fn, this, void 0);
                            break;
                        case 1:
                            value = tryCatch1(fn, this, arguments[0]);
                            break;
                        case 2:
                            value = tryCatch2(fn, this, arguments[0], arguments[1]);
                            break;
                        default:
                            var $_len = arguments.length;
                            var args = new Array($_len);
                            for (var $_i = 0; $_i < $_len; ++$_i) {
                                args[$_i] = arguments[$_i];
                            }
                            value = tryCatchApply(fn, args, this);
                            break;
                        }
                        var ret = new Promise(INTERNAL);
                        ret._setTrace(void 0);
                        ret._resolveFromSyncValue(value);
                        return ret;
                    };
                };
                Promise.attempt = Promise['try'] = function Promise$_Try(fn, args, ctx) {
                    if (typeof fn !== 'function') {
                        return apiRejection('fn must be a function');
                    }
                    var value = isArray(args) ? tryCatchApply(fn, args, ctx) : tryCatch1(fn, ctx, args);
                    var ret = new Promise(INTERNAL);
                    ret._setTrace(void 0);
                    ret._resolveFromSyncValue(value);
                    return ret;
                };
                Promise.defer = Promise.pending = function Promise$Defer() {
                    var promise = new Promise(INTERNAL);
                    promise._setTrace(void 0);
                    return new PromiseResolver(promise);
                };
                Promise.bind = function Promise$Bind(thisArg) {
                    var maybePromise = cast(thisArg, void 0);
                    var ret = new Promise(INTERNAL);
                    ret._setTrace(void 0);
                    if (maybePromise instanceof Promise) {
                        var p = maybePromise.then(function (thisArg) {
                            ret._setBoundTo(thisArg);
                        });
                        ret._follow(p);
                    } else {
                        ret._setBoundTo(thisArg);
                        ret._setFulfilled();
                    }
                    return ret;
                };
                Promise.cast = function Promise$_Cast(obj) {
                    var ret = cast(obj, void 0);
                    if (!(ret instanceof Promise)) {
                        var val = ret;
                        ret = new Promise(INTERNAL);
                        ret._setTrace(void 0);
                        ret._setFulfilled();
                        ret._cleanValues();
                        ret._settledValue = val;
                    }
                    return ret;
                };
                Promise.resolve = Promise.fulfilled = Promise.cast;
                Promise.reject = Promise.rejected = function Promise$Reject(reason) {
                    var ret = new Promise(INTERNAL);
                    ret._setTrace(void 0);
                    markAsOriginatingFromRejection(reason);
                    ret._cleanValues();
                    ret._setRejected();
                    ret._settledValue = reason;
                    if (!canAttach(reason)) {
                        var trace = new Error(reason + '');
                        ret._setCarriedStackTrace(trace);
                    }
                    ret._ensurePossibleRejectionHandled();
                    return ret;
                };
                Promise.onPossiblyUnhandledRejection = function Promise$OnPossiblyUnhandledRejection(fn) {
                    CapturedTrace.possiblyUnhandledRejection = typeof fn === 'function' ? fn : void 0;
                };
                var unhandledRejectionHandled;
                Promise.onUnhandledRejectionHandled = function Promise$onUnhandledRejectionHandled(fn) {
                    unhandledRejectionHandled = typeof fn === 'function' ? fn : void 0;
                };
                var debugging = false || !!(typeof process !== 'undefined' && typeof process.execPath === 'string' && typeof process.env === 'object' && (process.env['BLUEBIRD_DEBUG'] || process.env['NODE_ENV'] === 'development'));
                Promise.longStackTraces = function Promise$LongStackTraces() {
                    if (async.haveItemsQueued() && debugging === false) {
                        throw new Error('cannot enable long stack traces after promises have been created');
                    }
                    debugging = CapturedTrace.isSupported();
                };
                Promise.hasLongStackTraces = function Promise$HasLongStackTraces() {
                    return debugging && CapturedTrace.isSupported();
                };
                Promise.prototype._then = function Promise$_then(didFulfill, didReject, didProgress, receiver, internalData) {
                    var haveInternalData = internalData !== void 0;
                    var ret = haveInternalData ? internalData : new Promise(INTERNAL);
                    if (!haveInternalData) {
                        if (debugging) {
                            var haveSameContext = this._peekContext() === this._traceParent;
                            ret._traceParent = haveSameContext ? this._traceParent : this;
                        }
                        ret._propagateFrom(this, 7);
                    }
                    var callbackIndex = this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
                    if (this.isResolved()) {
                        async.invoke(this._queueSettleAt, this, callbackIndex);
                    }
                    return ret;
                };
                Promise.prototype._length = function Promise$_length() {
                    return this._bitField & 262143;
                };
                Promise.prototype._isFollowingOrFulfilledOrRejected = function Promise$_isFollowingOrFulfilledOrRejected() {
                    return (this._bitField & 939524096) > 0;
                };
                Promise.prototype._isFollowing = function Promise$_isFollowing() {
                    return (this._bitField & 536870912) === 536870912;
                };
                Promise.prototype._setLength = function Promise$_setLength(len) {
                    this._bitField = this._bitField & -262144 | len & 262143;
                };
                Promise.prototype._setFulfilled = function Promise$_setFulfilled() {
                    this._bitField = this._bitField | 268435456;
                };
                Promise.prototype._setRejected = function Promise$_setRejected() {
                    this._bitField = this._bitField | 134217728;
                };
                Promise.prototype._setFollowing = function Promise$_setFollowing() {
                    this._bitField = this._bitField | 536870912;
                };
                Promise.prototype._setIsFinal = function Promise$_setIsFinal() {
                    this._bitField = this._bitField | 33554432;
                };
                Promise.prototype._isFinal = function Promise$_isFinal() {
                    return (this._bitField & 33554432) > 0;
                };
                Promise.prototype._cancellable = function Promise$_cancellable() {
                    return (this._bitField & 67108864) > 0;
                };
                Promise.prototype._setCancellable = function Promise$_setCancellable() {
                    this._bitField = this._bitField | 67108864;
                };
                Promise.prototype._unsetCancellable = function Promise$_unsetCancellable() {
                    this._bitField = this._bitField & ~67108864;
                };
                Promise.prototype._setRejectionIsUnhandled = function Promise$_setRejectionIsUnhandled() {
                    this._bitField = this._bitField | 2097152;
                };
                Promise.prototype._unsetRejectionIsUnhandled = function Promise$_unsetRejectionIsUnhandled() {
                    this._bitField = this._bitField & ~2097152;
                    if (this._isUnhandledRejectionNotified()) {
                        this._unsetUnhandledRejectionIsNotified();
                        this._notifyUnhandledRejectionIsHandled();
                    }
                };
                Promise.prototype._isRejectionUnhandled = function Promise$_isRejectionUnhandled() {
                    return (this._bitField & 2097152) > 0;
                };
                Promise.prototype._setUnhandledRejectionIsNotified = function Promise$_setUnhandledRejectionIsNotified() {
                    this._bitField = this._bitField | 524288;
                };
                Promise.prototype._unsetUnhandledRejectionIsNotified = function Promise$_unsetUnhandledRejectionIsNotified() {
                    this._bitField = this._bitField & ~524288;
                };
                Promise.prototype._isUnhandledRejectionNotified = function Promise$_isUnhandledRejectionNotified() {
                    return (this._bitField & 524288) > 0;
                };
                Promise.prototype._setCarriedStackTrace = function Promise$_setCarriedStackTrace(capturedTrace) {
                    this._bitField = this._bitField | 1048576;
                    this._fulfillmentHandler0 = capturedTrace;
                };
                Promise.prototype._unsetCarriedStackTrace = function Promise$_unsetCarriedStackTrace() {
                    this._bitField = this._bitField & ~1048576;
                    this._fulfillmentHandler0 = void 0;
                };
                Promise.prototype._isCarryingStackTrace = function Promise$_isCarryingStackTrace() {
                    return (this._bitField & 1048576) > 0;
                };
                Promise.prototype._getCarriedStackTrace = function Promise$_getCarriedStackTrace() {
                    return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0;
                };
                Promise.prototype._receiverAt = function Promise$_receiverAt(index) {
                    var ret = index === 0 ? this._receiver0 : this[(index << 2) + index - 5 + 4];
                    if (this._isBound() && ret === void 0) {
                        return this._boundTo;
                    }
                    return ret;
                };
                Promise.prototype._promiseAt = function Promise$_promiseAt(index) {
                    return index === 0 ? this._promise0 : this[(index << 2) + index - 5 + 3];
                };
                Promise.prototype._fulfillmentHandlerAt = function Promise$_fulfillmentHandlerAt(index) {
                    return index === 0 ? this._fulfillmentHandler0 : this[(index << 2) + index - 5 + 0];
                };
                Promise.prototype._rejectionHandlerAt = function Promise$_rejectionHandlerAt(index) {
                    return index === 0 ? this._rejectionHandler0 : this[(index << 2) + index - 5 + 1];
                };
                Promise.prototype._addCallbacks = function Promise$_addCallbacks(fulfill, reject, progress, promise, receiver) {
                    var index = this._length();
                    if (index >= 262143 - 5) {
                        index = 0;
                        this._setLength(0);
                    }
                    if (index === 0) {
                        this._promise0 = promise;
                        if (receiver !== void 0)
                            this._receiver0 = receiver;
                        if (typeof fulfill === 'function' && !this._isCarryingStackTrace())
                            this._fulfillmentHandler0 = fulfill;
                        if (typeof reject === 'function')
                            this._rejectionHandler0 = reject;
                        if (typeof progress === 'function')
                            this._progressHandler0 = progress;
                    } else {
                        var base = (index << 2) + index - 5;
                        this[base + 3] = promise;
                        this[base + 4] = receiver;
                        this[base + 0] = typeof fulfill === 'function' ? fulfill : void 0;
                        this[base + 1] = typeof reject === 'function' ? reject : void 0;
                        this[base + 2] = typeof progress === 'function' ? progress : void 0;
                    }
                    this._setLength(index + 1);
                    return index;
                };
                Promise.prototype._setProxyHandlers = function Promise$_setProxyHandlers(receiver, promiseSlotValue) {
                    var index = this._length();
                    if (index >= 262143 - 5) {
                        index = 0;
                        this._setLength(0);
                    }
                    if (index === 0) {
                        this._promise0 = promiseSlotValue;
                        this._receiver0 = receiver;
                    } else {
                        var base = (index << 2) + index - 5;
                        this[base + 3] = promiseSlotValue;
                        this[base + 4] = receiver;
                        this[base + 0] = this[base + 1] = this[base + 2] = void 0;
                    }
                    this._setLength(index + 1);
                };
                Promise.prototype._proxyPromiseArray = function Promise$_proxyPromiseArray(promiseArray, index) {
                    this._setProxyHandlers(promiseArray, index);
                };
                Promise.prototype._proxyPromise = function Promise$_proxyPromise(promise) {
                    promise._setProxied();
                    this._setProxyHandlers(promise, -15);
                };
                Promise.prototype._setBoundTo = function Promise$_setBoundTo(obj) {
                    if (obj !== void 0) {
                        this._bitField = this._bitField | 8388608;
                        this._boundTo = obj;
                    } else {
                        this._bitField = this._bitField & ~8388608;
                    }
                };
                Promise.prototype._isBound = function Promise$_isBound() {
                    return (this._bitField & 8388608) === 8388608;
                };
                Promise.prototype._resolveFromResolver = function Promise$_resolveFromResolver(resolver) {
                    var promise = this;
                    this._setTrace(void 0);
                    this._pushContext();
                    function Promise$_resolver(val) {
                        if (promise._tryFollow(val)) {
                            return;
                        }
                        promise._fulfill(val);
                    }
                    function Promise$_rejecter(val) {
                        var trace = canAttach(val) ? val : new Error(val + '');
                        promise._attachExtraTrace(trace);
                        markAsOriginatingFromRejection(val);
                        promise._reject(val, trace === val ? void 0 : trace);
                    }
                    var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);
                    this._popContext();
                    if (r !== void 0 && r === errorObj) {
                        var e = r.e;
                        var trace = canAttach(e) ? e : new Error(e + '');
                        promise._reject(e, trace);
                    }
                };
                Promise.prototype._spreadSlowCase = function Promise$_spreadSlowCase(targetFn, promise, values, boundTo) {
                    var promiseForAll = new PromiseArray(values).promise();
                    var promise2 = promiseForAll._then(function () {
                        return targetFn.apply(boundTo, arguments);
                    }, void 0, void 0, APPLY, void 0);
                    promise._follow(promise2);
                };
                Promise.prototype._callSpread = function Promise$_callSpread(handler, promise, value) {
                    var boundTo = this._boundTo;
                    if (isArray(value)) {
                        for (var i = 0, len = value.length; i < len; ++i) {
                            if (cast(value[i], void 0) instanceof Promise) {
                                this._spreadSlowCase(handler, promise, value, boundTo);
                                return;
                            }
                        }
                    }
                    promise._pushContext();
                    return tryCatchApply(handler, value, boundTo);
                };
                Promise.prototype._callHandler = function Promise$_callHandler(handler, receiver, promise, value) {
                    var x;
                    if (receiver === APPLY && !this.isRejected()) {
                        x = this._callSpread(handler, promise, value);
                    } else {
                        promise._pushContext();
                        x = tryCatch1(handler, receiver, value);
                    }
                    promise._popContext();
                    return x;
                };
                Promise.prototype._settlePromiseFromHandler = function Promise$_settlePromiseFromHandler(handler, receiver, value, promise) {
                    if (!(promise instanceof Promise)) {
                        handler.call(receiver, value, promise);
                        return;
                    }
                    if (promise.isResolved())
                        return;
                    var x = this._callHandler(handler, receiver, promise, value);
                    if (promise._isFollowing())
                        return;
                    if (x === errorObj || x === promise || x === NEXT_FILTER) {
                        var err = x === promise ? makeSelfResolutionError() : x.e;
                        var trace = canAttach(err) ? err : new Error(err + '');
                        if (x !== NEXT_FILTER)
                            promise._attachExtraTrace(trace);
                        promise._rejectUnchecked(err, trace);
                    } else {
                        var castValue = cast(x, promise);
                        if (castValue instanceof Promise) {
                            if (castValue.isRejected() && !castValue._isCarryingStackTrace() && !canAttach(castValue._settledValue)) {
                                var trace = new Error(castValue._settledValue + '');
                                promise._attachExtraTrace(trace);
                                castValue._setCarriedStackTrace(trace);
                            }
                            promise._follow(castValue);
                            promise._propagateFrom(castValue, 1);
                        } else {
                            promise._fulfillUnchecked(x);
                        }
                    }
                };
                Promise.prototype._follow = function Promise$_follow(promise) {
                    this._setFollowing();
                    if (promise.isPending()) {
                        this._propagateFrom(promise, 1);
                        promise._proxyPromise(this);
                    } else if (promise.isFulfilled()) {
                        this._fulfillUnchecked(promise._settledValue);
                    } else {
                        this._rejectUnchecked(promise._settledValue, promise._getCarriedStackTrace());
                    }
                    if (promise._isRejectionUnhandled())
                        promise._unsetRejectionIsUnhandled();
                    if (debugging && promise._traceParent == null) {
                        promise._traceParent = this;
                    }
                };
                Promise.prototype._tryFollow = function Promise$_tryFollow(value) {
                    if (this._isFollowingOrFulfilledOrRejected() || value === this) {
                        return false;
                    }
                    var maybePromise = cast(value, void 0);
                    if (!(maybePromise instanceof Promise)) {
                        return false;
                    }
                    this._follow(maybePromise);
                    return true;
                };
                Promise.prototype._resetTrace = function Promise$_resetTrace() {
                    if (debugging) {
                        this._trace = new CapturedTrace(this._peekContext() === void 0);
                    }
                };
                Promise.prototype._setTrace = function Promise$_setTrace(parent) {
                    if (debugging) {
                        var context = this._peekContext();
                        this._traceParent = context;
                        var isTopLevel = context === void 0;
                        if (parent !== void 0 && parent._traceParent === context) {
                            this._trace = parent._trace;
                        } else {
                            this._trace = new CapturedTrace(isTopLevel);
                        }
                    }
                    return this;
                };
                Promise.prototype._tryAttachExtraTrace = function Promise$_tryAttachExtraTrace(error) {
                    if (canAttach(error)) {
                        this._attachExtraTrace(error);
                    }
                };
                Promise.prototype._attachExtraTrace = function Promise$_attachExtraTrace(error) {
                    if (debugging) {
                        var promise = this;
                        var stack = error.stack;
                        stack = typeof stack === 'string' ? stack.split('\n') : [];
                        CapturedTrace.protectErrorMessageNewlines(stack);
                        var headerLineCount = 1;
                        var combinedTraces = 1;
                        while (promise != null && promise._trace != null) {
                            stack = CapturedTrace.combine(stack, promise._trace.stack.split('\n'));
                            promise = promise._traceParent;
                            combinedTraces++;
                        }
                        var stackTraceLimit = Error.stackTraceLimit || 10;
                        var max = (stackTraceLimit + headerLineCount) * combinedTraces;
                        var len = stack.length;
                        if (len > max) {
                            stack.length = max;
                        }
                        if (len > 0)
                            stack[0] = stack[0].split('\x02\0\x01').join('\n');
                        if (stack.length <= headerLineCount) {
                            error.stack = '(No stack trace)';
                        } else {
                            error.stack = stack.join('\n');
                        }
                    }
                };
                Promise.prototype._cleanValues = function Promise$_cleanValues() {
                    if (this._cancellable()) {
                        this._cancellationParent = void 0;
                    }
                };
                Promise.prototype._propagateFrom = function Promise$_propagateFrom(parent, flags) {
                    if ((flags & 1) > 0 && parent._cancellable()) {
                        this._setCancellable();
                        this._cancellationParent = parent;
                    }
                    if ((flags & 4) > 0) {
                        this._setBoundTo(parent._boundTo);
                    }
                    if ((flags & 2) > 0) {
                        this._setTrace(parent);
                    }
                };
                Promise.prototype._fulfill = function Promise$_fulfill(value) {
                    if (this._isFollowingOrFulfilledOrRejected())
                        return;
                    this._fulfillUnchecked(value);
                };
                Promise.prototype._reject = function Promise$_reject(reason, carriedStackTrace) {
                    if (this._isFollowingOrFulfilledOrRejected())
                        return;
                    this._rejectUnchecked(reason, carriedStackTrace);
                };
                Promise.prototype._settlePromiseAt = function Promise$_settlePromiseAt(index) {
                    var handler = this.isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);
                    var value = this._settledValue;
                    var receiver = this._receiverAt(index);
                    var promise = this._promiseAt(index);
                    if (typeof handler === 'function') {
                        this._settlePromiseFromHandler(handler, receiver, value, promise);
                    } else {
                        var done = false;
                        var isFulfilled = this.isFulfilled();
                        if (receiver !== void 0) {
                            if (receiver instanceof Promise && receiver._isProxied()) {
                                receiver._unsetProxied();
                                if (isFulfilled)
                                    receiver._fulfillUnchecked(value);
                                else
                                    receiver._rejectUnchecked(value, this._getCarriedStackTrace());
                                done = true;
                            } else if (receiver instanceof PromiseArray) {
                                if (isFulfilled)
                                    receiver._promiseFulfilled(value, promise);
                                else
                                    receiver._promiseRejected(value, promise);
                                done = true;
                            }
                        }
                        if (!done) {
                            if (isFulfilled)
                                promise._fulfill(value);
                            else
                                promise._reject(value, this._getCarriedStackTrace());
                        }
                    }
                    if (index >= 4) {
                        this._queueGC();
                    }
                };
                Promise.prototype._isProxied = function Promise$_isProxied() {
                    return (this._bitField & 4194304) === 4194304;
                };
                Promise.prototype._setProxied = function Promise$_setProxied() {
                    this._bitField = this._bitField | 4194304;
                };
                Promise.prototype._unsetProxied = function Promise$_unsetProxied() {
                    this._bitField = this._bitField & ~4194304;
                };
                Promise.prototype._isGcQueued = function Promise$_isGcQueued() {
                    return (this._bitField & -1073741824) === -1073741824;
                };
                Promise.prototype._setGcQueued = function Promise$_setGcQueued() {
                    this._bitField = this._bitField | -1073741824;
                };
                Promise.prototype._unsetGcQueued = function Promise$_unsetGcQueued() {
                    this._bitField = this._bitField & ~-1073741824;
                };
                Promise.prototype._queueGC = function Promise$_queueGC() {
                    if (this._isGcQueued())
                        return;
                    this._setGcQueued();
                    async.invokeLater(this._gc, this, void 0);
                };
                Promise.prototype._gc = function Promise$gc() {
                    var len = this._length() * 5 - 5;
                    for (var i = 0; i < len; i++) {
                        delete this[i];
                    }
                    this._clearFirstHandlerData();
                    this._setLength(0);
                    this._unsetGcQueued();
                };
                Promise.prototype._clearFirstHandlerData = function Promise$_clearFirstHandlerData() {
                    this._fulfillmentHandler0 = void 0;
                    this._rejectionHandler0 = void 0;
                    this._promise0 = void 0;
                    this._receiver0 = void 0;
                };
                Promise.prototype._queueSettleAt = function Promise$_queueSettleAt(index) {
                    if (this._isRejectionUnhandled())
                        this._unsetRejectionIsUnhandled();
                    async.invoke(this._settlePromiseAt, this, index);
                };
                Promise.prototype._fulfillUnchecked = function Promise$_fulfillUnchecked(value) {
                    if (!this.isPending())
                        return;
                    if (value === this) {
                        var err = makeSelfResolutionError();
                        this._attachExtraTrace(err);
                        return this._rejectUnchecked(err, void 0);
                    }
                    this._cleanValues();
                    this._setFulfilled();
                    this._settledValue = value;
                    var len = this._length();
                    if (len > 0) {
                        async.invoke(this._settlePromises, this, len);
                    }
                };
                Promise.prototype._rejectUncheckedCheckError = function Promise$_rejectUncheckedCheckError(reason) {
                    var trace = canAttach(reason) ? reason : new Error(reason + '');
                    this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
                };
                Promise.prototype._rejectUnchecked = function Promise$_rejectUnchecked(reason, trace) {
                    if (!this.isPending())
                        return;
                    if (reason === this) {
                        var err = makeSelfResolutionError();
                        this._attachExtraTrace(err);
                        return this._rejectUnchecked(err);
                    }
                    this._cleanValues();
                    this._setRejected();
                    this._settledValue = reason;
                    if (this._isFinal()) {
                        async.invokeLater(thrower, void 0, trace === void 0 ? reason : trace);
                        return;
                    }
                    var len = this._length();
                    if (trace !== void 0)
                        this._setCarriedStackTrace(trace);
                    if (len > 0) {
                        async.invoke(this._rejectPromises, this, null);
                    } else {
                        this._ensurePossibleRejectionHandled();
                    }
                };
                Promise.prototype._rejectPromises = function Promise$_rejectPromises() {
                    this._settlePromises();
                    this._unsetCarriedStackTrace();
                };
                Promise.prototype._settlePromises = function Promise$_settlePromises() {
                    var len = this._length();
                    for (var i = 0; i < len; i++) {
                        this._settlePromiseAt(i);
                    }
                };
                Promise.prototype._ensurePossibleRejectionHandled = function Promise$_ensurePossibleRejectionHandled() {
                    this._setRejectionIsUnhandled();
                    if (CapturedTrace.possiblyUnhandledRejection !== void 0) {
                        async.invokeLater(this._notifyUnhandledRejection, this, void 0);
                    }
                };
                Promise.prototype._notifyUnhandledRejectionIsHandled = function Promise$_notifyUnhandledRejectionIsHandled() {
                    if (typeof unhandledRejectionHandled === 'function') {
                        async.invokeLater(unhandledRejectionHandled, void 0, this);
                    }
                };
                Promise.prototype._notifyUnhandledRejection = function Promise$_notifyUnhandledRejection() {
                    if (this._isRejectionUnhandled()) {
                        var reason = this._settledValue;
                        var trace = this._getCarriedStackTrace();
                        this._setUnhandledRejectionIsNotified();
                        if (trace !== void 0) {
                            this._unsetCarriedStackTrace();
                            reason = trace;
                        }
                        if (typeof CapturedTrace.possiblyUnhandledRejection === 'function') {
                            CapturedTrace.possiblyUnhandledRejection(reason, this);
                        }
                    }
                };
                var contextStack = [];
                Promise.prototype._peekContext = function Promise$_peekContext() {
                    var lastIndex = contextStack.length - 1;
                    if (lastIndex >= 0) {
                        return contextStack[lastIndex];
                    }
                    return void 0;
                };
                Promise.prototype._pushContext = function Promise$_pushContext() {
                    if (!debugging)
                        return;
                    contextStack.push(this);
                };
                Promise.prototype._popContext = function Promise$_popContext() {
                    if (!debugging)
                        return;
                    contextStack.pop();
                };
                Promise.noConflict = function Promise$NoConflict() {
                    return noConflict(Promise);
                };
                Promise.setScheduler = function (fn) {
                    if (typeof fn !== 'function')
                        throw new TypeError('fn must be a function');
                    async._schedule = fn;
                };
                if (!CapturedTrace.isSupported()) {
                    Promise.longStackTraces = function () {
                    };
                    debugging = false;
                }
                Promise._makeSelfResolutionError = makeSelfResolutionError;
                require(82)(Promise, NEXT_FILTER, cast);
                require(83)(Promise);
                require(84)(Promise);
                require(85)(Promise, PromiseArray, cast, INTERNAL);
                Promise.RangeError = RangeError;
                Promise.CancellationError = CancellationError;
                Promise.TimeoutError = TimeoutError;
                Promise.TypeError = TypeError;
                Promise.OperationalError = OperationalError;
                Promise.RejectionError = OperationalError;
                Promise.AggregateError = errors.AggregateError;
                util.toFastProperties(Promise);
                util.toFastProperties(Promise.prototype);
                Promise.Promise = Promise;
                require(86)(Promise, INTERNAL, cast);
                require(87)(Promise, INTERNAL, cast);
                require(88)(Promise);
                require(90)(Promise, apiRejection, INTERNAL, cast);
                require(92)(Promise, PromiseArray, apiRejection, cast, INTERNAL);
                require(95)(Promise);
                require(96)(Promise, INTERNAL);
                require(97)(Promise, PromiseArray, cast);
                require(98)(Promise, PromiseArray, apiRejection, cast, INTERNAL);
                require(99)(Promise, PromiseArray);
                require(101)(Promise, PromiseArray, apiRejection);
                require(105)(Promise, PromiseArray);
                require(109)(Promise, INTERNAL);
                require(112)(Promise, INTERNAL);
                require(114)(Promise, PromiseArray);
                require(116)(Promise, INTERNAL);
                require(118)(Promise, apiRejection, cast);
                Promise.prototype = Promise.prototype;
                return Promise;
            };
        });
        _define(40, function (module, exports) {
            var buf = require('buffer');
            var Buffer = buf.Buffer;
            module.exports = function (o) {
                return typeof o === 'object' && o instanceof Buffer;
            };
        });
        _define(41, function (module, exports) {
            module.exports = require(70).reduce(function (acc, x) {
                acc[x] = true;
                return acc;
            }, {});
        });
        _define(42, function (module, exports) {
            var Stream = require('stream').Stream;
            module.exports = function (o) {
                return !!o && o instanceof Stream;
            };
        });
        _define(43, function (module, exports) {
            var core = require(41);
            var fs = require('fs');
            var path = require('path');
            var caller = require(72);
            var nodeModulesPaths = require(75);
            module.exports = function resolve(x, opts, cb) {
                if (typeof opts === 'function') {
                    cb = opts;
                    opts = {};
                }
                if (!opts)
                    opts = {};
                if (typeof x !== 'string') {
                    return process.nextTick(function () {
                        cb(new Error('path must be a string'));
                    });
                }
                var isFile = opts.isFile || function (file, cb) {
                    fs.stat(file, function (err, stat) {
                        if (err && err.code === 'ENOENT')
                            cb(null, false);
                        else if (err)
                            cb(err);
                        else
                            cb(null, stat.isFile() || stat.isFIFO());
                    });
                };
                var readFile = opts.readFile || fs.readFile;
                var extensions = opts.extensions || ['.js'];
                var y = opts.basedir || path.dirname(caller());
                opts.paths = opts.paths || [];
                if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[\\\/])/.test(x)) {
                    var res = path.resolve(y, x);
                    if (x === '..')
                        res += '/';
                    loadAsFile(res, function (err, m, pkg) {
                        if (err)
                            cb(err);
                        else if (m)
                            cb(null, m, pkg);
                        else
                            loadAsDirectory(path.resolve(y, x), function (err, d, pkg) {
                                if (err)
                                    cb(err);
                                else if (d)
                                    cb(null, d, pkg);
                                else
                                    cb(new Error('Cannot find module \'' + x + '\' from \'' + y + '\''));
                            });
                    });
                } else
                    loadNodeModules(x, y, function (err, n, pkg) {
                        if (err)
                            cb(err);
                        else if (n)
                            cb(null, n, pkg);
                        else if (core[x])
                            return cb(null, x);
                        else
                            cb(new Error('Cannot find module \'' + x + '\' from \'' + y + '\''));
                    });
                function loadAsFile(x, pkg, cb) {
                    if (typeof pkg === 'function') {
                        cb = pkg;
                        pkg = opts.package;
                    }
                    (function load(exts) {
                        if (exts.length === 0)
                            return cb(null, undefined, pkg);
                        var file = x + exts[0];
                        isFile(file, function (err, ex) {
                            if (err)
                                cb(err);
                            else if (ex)
                                cb(null, file, pkg);
                            else
                                load(exts.slice(1));
                        });
                    }([''].concat(extensions)));
                }
                function loadAsDirectory(x, fpkg, cb) {
                    if (typeof fpkg === 'function') {
                        cb = fpkg;
                        fpkg = opts.package;
                    }
                    var pkgfile = path.join(x, '/package.json');
                    isFile(pkgfile, function (err, ex) {
                        if (err)
                            return cb(err);
                        if (!ex)
                            return loadAsFile(path.join(x, '/index'), fpkg, cb);
                        readFile(pkgfile, function (err, body) {
                            if (err)
                                return cb(err);
                            try {
                                var pkg = JSON.parse(body);
                            } catch (err) {
                            }
                            if (opts.packageFilter) {
                                pkg = opts.packageFilter(pkg, x);
                            }
                            if (pkg.main) {
                                if (pkg.main === '.' || pkg.main === './') {
                                    pkg.main = 'index';
                                }
                                loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                                    if (err)
                                        return cb(err);
                                    if (m)
                                        return cb(null, m, pkg);
                                    if (!pkg)
                                        return loadAsFile(path.join(x, '/index'), pkg, cb);
                                    var dir = path.resolve(x, pkg.main);
                                    loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                        if (err)
                                            return cb(err);
                                        if (n)
                                            return cb(null, n, pkg);
                                        loadAsFile(path.join(x, '/index'), pkg, cb);
                                    });
                                });
                                return;
                            }
                            loadAsFile(path.join(x, '/index'), pkg, cb);
                        });
                    });
                }
                function loadNodeModules(x, start, cb) {
                    (function process(dirs) {
                        if (dirs.length === 0)
                            return cb(null, undefined);
                        var dir = dirs[0];
                        loadAsFile(path.join(dir, '/', x), undefined, function (err, m, pkg) {
                            if (err)
                                return cb(err);
                            if (m)
                                return cb(null, m, pkg);
                            loadAsDirectory(path.join(dir, '/', x), undefined, function (err, n, pkg) {
                                if (err)
                                    return cb(err);
                                if (n)
                                    return cb(null, n, pkg);
                                process(dirs.slice(1));
                            });
                        });
                    }(nodeModulesPaths(start, opts)));
                }
            };
        });
        _define(44, function (module, exports) {
            module.exports = function (v) {
                return v === null;
            };
        });
        _define(45, function (module, exports) {
            var core = require(41);
            var fs = require('fs');
            var path = require('path');
            var caller = require(72);
            var nodeModulesPaths = require(75);
            module.exports = function (x, opts) {
                if (!opts)
                    opts = {};
                var isFile = opts.isFile || function (file) {
                    try {
                        var stat = fs.statSync(file);
                    } catch (err) {
                        if (err && err.code === 'ENOENT')
                            return false;
                    }
                    return stat.isFile() || stat.isFIFO();
                };
                var readFileSync = opts.readFileSync || fs.readFileSync;
                var extensions = opts.extensions || ['.js'];
                var y = opts.basedir || path.dirname(caller());
                opts.paths = opts.paths || [];
                if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[\\\/])/.test(x)) {
                    var res = path.resolve(y, x);
                    if (x === '..')
                        res += '/';
                    var m = loadAsFileSync(res) || loadAsDirectorySync(res);
                    if (m)
                        return m;
                } else {
                    var n = loadNodeModulesSync(x, y);
                    if (n)
                        return n;
                }
                if (core[x])
                    return x;
                throw new Error('Cannot find module \'' + x + '\' from \'' + y + '\'');
                function loadAsFileSync(x) {
                    if (isFile(x)) {
                        return x;
                    }
                    for (var i = 0; i < extensions.length; i++) {
                        var file = x + extensions[i];
                        if (isFile(file)) {
                            return file;
                        }
                    }
                }
                function loadAsDirectorySync(x) {
                    var pkgfile = path.join(x, '/package.json');
                    if (isFile(pkgfile)) {
                        var body = readFileSync(pkgfile, 'utf8');
                        try {
                            var pkg = JSON.parse(body);
                            if (opts.packageFilter) {
                                pkg = opts.packageFilter(pkg, x);
                            }
                            if (pkg.main) {
                                var m = loadAsFileSync(path.resolve(x, pkg.main));
                                if (m)
                                    return m;
                                var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                                if (n)
                                    return n;
                            }
                        } catch (err) {
                        }
                    }
                    return loadAsFileSync(path.join(x, '/index'));
                }
                function loadNodeModulesSync(x, start) {
                    var dirs = nodeModulesPaths(start, opts);
                    for (var i = 0; i < dirs.length; i++) {
                        var dir = dirs[i];
                        var m = loadAsFileSync(path.join(dir, '/', x));
                        if (m)
                            return m;
                        var n = loadAsDirectorySync(path.join(dir, '/', x));
                        if (n)
                            return n;
                    }
                }
            };
        });
        _define(46, function (module, exports) {
            var isStream = require(42);
            module.exports = function (stream) {
                if (!isStream(stream))
                    return;
                var streamType = stream.constructor.name;
                if (streamType === 'Stream')
                    streamType = '';
                return '<' + streamType + 'Stream>';
            };
        });
        _define(47, function (module, exports) {
            'use strict';
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            var util = {
                isArray: function (ar) {
                    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
                },
                isDate: function (d) {
                    return typeof d === 'object' && objectToString(d) === '[object Date]';
                },
                isRegExp: function (re) {
                    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
                },
                getRegExpFlags: function (re) {
                    var flags = '';
                    re.global && (flags += 'g');
                    re.ignoreCase && (flags += 'i');
                    re.multiline && (flags += 'm');
                    return flags;
                }
            };
            if (typeof module === 'object')
                module.exports = clone;
            function clone(parent, circular, depth, prototype) {
                var allParents = [];
                var allChildren = [];
                var useBuffer = typeof Buffer != 'undefined';
                if (typeof circular == 'undefined')
                    circular = true;
                if (typeof depth == 'undefined')
                    depth = Infinity;
                function _clone(parent, depth) {
                    if (parent === null)
                        return null;
                    if (depth == 0)
                        return parent;
                    var child;
                    var proto;
                    if (typeof parent != 'object') {
                        return parent;
                    }
                    if (util.isArray(parent)) {
                        child = [];
                    } else if (util.isRegExp(parent)) {
                        child = new RegExp(parent.source, util.getRegExpFlags(parent));
                        if (parent.lastIndex)
                            child.lastIndex = parent.lastIndex;
                    } else if (util.isDate(parent)) {
                        child = new Date(parent.getTime());
                    } else if (useBuffer && Buffer.isBuffer(parent)) {
                        child = new Buffer(parent.length);
                        parent.copy(child);
                        return child;
                    } else {
                        if (typeof prototype == 'undefined') {
                            proto = Object.getPrototypeOf(parent);
                            child = Object.create(proto);
                        } else {
                            child = Object.create(prototype);
                            proto = prototype;
                        }
                    }
                    if (circular) {
                        var index = allParents.indexOf(parent);
                        if (index != -1) {
                            return allChildren[index];
                        }
                        allParents.push(parent);
                        allChildren.push(child);
                    }
                    for (var i in parent) {
                        var attrs;
                        if (proto) {
                            attrs = Object.getOwnPropertyDescriptor(proto, i);
                        }
                        if (attrs && attrs.set == null) {
                            continue;
                        }
                        child[i] = _clone(parent[i], depth - 1);
                    }
                    return child;
                }
                return _clone(parent, depth);
            }
            clone.clonePrototype = function (parent) {
                if (parent === null)
                    return null;
                var c = function () {
                };
                c.prototype = parent;
                return new c();
            };
        });
        _define(48, function (module, exports) {
            var Stat = require('fs').Stats;
            module.exports = cloneStats;
            function cloneStats(stats) {
                var replacement = new Stat();
                Object.keys(stats).forEach(function (key) {
                    replacement[key] = stats[key];
                });
                return replacement;
            }
        });
        _define(49, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var fs = require(54);
            function getStats() {
                return through2.obj(fetchStats);
            }
            function fetchStats(file, enc, cb) {
                fs.lstat(file.path, function (err, stat) {
                    if (stat) {
                        file.stat = stat;
                    }
                    cb(err, file);
                });
            }
            module.exports = getStats;
        });
        _define(50, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var readDir = require(89);
            var bufferFile = require(91);
            var streamFile = require(93);
            function getContents(opt) {
                return through2.obj(function (file, enc, cb) {
                    if (file.isDirectory()) {
                        return readDir(file, cb);
                    }
                    if (opt.buffer !== false) {
                        return bufferFile(file, cb);
                    }
                    return streamFile(file, cb);
                });
            }
            module.exports = getContents;
        });
        _define(51, function (module, exports) {
            var clone = require(94);
            module.exports = function (options, defaults) {
                options = options || {};
                Object.keys(defaults).forEach(function (key) {
                    if (typeof options[key] === 'undefined') {
                        options[key] = clone(defaults[key]);
                    }
                });
                return options;
            };
        });
        _define(52, function (module, exports) {
            'use strict';
            var through2 = require(6);
            var Combine = require(100);
            var unique = require(104);
            var glob = require(108);
            var minimatch = require(111);
            var glob2base = require(113);
            var path = require('path');
            var gs = {
                createStream: function (ourGlob, negatives, opt) {
                    if (!negatives)
                        negatives = [];
                    if (!opt)
                        opt = {};
                    if (typeof opt.cwd !== 'string')
                        opt.cwd = process.cwd();
                    if (typeof opt.dot !== 'boolean')
                        opt.dot = false;
                    if (typeof opt.silent !== 'boolean')
                        opt.silent = true;
                    if (typeof opt.nonull !== 'boolean')
                        opt.nonull = false;
                    if (typeof opt.cwdbase !== 'boolean')
                        opt.cwdbase = false;
                    if (opt.cwdbase)
                        opt.base = opt.cwd;
                    ourGlob = unrelative(opt.cwd, ourGlob);
                    negatives = negatives.map(unrelative.bind(null, opt.cwd));
                    var globber = new glob.Glob(ourGlob, opt);
                    var basePath = opt.base ? opt.base : glob2base(globber);
                    var stream = through2.obj(negatives.length ? filterNegatives : undefined);
                    globber.on('error', stream.emit.bind(stream, 'error'));
                    globber.on('end', function () {
                        stream.end();
                    });
                    globber.on('match', function (filename) {
                        stream.write({
                            cwd: opt.cwd,
                            base: basePath,
                            path: path.resolve(opt.cwd, filename)
                        });
                    });
                    return stream;
                    function filterNegatives(filename, enc, cb) {
                        var matcha = isMatch.bind(null, filename, opt);
                        if (negatives.every(matcha)) {
                            cb(null, filename);
                        } else {
                            cb();
                        }
                    }
                },
                create: function (globs, opt) {
                    if (!opt)
                        opt = {};
                    if (!Array.isArray(globs))
                        return gs.createStream(globs, null, opt);
                    var positives = globs.filter(isPositive);
                    var negatives = globs.filter(isNegative);
                    if (positives.length === 0)
                        throw new Error('Missing positive glob');
                    if (positives.length === 1)
                        return gs.createStream(positives[0], negatives, opt);
                    var streams = positives.map(function (glob) {
                        return gs.createStream(glob, negatives, opt);
                    });
                    var aggregate = new Combine(streams);
                    var uniqueStream = unique('path');
                    return aggregate.pipe(uniqueStream);
                }
            };
            function isMatch(file, opt, pattern) {
                if (typeof pattern === 'string')
                    return minimatch(file.path, pattern, opt);
                if (pattern instanceof RegExp)
                    return pattern.test(file.path);
                return true;
            }
            function isNegative(pattern) {
                if (typeof pattern !== 'string')
                    return true;
                if (pattern[0] === '!')
                    return true;
                return false;
            }
            function isPositive(pattern) {
                return !isNegative(pattern);
            }
            function unrelative(cwd, glob) {
                var mod = '';
                if (glob[0] === '!') {
                    mod = glob[0];
                    glob = glob.slice(1);
                }
                return mod + path.resolve(cwd, glob);
            }
            module.exports = gs;
        });
        _define(53, function (module, exports) {
            'use strict';
            var fs = require('fs');
            var writeDir = require(102);
            var writeStream = require(106);
            var writeBuffer = require(110);
            function writeContents(writePath, file, cb) {
                var written = function (err) {
                    var done = function (err) {
                        cb(err, file);
                    };
                    if (err) {
                        return done(err);
                    }
                    if (!file.stat || typeof file.stat.mode !== 'number') {
                        return done();
                    }
                    fs.stat(writePath, function (err, st) {
                        if (err) {
                            return done(err);
                        }
                        var currentMode = st.mode & 4095;
                        if (currentMode === file.stat.mode) {
                            return done();
                        }
                        fs.chmod(writePath, file.stat.mode, done);
                    });
                };
                if (file.isDirectory()) {
                    writeDir(writePath, file, written);
                    return;
                }
                if (file.isStream()) {
                    writeStream(writePath, file, written);
                    return;
                }
                if (file.isBuffer()) {
                    writeBuffer(writePath, file, written);
                    return;
                }
                if (file.isNull()) {
                    cb(null, file);
                    return;
                }
            }
            module.exports = writeContents;
        });
        _define(54, function (module, exports) {
            var fs = module.exports = require(103);
            var assert = require('assert');
            require(107);
            var util = require('util');
            function noop() {
            }
            var debug = noop;
            if (util.debuglog)
                debug = util.debuglog('gfs');
            else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
                debug = function () {
                    var m = util.format.apply(util, arguments);
                    m = 'GFS: ' + m.split(/\n/).join('\nGFS: ');
                    console.error(m);
                };
            if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
                process.on('exit', function () {
                    debug('fds', fds);
                    debug(queue);
                    assert.equal(queue.length, 0);
                });
            }
            var originalOpen = fs.open;
            fs.open = open;
            function open(path, flags, mode, cb) {
                if (typeof mode === 'function')
                    cb = mode, mode = null;
                if (typeof cb !== 'function')
                    cb = noop;
                new OpenReq(path, flags, mode, cb);
            }
            function OpenReq(path, flags, mode, cb) {
                this.path = path;
                this.flags = flags;
                this.mode = mode;
                this.cb = cb;
                Req.call(this);
            }
            util.inherits(OpenReq, Req);
            OpenReq.prototype.process = function () {
                originalOpen.call(fs, this.path, this.flags, this.mode, this.done);
            };
            var fds = {};
            OpenReq.prototype.done = function (er, fd) {
                debug('open done', er, fd);
                if (fd)
                    fds['fd' + fd] = this.path;
                Req.prototype.done.call(this, er, fd);
            };
            var originalReaddir = fs.readdir;
            fs.readdir = readdir;
            function readdir(path, cb) {
                if (typeof cb !== 'function')
                    cb = noop;
                new ReaddirReq(path, cb);
            }
            function ReaddirReq(path, cb) {
                this.path = path;
                this.cb = cb;
                Req.call(this);
            }
            util.inherits(ReaddirReq, Req);
            ReaddirReq.prototype.process = function () {
                originalReaddir.call(fs, this.path, this.done);
            };
            ReaddirReq.prototype.done = function (er, files) {
                if (files && files.sort)
                    files = files.sort();
                Req.prototype.done.call(this, er, files);
                onclose();
            };
            var originalClose = fs.close;
            fs.close = close;
            function close(fd, cb) {
                debug('close', fd);
                if (typeof cb !== 'function')
                    cb = noop;
                delete fds['fd' + fd];
                originalClose.call(fs, fd, function (er) {
                    onclose();
                    cb(er);
                });
            }
            var originalCloseSync = fs.closeSync;
            fs.closeSync = closeSync;
            function closeSync(fd) {
                try {
                    return originalCloseSync(fd);
                } finally {
                    onclose();
                }
            }
            function Req() {
                this.done = this.done.bind(this);
                this.failures = 0;
                this.process();
            }
            Req.prototype.done = function (er, result) {
                var tryAgain = false;
                if (er) {
                    var code = er.code;
                    var tryAgain = code === 'EMFILE';
                    if (process.platform === 'win32')
                        tryAgain = tryAgain || code === 'OK';
                }
                if (tryAgain) {
                    this.failures++;
                    enqueue(this);
                } else {
                    var cb = this.cb;
                    cb(er, result);
                }
            };
            var queue = [];
            function enqueue(req) {
                queue.push(req);
                debug('enqueue %d %s', queue.length, req.constructor.name, req);
            }
            function onclose() {
                var req = queue.shift();
                if (req) {
                    debug('process', req.constructor.name, req);
                    req.process();
                }
            }
        });
        _define(55, function (module, exports) {
            var path = require('path');
            var fs = require('fs');
            module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
            function mkdirP(p, opts, f, made) {
                if (typeof opts === 'function') {
                    f = opts;
                    opts = {};
                } else if (!opts || typeof opts !== 'object') {
                    opts = { mode: opts };
                }
                var mode = opts.mode;
                var xfs = opts.fs || fs;
                if (mode === undefined) {
                    mode = 511 & ~process.umask();
                }
                if (!made)
                    made = null;
                var cb = f || function () {
                };
                p = path.resolve(p);
                xfs.mkdir(p, mode, function (er) {
                    if (!er) {
                        made = made || p;
                        return cb(null, made);
                    }
                    switch (er.code) {
                    case 'ENOENT':
                        mkdirP(path.dirname(p), opts, function (er, made) {
                            if (er)
                                cb(er, made);
                            else
                                mkdirP(p, opts, cb, made);
                        });
                        break;
                    default:
                        xfs.stat(p, function (er2, stat) {
                            if (er2 || !stat.isDirectory())
                                cb(er, made);
                            else
                                cb(null, made);
                        });
                        break;
                    }
                });
            }
            mkdirP.sync = function sync(p, opts, made) {
                if (!opts || typeof opts !== 'object') {
                    opts = { mode: opts };
                }
                var mode = opts.mode;
                var xfs = opts.fs || fs;
                if (mode === undefined) {
                    mode = 511 & ~process.umask();
                }
                if (!made)
                    made = null;
                p = path.resolve(p);
                try {
                    xfs.mkdirSync(p, mode);
                    made = made || p;
                } catch (err0) {
                    switch (err0.code) {
                    case 'ENOENT':
                        made = sync(path.dirname(p), opts, made);
                        sync(p, opts, made);
                        break;
                    default:
                        var stat;
                        try {
                            stat = xfs.statSync(p);
                        } catch (err1) {
                            throw err0;
                        }
                        if (!stat.isDirectory())
                            throw err0;
                        break;
                    }
                }
                return made;
            };
        });
        _define(56, function (module, exports) {
            'use strict';
            var util = require('util');
            var EE = require('events').EventEmitter;
            var fs = require('fs');
            var path = require('path');
            var globule = require(117);
            var helper = require(115);
            var setImmediate = require('timers').setImmediate;
            if (typeof setImmediate !== 'function') {
                setImmediate = process.nextTick;
            }
            var delay = 10;
            function Gaze(patterns, opts, done) {
                var self = this;
                EE.call(self);
                if (typeof opts === 'function') {
                    done = opts;
                    opts = {};
                }
                opts = opts || {};
                opts.mark = true;
                opts.interval = opts.interval || 100;
                opts.debounceDelay = opts.debounceDelay || 500;
                opts.cwd = opts.cwd || process.cwd();
                this.options = opts;
                done = done || function () {
                };
                this._watched = Object.create(null);
                this._watchers = Object.create(null);
                this._pollers = Object.create(null);
                this._patterns = [];
                this._cached = Object.create(null);
                if (this.options.maxListeners) {
                    this.setMaxListeners(this.options.maxListeners);
                    Gaze.super_.prototype.setMaxListeners(this.options.maxListeners);
                    delete this.options.maxListeners;
                }
                if (patterns) {
                    this.add(patterns, done);
                }
                this._keepalive = setInterval(function () {
                }, 200);
                return this;
            }
            util.inherits(Gaze, EE);
            module.exports = function gaze(patterns, opts, done) {
                return new Gaze(patterns, opts, done);
            };
            module.exports.Gaze = Gaze;
            Gaze.prototype.emit = function () {
                var self = this;
                var args = arguments;
                var e = args[0];
                var filepath = args[1];
                var timeoutId;
                if (e.slice(-2) !== 'ed') {
                    Gaze.super_.prototype.emit.apply(self, args);
                    return this;
                }
                if (e === 'added') {
                    Object.keys(this._cached).forEach(function (oldFile) {
                        if (self._cached[oldFile].indexOf('deleted') !== -1) {
                            args[0] = e = 'renamed';
                            [].push.call(args, oldFile);
                            delete self._cached[oldFile];
                            return false;
                        }
                    });
                }
                var cache = this._cached[filepath] || [];
                if (cache.indexOf(e) === -1) {
                    helper.objectPush(self._cached, filepath, e);
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(function () {
                        delete self._cached[filepath];
                    }, this.options.debounceDelay);
                    Gaze.super_.prototype.emit.apply(self, args);
                    Gaze.super_.prototype.emit.apply(self, [
                        'all',
                        e
                    ].concat([].slice.call(args, 1)));
                }
                if (e === 'added') {
                    if (helper.isDir(filepath)) {
                        fs.readdirSync(filepath).map(function (file) {
                            return path.join(filepath, file);
                        }).filter(function (file) {
                            return globule.isMatch(self._patterns, file, self.options);
                        }).forEach(function (file) {
                            self.emit('added', file);
                        });
                    }
                }
                return this;
            };
            Gaze.prototype.close = function (_reset) {
                var self = this;
                _reset = _reset === false ? false : true;
                Object.keys(self._watchers).forEach(function (file) {
                    self._watchers[file].close();
                });
                self._watchers = Object.create(null);
                Object.keys(this._watched).forEach(function (dir) {
                    self._unpollDir(dir);
                });
                if (_reset) {
                    self._watched = Object.create(null);
                    setTimeout(function () {
                        self.emit('end');
                        self.removeAllListeners();
                        clearInterval(self._keepalive);
                    }, delay + 100);
                }
                return self;
            };
            Gaze.prototype.add = function (files, done) {
                if (typeof files === 'string') {
                    files = [files];
                }
                this._patterns = helper.unique.apply(null, [
                    this._patterns,
                    files
                ]);
                files = globule.find(this._patterns, this.options);
                this._addToWatched(files);
                this.close(false);
                this._initWatched(done);
            };
            Gaze.prototype._internalAdd = function (file, done) {
                var files = [];
                if (helper.isDir(file)) {
                    files = [helper.markDir(file)].concat(globule.find(this._patterns, this.options));
                } else {
                    if (globule.isMatch(this._patterns, file, this.options)) {
                        files = [file];
                    }
                }
                if (files.length > 0) {
                    this._addToWatched(files);
                    this.close(false);
                    this._initWatched(done);
                }
            };
            Gaze.prototype.remove = function (file) {
                var self = this;
                if (this._watched[file]) {
                    this._unpollDir(file);
                    delete this._watched[file];
                } else {
                    Object.keys(this._watched).forEach(function (dir) {
                        var index = self._watched[dir].indexOf(file);
                        if (index !== -1) {
                            self._unpollFile(file);
                            self._watched[dir].splice(index, 1);
                            return false;
                        }
                    });
                }
                if (this._watchers[file]) {
                    this._watchers[file].close();
                }
                return this;
            };
            Gaze.prototype.watched = function () {
                return this._watched;
            };
            Gaze.prototype.relative = function (dir, unixify) {
                var self = this;
                var relative = Object.create(null);
                var relDir, relFile, unixRelDir;
                var cwd = this.options.cwd || process.cwd();
                if (dir === '') {
                    dir = '.';
                }
                dir = helper.markDir(dir);
                unixify = unixify || false;
                Object.keys(this._watched).forEach(function (dir) {
                    relDir = path.relative(cwd, dir) + path.sep;
                    if (relDir === path.sep) {
                        relDir = '.';
                    }
                    unixRelDir = unixify ? helper.unixifyPathSep(relDir) : relDir;
                    relative[unixRelDir] = self._watched[dir].map(function (file) {
                        relFile = path.relative(path.join(cwd, relDir) || '', file || '');
                        if (helper.isDir(file)) {
                            relFile = helper.markDir(relFile);
                        }
                        if (unixify) {
                            relFile = helper.unixifyPathSep(relFile);
                        }
                        return relFile;
                    });
                });
                if (dir && unixify) {
                    dir = helper.unixifyPathSep(dir);
                }
                return dir ? relative[dir] || [] : relative;
            };
            Gaze.prototype._addToWatched = function (files) {
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    var filepath = path.resolve(this.options.cwd, file);
                    var dirname = helper.isDir(file) ? filepath : path.dirname(filepath);
                    dirname = helper.markDir(dirname);
                    if (helper.isDir(file) && !(filepath in this._watched)) {
                        helper.objectPush(this._watched, filepath, []);
                    }
                    if (file.slice(-1) === '/') {
                        filepath += path.sep;
                    }
                    helper.objectPush(this._watched, path.dirname(filepath) + path.sep, filepath);
                    var readdir = fs.readdirSync(dirname);
                    for (var j = 0; j < readdir.length; j++) {
                        var dirfile = path.join(dirname, readdir[j]);
                        if (fs.statSync(dirfile).isDirectory()) {
                            helper.objectPush(this._watched, dirname, dirfile + path.sep);
                        }
                    }
                }
                return this;
            };
            Gaze.prototype._watchDir = function (dir, done) {
                var self = this;
                var timeoutId;
                try {
                    this._watchers[dir] = fs.watch(dir, function (event) {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(function () {
                            if (dir in self._watchers && fs.existsSync(dir)) {
                                done(null, dir);
                            }
                        }, delay + 100);
                    });
                } catch (err) {
                    return this._handleError(err);
                }
                return this;
            };
            Gaze.prototype._unpollFile = function (file) {
                if (this._pollers[file]) {
                    fs.unwatchFile(file, this._pollers[file]);
                    delete this._pollers[file];
                }
                return this;
            };
            Gaze.prototype._unpollDir = function (dir) {
                this._unpollFile(dir);
                for (var i = 0; i < this._watched[dir].length; i++) {
                    this._unpollFile(this._watched[dir][i]);
                }
            };
            Gaze.prototype._pollFile = function (file, done) {
                var opts = {
                    persistent: true,
                    interval: this.options.interval
                };
                if (!this._pollers[file]) {
                    this._pollers[file] = function (curr, prev) {
                        done(null, file);
                    };
                    try {
                        fs.watchFile(file, opts, this._pollers[file]);
                    } catch (err) {
                        return this._handleError(err);
                    }
                }
                return this;
            };
            Gaze.prototype._initWatched = function (done) {
                var self = this;
                var cwd = this.options.cwd || process.cwd();
                var curWatched = Object.keys(self._watched);
                if (curWatched.length < 1) {
                    setImmediate(function () {
                        self.emit('ready', self);
                        if (done) {
                            done.call(self, null, self);
                        }
                        self.emit('nomatch');
                    });
                    return;
                }
                helper.forEachSeries(curWatched, function (dir, next) {
                    dir = dir || '';
                    var files = self._watched[dir];
                    self._watchDir(dir, function (event, dirpath) {
                        var relDir = cwd === dir ? '.' : path.relative(cwd, dir);
                        relDir = relDir || '';
                        fs.readdir(dirpath, function (err, current) {
                            if (err) {
                                return self.emit('error', err);
                            }
                            if (!current) {
                                return;
                            }
                            try {
                                current = current.map(function (curPath) {
                                    if (fs.existsSync(path.join(dir, curPath)) && fs.statSync(path.join(dir, curPath)).isDirectory()) {
                                        return curPath + path.sep;
                                    } else {
                                        return curPath;
                                    }
                                });
                            } catch (err) {
                            }
                            var previous = self.relative(relDir);
                            previous.filter(function (file) {
                                return current.indexOf(file) < 0;
                            }).forEach(function (file) {
                                if (!helper.isDir(file)) {
                                    var filepath = path.join(dir, file);
                                    self.remove(filepath);
                                    self.emit('deleted', filepath);
                                }
                            });
                            current.filter(function (file) {
                                return previous.indexOf(file) < 0;
                            }).forEach(function (file) {
                                var relFile = path.join(relDir, file);
                                self._internalAdd(relFile, function () {
                                    self.emit('added', path.join(dir, file));
                                });
                            });
                        });
                    });
                    files.forEach(function (file) {
                        if (helper.isDir(file)) {
                            return;
                        }
                        self._pollFile(file, function (err, filepath) {
                            if (fs.existsSync(filepath)) {
                                self.emit('changed', filepath);
                            }
                        });
                    });
                    next();
                }, function () {
                    setTimeout(function () {
                        self.emit('ready', self);
                        if (done) {
                            done.call(self, null, self);
                        }
                    }, delay + 100);
                });
            };
            Gaze.prototype._handleError = function (err) {
                if (err.code === 'EMFILE') {
                    return this.emit('error', new Error('EMFILE: Too many opened files.'));
                }
                return this.emit('error', err);
            };
        });
        _define(57, function (module, exports) {
            (function () {
                'use strict';
                function isExpression(node) {
                    if (node == null) {
                        return false;
                    }
                    switch (node.type) {
                    case 'ArrayExpression':
                    case 'AssignmentExpression':
                    case 'BinaryExpression':
                    case 'CallExpression':
                    case 'ConditionalExpression':
                    case 'FunctionExpression':
                    case 'Identifier':
                    case 'Literal':
                    case 'LogicalExpression':
                    case 'MemberExpression':
                    case 'NewExpression':
                    case 'ObjectExpression':
                    case 'SequenceExpression':
                    case 'ThisExpression':
                    case 'UnaryExpression':
                    case 'UpdateExpression':
                        return true;
                    }
                    return false;
                }
                function isIterationStatement(node) {
                    if (node == null) {
                        return false;
                    }
                    switch (node.type) {
                    case 'DoWhileStatement':
                    case 'ForInStatement':
                    case 'ForStatement':
                    case 'WhileStatement':
                        return true;
                    }
                    return false;
                }
                function isStatement(node) {
                    if (node == null) {
                        return false;
                    }
                    switch (node.type) {
                    case 'BlockStatement':
                    case 'BreakStatement':
                    case 'ContinueStatement':
                    case 'DebuggerStatement':
                    case 'DoWhileStatement':
                    case 'EmptyStatement':
                    case 'ExpressionStatement':
                    case 'ForInStatement':
                    case 'ForStatement':
                    case 'IfStatement':
                    case 'LabeledStatement':
                    case 'ReturnStatement':
                    case 'SwitchStatement':
                    case 'ThrowStatement':
                    case 'TryStatement':
                    case 'VariableDeclaration':
                    case 'WhileStatement':
                    case 'WithStatement':
                        return true;
                    }
                    return false;
                }
                function isSourceElement(node) {
                    return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
                }
                function trailingStatement(node) {
                    switch (node.type) {
                    case 'IfStatement':
                        if (node.alternate != null) {
                            return node.alternate;
                        }
                        return node.consequent;
                    case 'LabeledStatement':
                    case 'ForStatement':
                    case 'ForInStatement':
                    case 'WhileStatement':
                    case 'WithStatement':
                        return node.body;
                    }
                    return null;
                }
                function isProblematicIfStatement(node) {
                    var current;
                    if (node.type !== 'IfStatement') {
                        return false;
                    }
                    if (node.alternate == null) {
                        return false;
                    }
                    current = node.consequent;
                    do {
                        if (current.type === 'IfStatement') {
                            if (current.alternate == null) {
                                return true;
                            }
                        }
                        current = trailingStatement(current);
                    } while (current);
                    return false;
                }
                module.exports = {
                    isExpression: isExpression,
                    isStatement: isStatement,
                    isIterationStatement: isIterationStatement,
                    isSourceElement: isSourceElement,
                    isProblematicIfStatement: isProblematicIfStatement,
                    trailingStatement: trailingStatement
                };
            }());
        });
        _define(58, function (module, exports) {
            module.exports = Readable;
            var isArray = require(120);
            var Buffer = require('buffer').Buffer;
            Readable.ReadableState = ReadableState;
            var EE = require('events').EventEmitter;
            if (!EE.listenerCount)
                EE.listenerCount = function (emitter, type) {
                    return emitter.listeners(type).length;
                };
            var Stream = require('stream');
            var util = require(122);
            util.inherits = require(121);
            var StringDecoder;
            var debug = require('util');
            if (debug && debug.debuglog) {
                debug = debug.debuglog('stream');
            } else {
                debug = function () {
                };
            }
            util.inherits(Readable, Stream);
            function ReadableState(options, stream) {
                var Duplex = require(64);
                options = options || {};
                var hwm = options.highWaterMark;
                var defaultHwm = options.objectMode ? 16 : 16 * 1024;
                this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
                this.highWaterMark = ~~this.highWaterMark;
                this.buffer = [];
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;
                this.sync = true;
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.objectMode = !!options.objectMode;
                if (stream instanceof Duplex)
                    this.objectMode = this.objectMode || !!options.readableObjectMode;
                this.defaultEncoding = options.defaultEncoding || 'utf8';
                this.ranOut = false;
                this.awaitDrain = 0;
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                    if (!StringDecoder)
                        StringDecoder = require(123).StringDecoder;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                }
            }
            function Readable(options) {
                var Duplex = require(64);
                if (!(this instanceof Readable))
                    return new Readable(options);
                this._readableState = new ReadableState(options, this);
                this.readable = true;
                Stream.call(this);
            }
            Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState;
                if (util.isString(chunk) && !state.objectMode) {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                        chunk = new Buffer(chunk, encoding);
                        encoding = '';
                    }
                }
                return readableAddChunk(this, state, chunk, encoding, false);
            };
            Readable.prototype.unshift = function (chunk) {
                var state = this._readableState;
                return readableAddChunk(this, state, chunk, '', true);
            };
            function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                var er = chunkInvalid(state, chunk);
                if (er) {
                    stream.emit('error', er);
                } else if (util.isNullOrUndefined(chunk)) {
                    state.reading = false;
                    if (!state.ended)
                        onEofChunk(stream, state);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (state.ended && !addToFront) {
                        var e = new Error('stream.push() after EOF');
                        stream.emit('error', e);
                    } else if (state.endEmitted && addToFront) {
                        var e = new Error('stream.unshift() after end event');
                        stream.emit('error', e);
                    } else {
                        if (state.decoder && !addToFront && !encoding)
                            chunk = state.decoder.write(chunk);
                        if (!addToFront)
                            state.reading = false;
                        if (state.flowing && state.length === 0 && !state.sync) {
                            stream.emit('data', chunk);
                            stream.read(0);
                        } else {
                            state.length += state.objectMode ? 1 : chunk.length;
                            if (addToFront)
                                state.buffer.unshift(chunk);
                            else
                                state.buffer.push(chunk);
                            if (state.needReadable)
                                emitReadable(stream);
                        }
                        maybeReadMore(stream, state);
                    }
                } else if (!addToFront) {
                    state.reading = false;
                }
                return needMoreData(state);
            }
            function needMoreData(state) {
                return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }
            Readable.prototype.setEncoding = function (enc) {
                if (!StringDecoder)
                    StringDecoder = require(123).StringDecoder;
                this._readableState.decoder = new StringDecoder(enc);
                this._readableState.encoding = enc;
                return this;
            };
            var MAX_HWM = 8388608;
            function roundUpToNextPowerOf2(n) {
                if (n >= MAX_HWM) {
                    n = MAX_HWM;
                } else {
                    n--;
                    for (var p = 1; p < 32; p <<= 1)
                        n |= n >> p;
                    n++;
                }
                return n;
            }
            function howMuchToRead(n, state) {
                if (state.length === 0 && state.ended)
                    return 0;
                if (state.objectMode)
                    return n === 0 ? 0 : 1;
                if (isNaN(n) || util.isNull(n)) {
                    if (state.flowing && state.buffer.length)
                        return state.buffer[0].length;
                    else
                        return state.length;
                }
                if (n <= 0)
                    return 0;
                if (n > state.highWaterMark)
                    state.highWaterMark = roundUpToNextPowerOf2(n);
                if (n > state.length) {
                    if (!state.ended) {
                        state.needReadable = true;
                        return 0;
                    } else
                        return state.length;
                }
                return n;
            }
            Readable.prototype.read = function (n) {
                debug('read', n);
                var state = this._readableState;
                var nOrig = n;
                if (!util.isNumber(n) || n > 0)
                    state.emittedReadable = false;
                if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                    debug('read: emitReadable', state.length, state.ended);
                    if (state.length === 0 && state.ended)
                        endReadable(this);
                    else
                        emitReadable(this);
                    return null;
                }
                n = howMuchToRead(n, state);
                if (n === 0 && state.ended) {
                    if (state.length === 0)
                        endReadable(this);
                    return null;
                }
                var doRead = state.needReadable;
                debug('need readable', doRead);
                if (state.length === 0 || state.length - n < state.highWaterMark) {
                    doRead = true;
                    debug('length less than watermark', doRead);
                }
                if (state.ended || state.reading) {
                    doRead = false;
                    debug('reading or ended', doRead);
                }
                if (doRead) {
                    debug('do read');
                    state.reading = true;
                    state.sync = true;
                    if (state.length === 0)
                        state.needReadable = true;
                    this._read(state.highWaterMark);
                    state.sync = false;
                }
                if (doRead && !state.reading)
                    n = howMuchToRead(nOrig, state);
                var ret;
                if (n > 0)
                    ret = fromList(n, state);
                else
                    ret = null;
                if (util.isNull(ret)) {
                    state.needReadable = true;
                    n = 0;
                }
                state.length -= n;
                if (state.length === 0 && !state.ended)
                    state.needReadable = true;
                if (nOrig !== n && state.ended && state.length === 0)
                    endReadable(this);
                if (!util.isNull(ret))
                    this.emit('data', ret);
                return ret;
            };
            function chunkInvalid(state, chunk) {
                var er = null;
                if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
                    er = new TypeError('Invalid non-string/buffer chunk');
                }
                return er;
            }
            function onEofChunk(stream, state) {
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                        state.buffer.push(chunk);
                        state.length += state.objectMode ? 1 : chunk.length;
                    }
                }
                state.ended = true;
                emitReadable(stream);
            }
            function emitReadable(stream) {
                var state = stream._readableState;
                state.needReadable = false;
                if (!state.emittedReadable) {
                    debug('emitReadable', state.flowing);
                    state.emittedReadable = true;
                    if (state.sync)
                        process.nextTick(function () {
                            emitReadable_(stream);
                        });
                    else
                        emitReadable_(stream);
                }
            }
            function emitReadable_(stream) {
                debug('emit readable');
                stream.emit('readable');
                flow(stream);
            }
            function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                    state.readingMore = true;
                    process.nextTick(function () {
                        maybeReadMore_(stream, state);
                    });
                }
            }
            function maybeReadMore_(stream, state) {
                var len = state.length;
                while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                    debug('maybeReadMore read 0');
                    stream.read(0);
                    if (len === state.length)
                        break;
                    else
                        len = state.length;
                }
                state.readingMore = false;
            }
            Readable.prototype._read = function (n) {
                this.emit('error', new Error('not implemented'));
            };
            Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                case 0:
                    state.pipes = dest;
                    break;
                case 1:
                    state.pipes = [
                        state.pipes,
                        dest
                    ];
                    break;
                default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                var endFn = doEnd ? onend : cleanup;
                if (state.endEmitted)
                    process.nextTick(endFn);
                else
                    src.once('end', endFn);
                dest.on('unpipe', onunpipe);
                function onunpipe(readable) {
                    debug('onunpipe');
                    if (readable === src) {
                        cleanup();
                    }
                }
                function onend() {
                    debug('onend');
                    dest.end();
                }
                var ondrain = pipeOnDrain(src);
                dest.on('drain', ondrain);
                function cleanup() {
                    debug('cleanup');
                    dest.removeListener('close', onclose);
                    dest.removeListener('finish', onfinish);
                    dest.removeListener('drain', ondrain);
                    dest.removeListener('error', onerror);
                    dest.removeListener('unpipe', onunpipe);
                    src.removeListener('end', onend);
                    src.removeListener('end', cleanup);
                    src.removeListener('data', ondata);
                    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                        ondrain();
                }
                src.on('data', ondata);
                function ondata(chunk) {
                    debug('ondata');
                    var ret = dest.write(chunk);
                    if (false === ret) {
                        debug('false write response, pause', src._readableState.awaitDrain);
                        src._readableState.awaitDrain++;
                        src.pause();
                    }
                }
                function onerror(er) {
                    debug('onerror', er);
                    unpipe();
                    dest.removeListener('error', onerror);
                    if (EE.listenerCount(dest, 'error') === 0)
                        dest.emit('error', er);
                }
                if (!dest._events || !dest._events.error)
                    dest.on('error', onerror);
                else if (isArray(dest._events.error))
                    dest._events.error.unshift(onerror);
                else
                    dest._events.error = [
                        onerror,
                        dest._events.error
                    ];
                function onclose() {
                    dest.removeListener('finish', onfinish);
                    unpipe();
                }
                dest.once('close', onclose);
                function onfinish() {
                    debug('onfinish');
                    dest.removeListener('close', onclose);
                    unpipe();
                }
                dest.once('finish', onfinish);
                function unpipe() {
                    debug('unpipe');
                    src.unpipe(dest);
                }
                dest.emit('pipe', src);
                if (!state.flowing) {
                    debug('pipe resume');
                    src.resume();
                }
                return dest;
            };
            function pipeOnDrain(src) {
                return function () {
                    var state = src._readableState;
                    debug('pipeOnDrain', state.awaitDrain);
                    if (state.awaitDrain)
                        state.awaitDrain--;
                    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
                        state.flowing = true;
                        flow(src);
                    }
                };
            }
            Readable.prototype.unpipe = function (dest) {
                var state = this._readableState;
                if (state.pipesCount === 0)
                    return this;
                if (state.pipesCount === 1) {
                    if (dest && dest !== state.pipes)
                        return this;
                    if (!dest)
                        dest = state.pipes;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    if (dest)
                        dest.emit('unpipe', this);
                    return this;
                }
                if (!dest) {
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    for (var i = 0; i < len; i++)
                        dests[i].emit('unpipe', this);
                    return this;
                }
                var i = indexOf(state.pipes, dest);
                if (i === -1)
                    return this;
                state.pipes.splice(i, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1)
                    state.pipes = state.pipes[0];
                dest.emit('unpipe', this);
                return this;
            };
            Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                if (ev === 'data' && false !== this._readableState.flowing) {
                    this.resume();
                }
                if (ev === 'readable' && this.readable) {
                    var state = this._readableState;
                    if (!state.readableListening) {
                        state.readableListening = true;
                        state.emittedReadable = false;
                        state.needReadable = true;
                        if (!state.reading) {
                            var self = this;
                            process.nextTick(function () {
                                debug('readable nexttick read 0');
                                self.read(0);
                            });
                        } else if (state.length) {
                            emitReadable(this, state);
                        }
                    }
                }
                return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.resume = function () {
                var state = this._readableState;
                if (!state.flowing) {
                    debug('resume');
                    state.flowing = true;
                    if (!state.reading) {
                        debug('resume read 0');
                        this.read(0);
                    }
                    resume(this, state);
                }
                return this;
            };
            function resume(stream, state) {
                if (!state.resumeScheduled) {
                    state.resumeScheduled = true;
                    process.nextTick(function () {
                        resume_(stream, state);
                    });
                }
            }
            function resume_(stream, state) {
                state.resumeScheduled = false;
                stream.emit('resume');
                flow(stream);
                if (state.flowing && !state.reading)
                    stream.read(0);
            }
            Readable.prototype.pause = function () {
                debug('call pause flowing=%j', this._readableState.flowing);
                if (false !== this._readableState.flowing) {
                    debug('pause');
                    this._readableState.flowing = false;
                    this.emit('pause');
                }
                return this;
            };
            function flow(stream) {
                var state = stream._readableState;
                debug('flow', state.flowing);
                if (state.flowing) {
                    do {
                        var chunk = stream.read();
                    } while (null !== chunk && state.flowing);
                }
            }
            Readable.prototype.wrap = function (stream) {
                var state = this._readableState;
                var paused = false;
                var self = this;
                stream.on('end', function () {
                    debug('wrapped end');
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length)
                            self.push(chunk);
                    }
                    self.push(null);
                });
                stream.on('data', function (chunk) {
                    debug('wrapped data');
                    if (state.decoder)
                        chunk = state.decoder.write(chunk);
                    if (!chunk || !state.objectMode && !chunk.length)
                        return;
                    var ret = self.push(chunk);
                    if (!ret) {
                        paused = true;
                        stream.pause();
                    }
                });
                for (var i in stream) {
                    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
                        this[i] = function (method) {
                            return function () {
                                return stream[method].apply(stream, arguments);
                            };
                        }(i);
                    }
                }
                var events = [
                    'error',
                    'close',
                    'destroy',
                    'pause',
                    'resume'
                ];
                forEach(events, function (ev) {
                    stream.on(ev, self.emit.bind(self, ev));
                });
                self._read = function (n) {
                    debug('wrapped _read', n);
                    if (paused) {
                        paused = false;
                        stream.resume();
                    }
                };
                return self;
            };
            Readable._fromList = fromList;
            function fromList(n, state) {
                var list = state.buffer;
                var length = state.length;
                var stringMode = !!state.decoder;
                var objectMode = !!state.objectMode;
                var ret;
                if (list.length === 0)
                    return null;
                if (length === 0)
                    ret = null;
                else if (objectMode)
                    ret = list.shift();
                else if (!n || n >= length) {
                    if (stringMode)
                        ret = list.join('');
                    else
                        ret = Buffer.concat(list, length);
                    list.length = 0;
                } else {
                    if (n < list[0].length) {
                        var buf = list[0];
                        ret = buf.slice(0, n);
                        list[0] = buf.slice(n);
                    } else if (n === list[0].length) {
                        ret = list.shift();
                    } else {
                        if (stringMode)
                            ret = '';
                        else
                            ret = new Buffer(n);
                        var c = 0;
                        for (var i = 0, l = list.length; i < l && c < n; i++) {
                            var buf = list[0];
                            var cpy = Math.min(n - c, buf.length);
                            if (stringMode)
                                ret += buf.slice(0, cpy);
                            else
                                buf.copy(ret, c, 0, cpy);
                            if (cpy < buf.length)
                                list[0] = buf.slice(cpy);
                            else
                                list.shift();
                            c += cpy;
                        }
                    }
                }
                return ret;
            }
            function endReadable(stream) {
                var state = stream._readableState;
                if (state.length > 0)
                    throw new Error('endReadable called on non-empty stream');
                if (!state.endEmitted) {
                    state.ended = true;
                    process.nextTick(function () {
                        if (!state.endEmitted && state.length === 0) {
                            state.endEmitted = true;
                            stream.readable = false;
                            stream.emit('end');
                        }
                    });
                }
            }
            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }
            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x)
                        return i;
                }
                return -1;
            }
        });
        _define(59, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                var base64VLQ = require(124);
                var util = require(125);
                var ArraySet = require(126).ArraySet;
                function SourceMapGenerator(aArgs) {
                    if (!aArgs) {
                        aArgs = {};
                    }
                    this._file = util.getArg(aArgs, 'file', null);
                    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
                    this._sources = new ArraySet();
                    this._names = new ArraySet();
                    this._mappings = [];
                    this._sourcesContents = null;
                }
                SourceMapGenerator.prototype._version = 3;
                SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
                    var sourceRoot = aSourceMapConsumer.sourceRoot;
                    var generator = new SourceMapGenerator({
                        file: aSourceMapConsumer.file,
                        sourceRoot: sourceRoot
                    });
                    aSourceMapConsumer.eachMapping(function (mapping) {
                        var newMapping = {
                            generated: {
                                line: mapping.generatedLine,
                                column: mapping.generatedColumn
                            }
                        };
                        if (mapping.source != null) {
                            newMapping.source = mapping.source;
                            if (sourceRoot != null) {
                                newMapping.source = util.relative(sourceRoot, newMapping.source);
                            }
                            newMapping.original = {
                                line: mapping.originalLine,
                                column: mapping.originalColumn
                            };
                            if (mapping.name != null) {
                                newMapping.name = mapping.name;
                            }
                        }
                        generator.addMapping(newMapping);
                    });
                    aSourceMapConsumer.sources.forEach(function (sourceFile) {
                        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                        if (content != null) {
                            generator.setSourceContent(sourceFile, content);
                        }
                    });
                    return generator;
                };
                SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
                    var generated = util.getArg(aArgs, 'generated');
                    var original = util.getArg(aArgs, 'original', null);
                    var source = util.getArg(aArgs, 'source', null);
                    var name = util.getArg(aArgs, 'name', null);
                    this._validateMapping(generated, original, source, name);
                    if (source != null && !this._sources.has(source)) {
                        this._sources.add(source);
                    }
                    if (name != null && !this._names.has(name)) {
                        this._names.add(name);
                    }
                    this._mappings.push({
                        generatedLine: generated.line,
                        generatedColumn: generated.column,
                        originalLine: original != null && original.line,
                        originalColumn: original != null && original.column,
                        source: source,
                        name: name
                    });
                };
                SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
                    var source = aSourceFile;
                    if (this._sourceRoot != null) {
                        source = util.relative(this._sourceRoot, source);
                    }
                    if (aSourceContent != null) {
                        if (!this._sourcesContents) {
                            this._sourcesContents = {};
                        }
                        this._sourcesContents[util.toSetString(source)] = aSourceContent;
                    } else if (this._sourcesContents) {
                        delete this._sourcesContents[util.toSetString(source)];
                        if (Object.keys(this._sourcesContents).length === 0) {
                            this._sourcesContents = null;
                        }
                    }
                };
                SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
                    var sourceFile = aSourceFile;
                    if (aSourceFile == null) {
                        if (aSourceMapConsumer.file == null) {
                            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
                        }
                        sourceFile = aSourceMapConsumer.file;
                    }
                    var sourceRoot = this._sourceRoot;
                    if (sourceRoot != null) {
                        sourceFile = util.relative(sourceRoot, sourceFile);
                    }
                    var newSources = new ArraySet();
                    var newNames = new ArraySet();
                    this._mappings.forEach(function (mapping) {
                        if (mapping.source === sourceFile && mapping.originalLine != null) {
                            var original = aSourceMapConsumer.originalPositionFor({
                                line: mapping.originalLine,
                                column: mapping.originalColumn
                            });
                            if (original.source != null) {
                                mapping.source = original.source;
                                if (aSourceMapPath != null) {
                                    mapping.source = util.join(aSourceMapPath, mapping.source);
                                }
                                if (sourceRoot != null) {
                                    mapping.source = util.relative(sourceRoot, mapping.source);
                                }
                                mapping.originalLine = original.line;
                                mapping.originalColumn = original.column;
                                if (original.name != null) {
                                    mapping.name = original.name;
                                }
                            }
                        }
                        var source = mapping.source;
                        if (source != null && !newSources.has(source)) {
                            newSources.add(source);
                        }
                        var name = mapping.name;
                        if (name != null && !newNames.has(name)) {
                            newNames.add(name);
                        }
                    }, this);
                    this._sources = newSources;
                    this._names = newNames;
                    aSourceMapConsumer.sources.forEach(function (sourceFile) {
                        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                        if (content != null) {
                            if (aSourceMapPath != null) {
                                sourceFile = util.join(aSourceMapPath, sourceFile);
                            }
                            if (sourceRoot != null) {
                                sourceFile = util.relative(sourceRoot, sourceFile);
                            }
                            this.setSourceContent(sourceFile, content);
                        }
                    }, this);
                };
                SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
                    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
                        return;
                    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
                        return;
                    } else {
                        throw new Error('Invalid mapping: ' + JSON.stringify({
                            generated: aGenerated,
                            source: aSource,
                            original: aOriginal,
                            name: aName
                        }));
                    }
                };
                SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
                    var previousGeneratedColumn = 0;
                    var previousGeneratedLine = 1;
                    var previousOriginalColumn = 0;
                    var previousOriginalLine = 0;
                    var previousName = 0;
                    var previousSource = 0;
                    var result = '';
                    var mapping;
                    this._mappings.sort(util.compareByGeneratedPositions);
                    for (var i = 0, len = this._mappings.length; i < len; i++) {
                        mapping = this._mappings[i];
                        if (mapping.generatedLine !== previousGeneratedLine) {
                            previousGeneratedColumn = 0;
                            while (mapping.generatedLine !== previousGeneratedLine) {
                                result += ';';
                                previousGeneratedLine++;
                            }
                        } else {
                            if (i > 0) {
                                if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
                                    continue;
                                }
                                result += ',';
                            }
                        }
                        result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
                        previousGeneratedColumn = mapping.generatedColumn;
                        if (mapping.source != null) {
                            result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);
                            previousSource = this._sources.indexOf(mapping.source);
                            result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
                            previousOriginalLine = mapping.originalLine - 1;
                            result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
                            previousOriginalColumn = mapping.originalColumn;
                            if (mapping.name != null) {
                                result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);
                                previousName = this._names.indexOf(mapping.name);
                            }
                        }
                    }
                    return result;
                };
                SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
                    return aSources.map(function (source) {
                        if (!this._sourcesContents) {
                            return null;
                        }
                        if (aSourceRoot != null) {
                            source = util.relative(aSourceRoot, source);
                        }
                        var key = util.toSetString(source);
                        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
                    }, this);
                };
                SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
                    var map = {
                        version: this._version,
                        sources: this._sources.toArray(),
                        names: this._names.toArray(),
                        mappings: this._serializeMappings()
                    };
                    if (this._file != null) {
                        map.file = this._file;
                    }
                    if (this._sourceRoot != null) {
                        map.sourceRoot = this._sourceRoot;
                    }
                    if (this._sourcesContents) {
                        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
                    }
                    return map;
                };
                SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
                    return JSON.stringify(this);
                };
                exports.SourceMapGenerator = SourceMapGenerator;
            });
        });
        _define(60, function (module, exports) {
            (function () {
                'use strict';
                var Regex, NON_ASCII_WHITESPACES;
                Regex = {
                    NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
                    NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
                };
                function isDecimalDigit(ch) {
                    return ch >= 48 && ch <= 57;
                }
                function isHexDigit(ch) {
                    return isDecimalDigit(ch) || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
                }
                function isOctalDigit(ch) {
                    return ch >= 48 && ch <= 55;
                }
                NON_ASCII_WHITESPACES = [
                    5760,
                    6158,
                    8192,
                    8193,
                    8194,
                    8195,
                    8196,
                    8197,
                    8198,
                    8199,
                    8200,
                    8201,
                    8202,
                    8239,
                    8287,
                    12288,
                    65279
                ];
                function isWhiteSpace(ch) {
                    return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
                }
                function isLineTerminator(ch) {
                    return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
                }
                function isIdentifierStart(ch) {
                    return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
                }
                function isIdentifierPart(ch) {
                    return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
                }
                module.exports = {
                    isDecimalDigit: isDecimalDigit,
                    isHexDigit: isHexDigit,
                    isOctalDigit: isOctalDigit,
                    isWhiteSpace: isWhiteSpace,
                    isLineTerminator: isLineTerminator,
                    isIdentifierStart: isIdentifierStart,
                    isIdentifierPart: isIdentifierPart
                };
            }());
        });
        _define(61, function (module, exports) {
            module.exports = Writable;
            var Buffer = require('buffer').Buffer;
            Writable.WritableState = WritableState;
            var util = require(122);
            util.inherits = require(121);
            var Stream = require('stream');
            util.inherits(Writable, Stream);
            function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
            }
            function WritableState(options, stream) {
                var Duplex = require(64);
                options = options || {};
                var hwm = options.highWaterMark;
                var defaultHwm = options.objectMode ? 16 : 16 * 1024;
                this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
                this.objectMode = !!options.objectMode;
                if (stream instanceof Duplex)
                    this.objectMode = this.objectMode || !!options.writableObjectMode;
                this.highWaterMark = ~~this.highWaterMark;
                this.needDrain = false;
                this.ending = false;
                this.ended = false;
                this.finished = false;
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;
                this.defaultEncoding = options.defaultEncoding || 'utf8';
                this.length = 0;
                this.writing = false;
                this.corked = 0;
                this.sync = true;
                this.bufferProcessing = false;
                this.onwrite = function (er) {
                    onwrite(stream, er);
                };
                this.writecb = null;
                this.writelen = 0;
                this.buffer = [];
                this.pendingcb = 0;
                this.prefinished = false;
                this.errorEmitted = false;
            }
            function Writable(options) {
                var Duplex = require(64);
                if (!(this instanceof Writable) && !(this instanceof Duplex))
                    return new Writable(options);
                this._writableState = new WritableState(options, this);
                this.writable = true;
                Stream.call(this);
            }
            Writable.prototype.pipe = function () {
                this.emit('error', new Error('Cannot pipe. Not readable.'));
            };
            function writeAfterEnd(stream, state, cb) {
                var er = new Error('write after end');
                stream.emit('error', er);
                process.nextTick(function () {
                    cb(er);
                });
            }
            function validChunk(stream, state, chunk, cb) {
                var valid = true;
                if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
                    var er = new TypeError('Invalid non-string/buffer chunk');
                    stream.emit('error', er);
                    process.nextTick(function () {
                        cb(er);
                    });
                    valid = false;
                }
                return valid;
            }
            Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                if (util.isFunction(encoding)) {
                    cb = encoding;
                    encoding = null;
                }
                if (util.isBuffer(chunk))
                    encoding = 'buffer';
                else if (!encoding)
                    encoding = state.defaultEncoding;
                if (!util.isFunction(cb))
                    cb = function () {
                    };
                if (state.ended)
                    writeAfterEnd(this, state, cb);
                else if (validChunk(this, state, chunk, cb)) {
                    state.pendingcb++;
                    ret = writeOrBuffer(this, state, chunk, encoding, cb);
                }
                return ret;
            };
            Writable.prototype.cork = function () {
                var state = this._writableState;
                state.corked++;
            };
            Writable.prototype.uncork = function () {
                var state = this._writableState;
                if (state.corked) {
                    state.corked--;
                    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
                        clearBuffer(this, state);
                }
            };
            function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
                    chunk = new Buffer(chunk, encoding);
                }
                return chunk;
            }
            function writeOrBuffer(stream, state, chunk, encoding, cb) {
                chunk = decodeChunk(state, chunk, encoding);
                if (util.isBuffer(chunk))
                    encoding = 'buffer';
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark;
                if (!ret)
                    state.needDrain = true;
                if (state.writing || state.corked)
                    state.buffer.push(new WriteReq(chunk, encoding, cb));
                else
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (writev)
                    stream._writev(chunk, state.onwrite);
                else
                    stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
                if (sync)
                    process.nextTick(function () {
                        state.pendingcb--;
                        cb(er);
                    });
                else {
                    state.pendingcb--;
                    cb(er);
                }
                stream._writableState.errorEmitted = true;
                stream.emit('error', er);
            }
            function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
            }
            function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;
                onwriteStateUpdate(state);
                if (er)
                    onwriteError(stream, state, sync, er, cb);
                else {
                    var finished = needFinish(stream, state);
                    if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
                        clearBuffer(stream, state);
                    }
                    if (sync) {
                        process.nextTick(function () {
                            afterWrite(stream, state, finished, cb);
                        });
                    } else {
                        afterWrite(stream, state, finished, cb);
                    }
                }
            }
            function afterWrite(stream, state, finished, cb) {
                if (!finished)
                    onwriteDrain(stream, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit('drain');
                }
            }
            function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                if (stream._writev && state.buffer.length > 1) {
                    var cbs = [];
                    for (var c = 0; c < state.buffer.length; c++)
                        cbs.push(state.buffer[c].callback);
                    state.pendingcb++;
                    doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
                        for (var i = 0; i < cbs.length; i++) {
                            state.pendingcb--;
                            cbs[i](err);
                        }
                    });
                    state.buffer = [];
                } else {
                    for (var c = 0; c < state.buffer.length; c++) {
                        var entry = state.buffer[c];
                        var chunk = entry.chunk;
                        var encoding = entry.encoding;
                        var cb = entry.callback;
                        var len = state.objectMode ? 1 : chunk.length;
                        doWrite(stream, state, false, len, chunk, encoding, cb);
                        if (state.writing) {
                            c++;
                            break;
                        }
                    }
                    if (c < state.buffer.length)
                        state.buffer = state.buffer.slice(c);
                    else
                        state.buffer.length = 0;
                }
                state.bufferProcessing = false;
            }
            Writable.prototype._write = function (chunk, encoding, cb) {
                cb(new Error('not implemented'));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState;
                if (util.isFunction(chunk)) {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                } else if (util.isFunction(encoding)) {
                    cb = encoding;
                    encoding = null;
                }
                if (!util.isNullOrUndefined(chunk))
                    this.write(chunk, encoding);
                if (state.corked) {
                    state.corked = 1;
                    this.uncork();
                }
                if (!state.ending && !state.finished)
                    endWritable(this, state, cb);
            };
            function needFinish(stream, state) {
                return state.ending && state.length === 0 && !state.finished && !state.writing;
            }
            function prefinish(stream, state) {
                if (!state.prefinished) {
                    state.prefinished = true;
                    stream.emit('prefinish');
                }
            }
            function finishMaybe(stream, state) {
                var need = needFinish(stream, state);
                if (need) {
                    if (state.pendingcb === 0) {
                        prefinish(stream, state);
                        state.finished = true;
                        stream.emit('finish');
                    } else
                        prefinish(stream, state);
                }
                return need;
            }
            function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                    if (state.finished)
                        process.nextTick(cb);
                    else
                        stream.once('finish', cb);
                }
                state.ended = true;
            }
        });
        _define(62, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                var util = require(125);
                var binarySearch = require(128);
                var ArraySet = require(126).ArraySet;
                var base64VLQ = require(124);
                function SourceMapConsumer(aSourceMap) {
                    var sourceMap = aSourceMap;
                    if (typeof aSourceMap === 'string') {
                        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
                    }
                    var version = util.getArg(sourceMap, 'version');
                    var sources = util.getArg(sourceMap, 'sources');
                    var names = util.getArg(sourceMap, 'names', []);
                    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
                    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
                    var mappings = util.getArg(sourceMap, 'mappings');
                    var file = util.getArg(sourceMap, 'file', null);
                    if (version != this._version) {
                        throw new Error('Unsupported version: ' + version);
                    }
                    this._names = ArraySet.fromArray(names, true);
                    this._sources = ArraySet.fromArray(sources, true);
                    this.sourceRoot = sourceRoot;
                    this.sourcesContent = sourcesContent;
                    this._mappings = mappings;
                    this.file = file;
                }
                SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
                    var smc = Object.create(SourceMapConsumer.prototype);
                    smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
                    smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
                    smc.sourceRoot = aSourceMap._sourceRoot;
                    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
                    smc.file = aSourceMap._file;
                    smc.__generatedMappings = aSourceMap._mappings.slice().sort(util.compareByGeneratedPositions);
                    smc.__originalMappings = aSourceMap._mappings.slice().sort(util.compareByOriginalPositions);
                    return smc;
                };
                SourceMapConsumer.prototype._version = 3;
                Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
                    get: function () {
                        return this._sources.toArray().map(function (s) {
                            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
                        }, this);
                    }
                });
                SourceMapConsumer.prototype.__generatedMappings = null;
                Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
                    get: function () {
                        if (!this.__generatedMappings) {
                            this.__generatedMappings = [];
                            this.__originalMappings = [];
                            this._parseMappings(this._mappings, this.sourceRoot);
                        }
                        return this.__generatedMappings;
                    }
                });
                SourceMapConsumer.prototype.__originalMappings = null;
                Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
                    get: function () {
                        if (!this.__originalMappings) {
                            this.__generatedMappings = [];
                            this.__originalMappings = [];
                            this._parseMappings(this._mappings, this.sourceRoot);
                        }
                        return this.__originalMappings;
                    }
                });
                SourceMapConsumer.prototype._nextCharIsMappingSeparator = function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
                    var c = aStr.charAt(0);
                    return c === ';' || c === ',';
                };
                SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
                    var generatedLine = 1;
                    var previousGeneratedColumn = 0;
                    var previousOriginalLine = 0;
                    var previousOriginalColumn = 0;
                    var previousSource = 0;
                    var previousName = 0;
                    var str = aStr;
                    var temp = {};
                    var mapping;
                    while (str.length > 0) {
                        if (str.charAt(0) === ';') {
                            generatedLine++;
                            str = str.slice(1);
                            previousGeneratedColumn = 0;
                        } else if (str.charAt(0) === ',') {
                            str = str.slice(1);
                        } else {
                            mapping = {};
                            mapping.generatedLine = generatedLine;
                            base64VLQ.decode(str, temp);
                            mapping.generatedColumn = previousGeneratedColumn + temp.value;
                            previousGeneratedColumn = mapping.generatedColumn;
                            str = temp.rest;
                            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
                                base64VLQ.decode(str, temp);
                                mapping.source = this._sources.at(previousSource + temp.value);
                                previousSource += temp.value;
                                str = temp.rest;
                                if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
                                    throw new Error('Found a source, but no line and column');
                                }
                                base64VLQ.decode(str, temp);
                                mapping.originalLine = previousOriginalLine + temp.value;
                                previousOriginalLine = mapping.originalLine;
                                mapping.originalLine += 1;
                                str = temp.rest;
                                if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
                                    throw new Error('Found a source and line, but no column');
                                }
                                base64VLQ.decode(str, temp);
                                mapping.originalColumn = previousOriginalColumn + temp.value;
                                previousOriginalColumn = mapping.originalColumn;
                                str = temp.rest;
                                if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
                                    base64VLQ.decode(str, temp);
                                    mapping.name = this._names.at(previousName + temp.value);
                                    previousName += temp.value;
                                    str = temp.rest;
                                }
                            }
                            this.__generatedMappings.push(mapping);
                            if (typeof mapping.originalLine === 'number') {
                                this.__originalMappings.push(mapping);
                            }
                        }
                    }
                    this.__generatedMappings.sort(util.compareByGeneratedPositions);
                    this.__originalMappings.sort(util.compareByOriginalPositions);
                };
                SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {
                    if (aNeedle[aLineName] <= 0) {
                        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
                    }
                    if (aNeedle[aColumnName] < 0) {
                        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
                    }
                    return binarySearch.search(aNeedle, aMappings, aComparator);
                };
                SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
                    var needle = {
                        generatedLine: util.getArg(aArgs, 'line'),
                        generatedColumn: util.getArg(aArgs, 'column')
                    };
                    var mapping = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositions);
                    if (mapping && mapping.generatedLine === needle.generatedLine) {
                        var source = util.getArg(mapping, 'source', null);
                        if (source != null && this.sourceRoot != null) {
                            source = util.join(this.sourceRoot, source);
                        }
                        return {
                            source: source,
                            line: util.getArg(mapping, 'originalLine', null),
                            column: util.getArg(mapping, 'originalColumn', null),
                            name: util.getArg(mapping, 'name', null)
                        };
                    }
                    return {
                        source: null,
                        line: null,
                        column: null,
                        name: null
                    };
                };
                SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {
                    if (!this.sourcesContent) {
                        return null;
                    }
                    if (this.sourceRoot != null) {
                        aSource = util.relative(this.sourceRoot, aSource);
                    }
                    if (this._sources.has(aSource)) {
                        return this.sourcesContent[this._sources.indexOf(aSource)];
                    }
                    var url;
                    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
                        var fileUriAbsPath = aSource.replace(/^file:\/\//, '');
                        if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
                            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
                        }
                        if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {
                            return this.sourcesContent[this._sources.indexOf('/' + aSource)];
                        }
                    }
                    throw new Error('"' + aSource + '" is not in the SourceMap.');
                };
                SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
                    var needle = {
                        source: util.getArg(aArgs, 'source'),
                        originalLine: util.getArg(aArgs, 'line'),
                        originalColumn: util.getArg(aArgs, 'column')
                    };
                    if (this.sourceRoot != null) {
                        needle.source = util.relative(this.sourceRoot, needle.source);
                    }
                    var mapping = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions);
                    if (mapping) {
                        return {
                            line: util.getArg(mapping, 'generatedLine', null),
                            column: util.getArg(mapping, 'generatedColumn', null)
                        };
                    }
                    return {
                        line: null,
                        column: null
                    };
                };
                SourceMapConsumer.GENERATED_ORDER = 1;
                SourceMapConsumer.ORIGINAL_ORDER = 2;
                SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
                    var context = aContext || null;
                    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
                    var mappings;
                    switch (order) {
                    case SourceMapConsumer.GENERATED_ORDER:
                        mappings = this._generatedMappings;
                        break;
                    case SourceMapConsumer.ORIGINAL_ORDER:
                        mappings = this._originalMappings;
                        break;
                    default:
                        throw new Error('Unknown order of iteration.');
                    }
                    var sourceRoot = this.sourceRoot;
                    mappings.map(function (mapping) {
                        var source = mapping.source;
                        if (source != null && sourceRoot != null) {
                            source = util.join(sourceRoot, source);
                        }
                        return {
                            source: source,
                            generatedLine: mapping.generatedLine,
                            generatedColumn: mapping.generatedColumn,
                            originalLine: mapping.originalLine,
                            originalColumn: mapping.originalColumn,
                            name: mapping.name
                        };
                    }).forEach(aCallback, context);
                };
                exports.SourceMapConsumer = SourceMapConsumer;
            });
        });
        _define(63, function (module, exports) {
            (function () {
                'use strict';
                var code = require(60);
                function isStrictModeReservedWordES6(id) {
                    switch (id) {
                    case 'implements':
                    case 'interface':
                    case 'package':
                    case 'private':
                    case 'protected':
                    case 'public':
                    case 'static':
                    case 'let':
                        return true;
                    default:
                        return false;
                    }
                }
                function isKeywordES5(id, strict) {
                    if (!strict && id === 'yield') {
                        return false;
                    }
                    return isKeywordES6(id, strict);
                }
                function isKeywordES6(id, strict) {
                    if (strict && isStrictModeReservedWordES6(id)) {
                        return true;
                    }
                    switch (id.length) {
                    case 2:
                        return id === 'if' || id === 'in' || id === 'do';
                    case 3:
                        return id === 'var' || id === 'for' || id === 'new' || id === 'try';
                    case 4:
                        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
                    case 5:
                        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
                    case 6:
                        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
                    case 7:
                        return id === 'default' || id === 'finally' || id === 'extends';
                    case 8:
                        return id === 'function' || id === 'continue' || id === 'debugger';
                    case 10:
                        return id === 'instanceof';
                    default:
                        return false;
                    }
                }
                function isReservedWordES5(id, strict) {
                    return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
                }
                function isReservedWordES6(id, strict) {
                    return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
                }
                function isRestrictedWord(id) {
                    return id === 'eval' || id === 'arguments';
                }
                function isIdentifierName(id) {
                    var i, iz, ch;
                    if (id.length === 0) {
                        return false;
                    }
                    ch = id.charCodeAt(0);
                    if (!code.isIdentifierStart(ch) || ch === 92) {
                        return false;
                    }
                    for (i = 1, iz = id.length; i < iz; ++i) {
                        ch = id.charCodeAt(i);
                        if (!code.isIdentifierPart(ch) || ch === 92) {
                            return false;
                        }
                    }
                    return true;
                }
                function isIdentifierES5(id, strict) {
                    return isIdentifierName(id) && !isReservedWordES5(id, strict);
                }
                function isIdentifierES6(id, strict) {
                    return isIdentifierName(id) && !isReservedWordES6(id, strict);
                }
                module.exports = {
                    isKeywordES5: isKeywordES5,
                    isKeywordES6: isKeywordES6,
                    isReservedWordES5: isReservedWordES5,
                    isReservedWordES6: isReservedWordES6,
                    isRestrictedWord: isRestrictedWord,
                    isIdentifierName: isIdentifierName,
                    isIdentifierES5: isIdentifierES5,
                    isIdentifierES6: isIdentifierES6
                };
            }());
        });
        _define(64, function (module, exports) {
            module.exports = Duplex;
            var objectKeys = Object.keys || function (obj) {
                var keys = [];
                for (var key in obj)
                    keys.push(key);
                return keys;
            };
            var util = require(122);
            util.inherits = require(121);
            var Readable = require(58);
            var Writable = require(61);
            util.inherits(Duplex, Readable);
            forEach(objectKeys(Writable.prototype), function (method) {
                if (!Duplex.prototype[method])
                    Duplex.prototype[method] = Writable.prototype[method];
            });
            function Duplex(options) {
                if (!(this instanceof Duplex))
                    return new Duplex(options);
                Readable.call(this, options);
                Writable.call(this, options);
                if (options && options.readable === false)
                    this.readable = false;
                if (options && options.writable === false)
                    this.writable = false;
                this.allowHalfOpen = true;
                if (options && options.allowHalfOpen === false)
                    this.allowHalfOpen = false;
                this.once('end', onend);
            }
            function onend() {
                if (this.allowHalfOpen || this._writableState.ended)
                    return;
                process.nextTick(this.end.bind(this));
            }
            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }
        });
        _define(65, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                var SourceMapGenerator = require(59).SourceMapGenerator;
                var util = require(125);
                var REGEX_NEWLINE = /(\r?\n)/;
                var REGEX_CHARACTER = /\r\n|[\s\S]/g;
                function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
                    this.children = [];
                    this.sourceContents = {};
                    this.line = aLine == null ? null : aLine;
                    this.column = aColumn == null ? null : aColumn;
                    this.source = aSource == null ? null : aSource;
                    this.name = aName == null ? null : aName;
                    if (aChunks != null)
                        this.add(aChunks);
                }
                SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
                    var node = new SourceNode();
                    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
                    var shiftNextLine = function () {
                        var lineContents = remainingLines.shift();
                        var newLine = remainingLines.shift() || '';
                        return lineContents + newLine;
                    };
                    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
                    var lastMapping = null;
                    aSourceMapConsumer.eachMapping(function (mapping) {
                        if (lastMapping !== null) {
                            if (lastGeneratedLine < mapping.generatedLine) {
                                var code = '';
                                addMappingWithCode(lastMapping, shiftNextLine());
                                lastGeneratedLine++;
                                lastGeneratedColumn = 0;
                            } else {
                                var nextLine = remainingLines[0];
                                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                                remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                                lastGeneratedColumn = mapping.generatedColumn;
                                addMappingWithCode(lastMapping, code);
                                lastMapping = mapping;
                                return;
                            }
                        }
                        while (lastGeneratedLine < mapping.generatedLine) {
                            node.add(shiftNextLine());
                            lastGeneratedLine++;
                        }
                        if (lastGeneratedColumn < mapping.generatedColumn) {
                            var nextLine = remainingLines[0];
                            node.add(nextLine.substr(0, mapping.generatedColumn));
                            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
                            lastGeneratedColumn = mapping.generatedColumn;
                        }
                        lastMapping = mapping;
                    }, this);
                    if (remainingLines.length > 0) {
                        if (lastMapping) {
                            addMappingWithCode(lastMapping, shiftNextLine());
                        }
                        node.add(remainingLines.join(''));
                    }
                    aSourceMapConsumer.sources.forEach(function (sourceFile) {
                        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                        if (content != null) {
                            if (aRelativePath != null) {
                                sourceFile = util.join(aRelativePath, sourceFile);
                            }
                            node.setSourceContent(sourceFile, content);
                        }
                    });
                    return node;
                    function addMappingWithCode(mapping, code) {
                        if (mapping === null || mapping.source === undefined) {
                            node.add(code);
                        } else {
                            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
                            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
                        }
                    }
                };
                SourceNode.prototype.add = function SourceNode_add(aChunk) {
                    if (Array.isArray(aChunk)) {
                        aChunk.forEach(function (chunk) {
                            this.add(chunk);
                        }, this);
                    } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {
                        if (aChunk) {
                            this.children.push(aChunk);
                        }
                    } else {
                        throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);
                    }
                    return this;
                };
                SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
                    if (Array.isArray(aChunk)) {
                        for (var i = aChunk.length - 1; i >= 0; i--) {
                            this.prepend(aChunk[i]);
                        }
                    } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {
                        this.children.unshift(aChunk);
                    } else {
                        throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);
                    }
                    return this;
                };
                SourceNode.prototype.walk = function SourceNode_walk(aFn) {
                    var chunk;
                    for (var i = 0, len = this.children.length; i < len; i++) {
                        chunk = this.children[i];
                        if (chunk instanceof SourceNode) {
                            chunk.walk(aFn);
                        } else {
                            if (chunk !== '') {
                                aFn(chunk, {
                                    source: this.source,
                                    line: this.line,
                                    column: this.column,
                                    name: this.name
                                });
                            }
                        }
                    }
                };
                SourceNode.prototype.join = function SourceNode_join(aSep) {
                    var newChildren;
                    var i;
                    var len = this.children.length;
                    if (len > 0) {
                        newChildren = [];
                        for (i = 0; i < len - 1; i++) {
                            newChildren.push(this.children[i]);
                            newChildren.push(aSep);
                        }
                        newChildren.push(this.children[i]);
                        this.children = newChildren;
                    }
                    return this;
                };
                SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
                    var lastChild = this.children[this.children.length - 1];
                    if (lastChild instanceof SourceNode) {
                        lastChild.replaceRight(aPattern, aReplacement);
                    } else if (typeof lastChild === 'string') {
                        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
                    } else {
                        this.children.push(''.replace(aPattern, aReplacement));
                    }
                    return this;
                };
                SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
                    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
                };
                SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
                    for (var i = 0, len = this.children.length; i < len; i++) {
                        if (this.children[i] instanceof SourceNode) {
                            this.children[i].walkSourceContents(aFn);
                        }
                    }
                    var sources = Object.keys(this.sourceContents);
                    for (var i = 0, len = sources.length; i < len; i++) {
                        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
                    }
                };
                SourceNode.prototype.toString = function SourceNode_toString() {
                    var str = '';
                    this.walk(function (chunk) {
                        str += chunk;
                    });
                    return str;
                };
                SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
                    var generated = {
                        code: '',
                        line: 1,
                        column: 0
                    };
                    var map = new SourceMapGenerator(aArgs);
                    var sourceMappingActive = false;
                    var lastOriginalSource = null;
                    var lastOriginalLine = null;
                    var lastOriginalColumn = null;
                    var lastOriginalName = null;
                    this.walk(function (chunk, original) {
                        generated.code += chunk;
                        if (original.source !== null && original.line !== null && original.column !== null) {
                            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                                map.addMapping({
                                    source: original.source,
                                    original: {
                                        line: original.line,
                                        column: original.column
                                    },
                                    generated: {
                                        line: generated.line,
                                        column: generated.column
                                    },
                                    name: original.name
                                });
                            }
                            lastOriginalSource = original.source;
                            lastOriginalLine = original.line;
                            lastOriginalColumn = original.column;
                            lastOriginalName = original.name;
                            sourceMappingActive = true;
                        } else if (sourceMappingActive) {
                            map.addMapping({
                                generated: {
                                    line: generated.line,
                                    column: generated.column
                                }
                            });
                            lastOriginalSource = null;
                            sourceMappingActive = false;
                        }
                        chunk.match(REGEX_CHARACTER).forEach(function (ch, idx, array) {
                            if (REGEX_NEWLINE.test(ch)) {
                                generated.line++;
                                generated.column = 0;
                                if (idx + 1 === array.length) {
                                    lastOriginalSource = null;
                                    sourceMappingActive = false;
                                } else if (sourceMappingActive) {
                                    map.addMapping({
                                        source: original.source,
                                        original: {
                                            line: original.line,
                                            column: original.column
                                        },
                                        generated: {
                                            line: generated.line,
                                            column: generated.column
                                        },
                                        name: original.name
                                    });
                                }
                            } else {
                                generated.column += ch.length;
                            }
                        });
                    });
                    this.walkSourceContents(function (sourceFile, sourceContent) {
                        map.setSourceContent(sourceFile, sourceContent);
                    });
                    return {
                        code: generated.code,
                        map: map
                    };
                };
                exports.SourceNode = SourceNode;
            });
        });
        _define(66, function (module, exports) {
            module.exports = Transform;
            var Duplex = require(64);
            var util = require(122);
            util.inherits = require(121);
            util.inherits(Transform, Duplex);
            function TransformState(options, stream) {
                this.afterTransform = function (er, data) {
                    return afterTransform(stream, er, data);
                };
                this.needTransform = false;
                this.transforming = false;
                this.writecb = null;
                this.writechunk = null;
            }
            function afterTransform(stream, er, data) {
                var ts = stream._transformState;
                ts.transforming = false;
                var cb = ts.writecb;
                if (!cb)
                    return stream.emit('error', new Error('no writecb in Transform class'));
                ts.writechunk = null;
                ts.writecb = null;
                if (!util.isNullOrUndefined(data))
                    stream.push(data);
                if (cb)
                    cb(er);
                var rs = stream._readableState;
                rs.reading = false;
                if (rs.needReadable || rs.length < rs.highWaterMark) {
                    stream._read(rs.highWaterMark);
                }
            }
            function Transform(options) {
                if (!(this instanceof Transform))
                    return new Transform(options);
                Duplex.call(this, options);
                this._transformState = new TransformState(options, this);
                var stream = this;
                this._readableState.needReadable = true;
                this._readableState.sync = false;
                this.once('prefinish', function () {
                    if (util.isFunction(this._flush))
                        this._flush(function (er) {
                            done(stream, er);
                        });
                    else
                        done(stream);
                });
            }
            Transform.prototype.push = function (chunk, encoding) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call(this, chunk, encoding);
            };
            Transform.prototype._transform = function (chunk, encoding, cb) {
                throw new Error('not implemented');
            };
            Transform.prototype._write = function (chunk, encoding, cb) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                        this._read(rs.highWaterMark);
                }
            };
            Transform.prototype._read = function (n) {
                var ts = this._transformState;
                if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                } else {
                    ts.needTransform = true;
                }
            };
            function done(stream, er) {
                if (er)
                    return stream.emit('error', er);
                var ws = stream._writableState;
                var ts = stream._transformState;
                if (ws.length)
                    throw new Error('calling transform done when ws.length != 0');
                if (ts.transforming)
                    throw new Error('calling transform done when still transforming');
                return stream.push(null);
            }
        });
        _define(67, function (module, exports) {
            module.exports = Duplex;
            var objectKeys = Object.keys || function (obj) {
                var keys = [];
                for (var key in obj)
                    keys.push(key);
                return keys;
            };
            var util = require(71);
            util.inherits = require(74);
            var Readable = require(129);
            var Writable = require(130);
            util.inherits(Duplex, Readable);
            forEach(objectKeys(Writable.prototype), function (method) {
                if (!Duplex.prototype[method])
                    Duplex.prototype[method] = Writable.prototype[method];
            });
            function Duplex(options) {
                if (!(this instanceof Duplex))
                    return new Duplex(options);
                Readable.call(this, options);
                Writable.call(this, options);
                if (options && options.readable === false)
                    this.readable = false;
                if (options && options.writable === false)
                    this.writable = false;
                this.allowHalfOpen = true;
                if (options && options.allowHalfOpen === false)
                    this.allowHalfOpen = false;
                this.once('end', onend);
            }
            function onend() {
                if (this.allowHalfOpen || this._writableState.ended)
                    return;
                process.nextTick(this.end.bind(this));
            }
            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }
        });
        _define(68, function (module, exports) {
            module.exports = PassThrough;
            var Transform = require(66);
            var util = require(122);
            util.inherits = require(121);
            util.inherits(PassThrough, Transform);
            function PassThrough(options) {
                if (!(this instanceof PassThrough))
                    return new PassThrough(options);
                Transform.call(this, options);
            }
            PassThrough.prototype._transform = function (chunk, encoding, cb) {
                cb(null, chunk);
            };
        });
        _define(69, function (module, exports) {
            'use strict';
            var es5 = require(131);
            var haveGetters = function () {
                try {
                    var o = {};
                    es5.defineProperty(o, 'f', {
                        get: function () {
                            return 3;
                        }
                    });
                    return o.f === 3;
                } catch (e) {
                    return false;
                }
            }();
            var canEvaluate = typeof navigator == 'undefined';
            var errorObj = { e: {} };
            function tryCatch1(fn, receiver, arg) {
                try {
                    return fn.call(receiver, arg);
                } catch (e) {
                    errorObj.e = e;
                    return errorObj;
                }
            }
            function tryCatch2(fn, receiver, arg, arg2) {
                try {
                    return fn.call(receiver, arg, arg2);
                } catch (e) {
                    errorObj.e = e;
                    return errorObj;
                }
            }
            function tryCatch3(fn, receiver, arg, arg2, arg3) {
                try {
                    return fn.call(receiver, arg, arg2, arg3);
                } catch (e) {
                    errorObj.e = e;
                    return errorObj;
                }
            }
            function tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {
                try {
                    return fn.call(receiver, arg, arg2, arg3, arg4);
                } catch (e) {
                    errorObj.e = e;
                    return errorObj;
                }
            }
            function tryCatchApply(fn, args, receiver) {
                try {
                    return fn.apply(receiver, args);
                } catch (e) {
                    errorObj.e = e;
                    return errorObj;
                }
            }
            var inherits = function (Child, Parent) {
                var hasProp = {}.hasOwnProperty;
                function T() {
                    this.constructor = Child;
                    this.constructor$ = Parent;
                    for (var propertyName in Parent.prototype) {
                        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== '$') {
                            this[propertyName + '$'] = Parent.prototype[propertyName];
                        }
                    }
                }
                T.prototype = Parent.prototype;
                Child.prototype = new T();
                return Child.prototype;
            };
            function asString(val) {
                return typeof val === 'string' ? val : '' + val;
            }
            function isPrimitive(val) {
                return val == null || val === true || val === false || typeof val === 'string' || typeof val === 'number';
            }
            function isObject(value) {
                return !isPrimitive(value);
            }
            function maybeWrapAsError(maybeError) {
                if (!isPrimitive(maybeError))
                    return maybeError;
                return new Error(asString(maybeError));
            }
            function withAppended(target, appendee) {
                var len = target.length;
                var ret = new Array(len + 1);
                var i;
                for (i = 0; i < len; ++i) {
                    ret[i] = target[i];
                }
                ret[i] = appendee;
                return ret;
            }
            function getDataPropertyOrDefault(obj, key, defaultValue) {
                if (es5.isES5) {
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null) {
                        return desc.get == null && desc.set == null ? desc.value : defaultValue;
                    }
                } else {
                    return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
                }
            }
            function notEnumerableProp(obj, name, value) {
                if (isPrimitive(obj))
                    return obj;
                var descriptor = {
                    value: value,
                    configurable: true,
                    enumerable: false,
                    writable: true
                };
                es5.defineProperty(obj, name, descriptor);
                return obj;
            }
            var wrapsPrimitiveReceiver = function () {
                return this !== 'string';
            }.call('string');
            function thrower(r) {
                throw r;
            }
            var inheritedDataKeys = function () {
                if (es5.isES5) {
                    return function (obj, opts) {
                        var ret = [];
                        var visitedKeys = Object.create(null);
                        var getKeys = Object(opts).includeHidden ? Object.getOwnPropertyNames : Object.keys;
                        while (obj != null) {
                            var keys;
                            try {
                                keys = getKeys(obj);
                            } catch (e) {
                                return ret;
                            }
                            for (var i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                if (visitedKeys[key])
                                    continue;
                                visitedKeys[key] = true;
                                var desc = Object.getOwnPropertyDescriptor(obj, key);
                                if (desc != null && desc.get == null && desc.set == null) {
                                    ret.push(key);
                                }
                            }
                            obj = es5.getPrototypeOf(obj);
                        }
                        return ret;
                    };
                } else {
                    return function (obj) {
                        var ret = [];
                        for (var key in obj) {
                            ret.push(key);
                        }
                        return ret;
                    };
                }
            }();
            function isClass(fn) {
                try {
                    if (typeof fn === 'function') {
                        var keys = es5.keys(fn.prototype);
                        return keys.length > 0 && !(keys.length === 1 && keys[0] === 'constructor');
                    }
                    return false;
                } catch (e) {
                    return false;
                }
            }
            function toFastProperties(obj) {
                function f() {
                }
                f.prototype = obj;
                return f;
                eval(obj);
            }
            var rident = /^[a-z$_][a-z$_0-9]*$/i;
            function isIdentifier(str) {
                return rident.test(str);
            }
            function filledRange(count, prefix, suffix) {
                var ret = new Array(count);
                for (var i = 0; i < count; ++i) {
                    ret[i] = prefix + i + suffix;
                }
                return ret;
            }
            var ret = {
                isClass: isClass,
                isIdentifier: isIdentifier,
                inheritedDataKeys: inheritedDataKeys,
                getDataPropertyOrDefault: getDataPropertyOrDefault,
                thrower: thrower,
                isArray: es5.isArray,
                haveGetters: haveGetters,
                notEnumerableProp: notEnumerableProp,
                isPrimitive: isPrimitive,
                isObject: isObject,
                canEvaluate: canEvaluate,
                errorObj: errorObj,
                tryCatch1: tryCatch1,
                tryCatch2: tryCatch2,
                tryCatch3: tryCatch3,
                tryCatch4: tryCatch4,
                tryCatchApply: tryCatchApply,
                inherits: inherits,
                withAppended: withAppended,
                asString: asString,
                maybeWrapAsError: maybeWrapAsError,
                wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
                toFastProperties: toFastProperties,
                filledRange: filledRange
            };
            module.exports = ret;
        });
        _define(70, function (module, exports) {
            module.exports = [
                'assert',
                'buffer_ieee754',
                'buffer',
                'child_process',
                'cluster',
                'console',
                'constants',
                'crypto',
                '_debugger',
                'dgram',
                'dns',
                'domain',
                'events',
                'freelist',
                'fs',
                'http',
                'https',
                '_linklist',
                'module',
                'net',
                'os',
                'path',
                'punycode',
                'querystring',
                'readline',
                'repl',
                'stream',
                'string_decoder',
                'sys',
                'timers',
                'tls',
                'tty',
                'url',
                'util',
                'vm',
                'zlib'
            ];
        });
        _define(71, function (module, exports) {
            function isArray(ar) {
                return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
                return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
                return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
                return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
                return typeof arg === 'number';
            }
            exports.isNumber = isNumber;
            function isString(arg) {
                return typeof arg === 'string';
            }
            exports.isString = isString;
            function isSymbol(arg) {
                return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
                return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
                return isObject(re) && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
                return isObject(d) && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;
            function isError(e) {
                return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
                return typeof arg === 'function';
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
                return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
            }
            exports.isPrimitive = isPrimitive;
            function isBuffer(arg) {
                return Buffer.isBuffer(arg);
            }
            exports.isBuffer = isBuffer;
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
        });
        _define(72, function (module, exports) {
            module.exports = function () {
                var origPrepareStackTrace = Error.prepareStackTrace;
                Error.prepareStackTrace = function (_, stack) {
                    return stack;
                };
                var stack = new Error().stack;
                Error.prepareStackTrace = origPrepareStackTrace;
                return stack[2].getFileName();
            };
        });
        _define(73, function (module, exports) {
            'use strict';
            var schedule = require(132);
            var Queue = require(133);
            var errorObj = require(69).errorObj;
            var tryCatch1 = require(69).tryCatch1;
            var _process = typeof process !== 'undefined' ? process : void 0;
            function Async() {
                this._isTickUsed = false;
                this._schedule = schedule;
                this._length = 0;
                this._lateBuffer = new Queue(16);
                this._functionBuffer = new Queue(65536);
                var self = this;
                this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {
                    self._consumeFunctionBuffer();
                };
            }
            Async.prototype.haveItemsQueued = function Async$haveItemsQueued() {
                return this._length > 0;
            };
            Async.prototype.invokeLater = function Async$invokeLater(fn, receiver, arg) {
                if (_process !== void 0 && _process.domain != null && !fn.domain) {
                    fn = _process.domain.bind(fn);
                }
                this._lateBuffer.push(fn, receiver, arg);
                this._queueTick();
            };
            Async.prototype.invoke = function Async$invoke(fn, receiver, arg) {
                if (_process !== void 0 && _process.domain != null && !fn.domain) {
                    fn = _process.domain.bind(fn);
                }
                var functionBuffer = this._functionBuffer;
                functionBuffer.push(fn, receiver, arg);
                this._length = functionBuffer.length();
                this._queueTick();
            };
            Async.prototype._consumeFunctionBuffer = function Async$_consumeFunctionBuffer() {
                var functionBuffer = this._functionBuffer;
                while (functionBuffer.length() > 0) {
                    var fn = functionBuffer.shift();
                    var receiver = functionBuffer.shift();
                    var arg = functionBuffer.shift();
                    fn.call(receiver, arg);
                }
                this._reset();
                this._consumeLateBuffer();
            };
            Async.prototype._consumeLateBuffer = function Async$_consumeLateBuffer() {
                var buffer = this._lateBuffer;
                while (buffer.length() > 0) {
                    var fn = buffer.shift();
                    var receiver = buffer.shift();
                    var arg = buffer.shift();
                    var res = tryCatch1(fn, receiver, arg);
                    if (res === errorObj) {
                        this._queueTick();
                        if (fn.domain != null) {
                            fn.domain.emit('error', res.e);
                        } else {
                            throw res.e;
                        }
                    }
                }
            };
            Async.prototype._queueTick = function Async$_queue() {
                if (!this._isTickUsed) {
                    this._schedule(this.consumeFunctionBuffer);
                    this._isTickUsed = true;
                }
            };
            Async.prototype._reset = function Async$_reset() {
                this._isTickUsed = false;
                this._length = 0;
            };
            module.exports = new Async();
        });
        _define(74, function (module, exports) {
            module.exports = require('util').inherits;
        });
        _define(75, function (module, exports) {
            var path = require('path');
            module.exports = function (start, opts) {
                var modules = opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ['node_modules'];
                var prefix = '/';
                if (/^([A-Za-z]:)/.test(start)) {
                    prefix = '';
                } else if (/^\\\\/.test(start)) {
                    prefix = '\\\\';
                }
                var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\/+/;
                start = path.resolve(start);
                var parts = start.split(splitRe);
                var dirs = [];
                for (var i = parts.length - 1; i >= 0; i--) {
                    if (modules.indexOf(parts[i]) !== -1)
                        continue;
                    dirs = dirs.concat(modules.map(function (module_dir) {
                        return prefix + path.join(path.join.apply(path, parts.slice(0, i + 1)), module_dir);
                    }));
                }
                if (process.platform === 'win32') {
                    dirs[dirs.length - 1] = dirs[dirs.length - 1].replace(':', ':\\');
                }
                return dirs.concat(opts.paths);
            };
        });
        _define(76, function (module, exports) {
            'use strict';
            var Objectfreeze = require(131).freeze;
            var util = require(69);
            var inherits = util.inherits;
            var notEnumerableProp = util.notEnumerableProp;
            function markAsOriginatingFromRejection(e) {
                try {
                    notEnumerableProp(e, 'isOperational', true);
                } catch (ignore) {
                }
            }
            function originatesFromRejection(e) {
                if (e == null)
                    return false;
                return e instanceof OperationalError || e['isOperational'] === true;
            }
            function isError(obj) {
                return obj instanceof Error;
            }
            function canAttach(obj) {
                return isError(obj);
            }
            function subError(nameProperty, defaultMessage) {
                function SubError(message) {
                    if (!(this instanceof SubError))
                        return new SubError(message);
                    this.message = typeof message === 'string' ? message : defaultMessage;
                    this.name = nameProperty;
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }
                }
                inherits(SubError, Error);
                return SubError;
            }
            var _TypeError, _RangeError;
            var CancellationError = subError('CancellationError', 'cancellation error');
            var TimeoutError = subError('TimeoutError', 'timeout error');
            var AggregateError = subError('AggregateError', 'aggregate error');
            try {
                _TypeError = TypeError;
                _RangeError = RangeError;
            } catch (e) {
                _TypeError = subError('TypeError', 'type error');
                _RangeError = subError('RangeError', 'range error');
            }
            var methods = ('join pop push shift unshift slice filter forEach some ' + 'every map indexOf lastIndexOf reduce reduceRight sort reverse').split(' ');
            for (var i = 0; i < methods.length; ++i) {
                if (typeof Array.prototype[methods[i]] === 'function') {
                    AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
                }
            }
            AggregateError.prototype.length = 0;
            AggregateError.prototype['isOperational'] = true;
            var level = 0;
            AggregateError.prototype.toString = function () {
                var indent = Array(level * 4 + 1).join(' ');
                var ret = '\n' + indent + 'AggregateError of:' + '\n';
                level++;
                indent = Array(level * 4 + 1).join(' ');
                for (var i = 0; i < this.length; ++i) {
                    var str = this[i] === this ? '[Circular AggregateError]' : this[i] + '';
                    var lines = str.split('\n');
                    for (var j = 0; j < lines.length; ++j) {
                        lines[j] = indent + lines[j];
                    }
                    str = lines.join('\n');
                    ret += str + '\n';
                }
                level--;
                return ret;
            };
            function OperationalError(message) {
                this.name = 'OperationalError';
                this.message = message;
                this.cause = message;
                this['isOperational'] = true;
                if (message instanceof Error) {
                    this.message = message.message;
                    this.stack = message.stack;
                } else if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, this.constructor);
                }
            }
            inherits(OperationalError, Error);
            var key = '__BluebirdErrorTypes__';
            var errorTypes = Error[key];
            if (!errorTypes) {
                errorTypes = Objectfreeze({
                    CancellationError: CancellationError,
                    TimeoutError: TimeoutError,
                    OperationalError: OperationalError,
                    RejectionError: OperationalError,
                    AggregateError: AggregateError
                });
                notEnumerableProp(Error, key, errorTypes);
            }
            module.exports = {
                Error: Error,
                TypeError: _TypeError,
                RangeError: _RangeError,
                CancellationError: errorTypes.CancellationError,
                OperationalError: errorTypes.OperationalError,
                TimeoutError: errorTypes.TimeoutError,
                AggregateError: errorTypes.AggregateError,
                originatesFromRejection: originatesFromRejection,
                markAsOriginatingFromRejection: markAsOriginatingFromRejection,
                canAttach: canAttach
            };
        });
        _define(77, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
                var util = require(69);
                var canAttach = require(76).canAttach;
                var errorObj = util.errorObj;
                var isObject = util.isObject;
                function getThen(obj) {
                    try {
                        return obj.then;
                    } catch (e) {
                        errorObj.e = e;
                        return errorObj;
                    }
                }
                function Promise$_Cast(obj, originalPromise) {
                    if (isObject(obj)) {
                        if (obj instanceof Promise) {
                            return obj;
                        } else if (isAnyBluebirdPromise(obj)) {
                            var ret = new Promise(INTERNAL);
                            ret._setTrace(void 0);
                            obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);
                            ret._setFollowing();
                            return ret;
                        }
                        var then = getThen(obj);
                        if (then === errorObj) {
                            if (originalPromise !== void 0 && canAttach(then.e)) {
                                originalPromise._attachExtraTrace(then.e);
                            }
                            return Promise.reject(then.e);
                        } else if (typeof then === 'function') {
                            return Promise$_doThenable(obj, then, originalPromise);
                        }
                    }
                    return obj;
                }
                var hasProp = {}.hasOwnProperty;
                function isAnyBluebirdPromise(obj) {
                    return hasProp.call(obj, '_promise0');
                }
                function Promise$_doThenable(x, then, originalPromise) {
                    var resolver = Promise.defer();
                    var called = false;
                    try {
                        then.call(x, Promise$_resolveFromThenable, Promise$_rejectFromThenable, Promise$_progressFromThenable);
                    } catch (e) {
                        if (!called) {
                            called = true;
                            var trace = canAttach(e) ? e : new Error(e + '');
                            if (originalPromise !== void 0) {
                                originalPromise._attachExtraTrace(trace);
                            }
                            resolver.promise._reject(e, trace);
                        }
                    }
                    return resolver.promise;
                    function Promise$_resolveFromThenable(y) {
                        if (called)
                            return;
                        called = true;
                        if (x === y) {
                            var e = Promise._makeSelfResolutionError();
                            if (originalPromise !== void 0) {
                                originalPromise._attachExtraTrace(e);
                            }
                            resolver.promise._reject(e, void 0);
                            return;
                        }
                        resolver.resolve(y);
                    }
                    function Promise$_rejectFromThenable(r) {
                        if (called)
                            return;
                        called = true;
                        var trace = canAttach(r) ? r : new Error(r + '');
                        if (originalPromise !== void 0) {
                            originalPromise._attachExtraTrace(trace);
                        }
                        resolver.promise._reject(r, trace);
                    }
                    function Promise$_progressFromThenable(v) {
                        if (called)
                            return;
                        var promise = resolver.promise;
                        if (typeof promise._progress === 'function') {
                            promise._progress(v);
                        }
                    }
                }
                return Promise$_Cast;
            };
        });
        _define(78, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL, cast) {
                var canAttach = require(76).canAttach;
                var util = require(69);
                var isArray = util.isArray;
                function toResolutionValue(val) {
                    switch (val) {
                    case -1:
                        return void 0;
                    case -2:
                        return [];
                    case -3:
                        return {};
                    }
                }
                function PromiseArray(values) {
                    var promise = this._promise = new Promise(INTERNAL);
                    var parent = void 0;
                    if (values instanceof Promise) {
                        parent = values;
                        promise._propagateFrom(parent, 1 | 4);
                    }
                    promise._setTrace(parent);
                    this._values = values;
                    this._length = 0;
                    this._totalResolved = 0;
                    this._init(void 0, -2);
                }
                PromiseArray.prototype.length = function PromiseArray$length() {
                    return this._length;
                };
                PromiseArray.prototype.promise = function PromiseArray$promise() {
                    return this._promise;
                };
                PromiseArray.prototype._init = function PromiseArray$_init(_, resolveValueIfEmpty) {
                    var values = cast(this._values, void 0);
                    if (values instanceof Promise) {
                        this._values = values;
                        values._setBoundTo(this._promise._boundTo);
                        if (values.isFulfilled()) {
                            values = values._settledValue;
                            if (!isArray(values)) {
                                var err = new Promise.TypeError('expecting an array, a promise or a thenable');
                                this.__hardReject__(err);
                                return;
                            }
                        } else if (values.isPending()) {
                            values._then(PromiseArray$_init, this._reject, void 0, this, resolveValueIfEmpty);
                            return;
                        } else {
                            values._unsetRejectionIsUnhandled();
                            this._reject(values._settledValue);
                            return;
                        }
                    } else if (!isArray(values)) {
                        var err = new Promise.TypeError('expecting an array, a promise or a thenable');
                        this.__hardReject__(err);
                        return;
                    }
                    if (values.length === 0) {
                        if (resolveValueIfEmpty === -5) {
                            this._resolveEmptyArray();
                        } else {
                            this._resolve(toResolutionValue(resolveValueIfEmpty));
                        }
                        return;
                    }
                    var len = this.getActualLength(values.length);
                    var newLen = len;
                    var newValues = this.shouldCopyValues() ? new Array(len) : this._values;
                    var isDirectScanNeeded = false;
                    for (var i = 0; i < len; ++i) {
                        var maybePromise = cast(values[i], void 0);
                        if (maybePromise instanceof Promise) {
                            if (maybePromise.isPending()) {
                                maybePromise._proxyPromiseArray(this, i);
                            } else {
                                maybePromise._unsetRejectionIsUnhandled();
                                isDirectScanNeeded = true;
                            }
                        } else {
                            isDirectScanNeeded = true;
                        }
                        newValues[i] = maybePromise;
                    }
                    this._values = newValues;
                    this._length = newLen;
                    if (isDirectScanNeeded) {
                        this._scanDirectValues(len);
                    }
                };
                PromiseArray.prototype._settlePromiseAt = function PromiseArray$_settlePromiseAt(index) {
                    var value = this._values[index];
                    if (!(value instanceof Promise)) {
                        this._promiseFulfilled(value, index);
                    } else if (value.isFulfilled()) {
                        this._promiseFulfilled(value._settledValue, index);
                    } else if (value.isRejected()) {
                        this._promiseRejected(value._settledValue, index);
                    }
                };
                PromiseArray.prototype._scanDirectValues = function PromiseArray$_scanDirectValues(len) {
                    for (var i = 0; i < len; ++i) {
                        if (this._isResolved()) {
                            break;
                        }
                        this._settlePromiseAt(i);
                    }
                };
                PromiseArray.prototype._isResolved = function PromiseArray$_isResolved() {
                    return this._values === null;
                };
                PromiseArray.prototype._resolve = function PromiseArray$_resolve(value) {
                    this._values = null;
                    this._promise._fulfill(value);
                };
                PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function PromiseArray$_reject(reason) {
                    this._values = null;
                    var trace = canAttach(reason) ? reason : new Error(reason + '');
                    this._promise._attachExtraTrace(trace);
                    this._promise._reject(reason, trace);
                };
                PromiseArray.prototype._promiseProgressed = function PromiseArray$_promiseProgressed(progressValue, index) {
                    if (this._isResolved())
                        return;
                    this._promise._progress({
                        index: index,
                        value: progressValue
                    });
                };
                PromiseArray.prototype._promiseFulfilled = function PromiseArray$_promiseFulfilled(value, index) {
                    if (this._isResolved())
                        return;
                    this._values[index] = value;
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= this._length) {
                        this._resolve(this._values);
                    }
                };
                PromiseArray.prototype._promiseRejected = function PromiseArray$_promiseRejected(reason, index) {
                    if (this._isResolved())
                        return;
                    this._totalResolved++;
                    this._reject(reason);
                };
                PromiseArray.prototype.shouldCopyValues = function PromiseArray$_shouldCopyValues() {
                    return true;
                };
                PromiseArray.prototype.getActualLength = function PromiseArray$getActualLength(len) {
                    return len;
                };
                return PromiseArray;
            };
        });
        _define(79, function (module, exports) {
            'use strict';
            module.exports = function () {
                var inherits = require(69).inherits;
                var defineProperty = require(131).defineProperty;
                var rignore = new RegExp('\\b(?:[a-zA-Z0-9.]+\\$_\\w+|' + 'tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|' + '\\w*PromiseArray\\.\\w*PromiseArray|' + 'setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|' + 'process._tickCallback|nextTick|Async\\$\\w+)\\b');
                var rtraceline = null;
                var formatStack = null;
                function formatNonError(obj) {
                    var str;
                    if (typeof obj === 'function') {
                        str = '[function ' + (obj.name || 'anonymous') + ']';
                    } else {
                        str = obj.toString();
                        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
                        if (ruselessToString.test(str)) {
                            try {
                                var newStr = JSON.stringify(obj);
                                str = newStr;
                            } catch (e) {
                            }
                        }
                        if (str.length === 0) {
                            str = '(empty array)';
                        }
                    }
                    return '(<' + snip(str) + '>, no stack trace)';
                }
                function snip(str) {
                    var maxChars = 41;
                    if (str.length < maxChars) {
                        return str;
                    }
                    return str.substr(0, maxChars - 3) + '...';
                }
                function CapturedTrace(ignoreUntil, isTopLevel) {
                    this.captureStackTrace(CapturedTrace, isTopLevel);
                }
                inherits(CapturedTrace, Error);
                CapturedTrace.prototype.captureStackTrace = function CapturedTrace$captureStackTrace(ignoreUntil, isTopLevel) {
                    captureStackTrace(this, ignoreUntil, isTopLevel);
                };
                CapturedTrace.possiblyUnhandledRejection = function CapturedTrace$PossiblyUnhandledRejection(reason) {
                    if (typeof console === 'object') {
                        var message;
                        if (typeof reason === 'object' || typeof reason === 'function') {
                            var stack = reason.stack;
                            message = 'Possibly unhandled ' + formatStack(stack, reason);
                        } else {
                            message = 'Possibly unhandled ' + String(reason);
                        }
                        if (typeof console.error === 'function' || typeof console.error === 'object') {
                            console.error(message);
                        } else if (typeof console.log === 'function' || typeof console.log === 'object') {
                            console.log(message);
                        }
                    }
                };
                CapturedTrace.combine = function CapturedTrace$Combine(current, prev) {
                    var currentLastIndex = current.length - 1;
                    var currentLastLine = current[currentLastIndex];
                    var commonRootMeetPoint = -1;
                    for (var i = prev.length - 1; i >= 0; --i) {
                        if (prev[i] === currentLastLine) {
                            commonRootMeetPoint = i;
                            break;
                        }
                    }
                    for (var i = commonRootMeetPoint; i >= 0; --i) {
                        var line = prev[i];
                        if (current[currentLastIndex] === line) {
                            current.pop();
                            currentLastIndex--;
                        } else {
                            break;
                        }
                    }
                    current.push('From previous event:');
                    var lines = current.concat(prev);
                    var ret = [];
                    for (var i = 0, len = lines.length; i < len; ++i) {
                        if (rignore.test(lines[i]) && rtraceline.test(lines[i]) || i > 0 && !rtraceline.test(lines[i]) && lines[i] !== 'From previous event:') {
                            continue;
                        }
                        ret.push(lines[i]);
                    }
                    return ret;
                };
                CapturedTrace.protectErrorMessageNewlines = function (stack) {
                    for (var i = 0; i < stack.length; ++i) {
                        if (rtraceline.test(stack[i])) {
                            break;
                        }
                    }
                    if (i <= 1)
                        return;
                    var errorMessageLines = [];
                    for (var j = 0; j < i; ++j) {
                        errorMessageLines.push(stack.shift());
                    }
                    stack.unshift(errorMessageLines.join('\x02\0\x01'));
                };
                CapturedTrace.isSupported = function CapturedTrace$IsSupported() {
                    return typeof captureStackTrace === 'function';
                };
                var captureStackTrace = function stackDetection() {
                    if (typeof Error.stackTraceLimit === 'number' && typeof Error.captureStackTrace === 'function') {
                        rtraceline = /^\s*at\s*/;
                        formatStack = function (stack, error) {
                            if (typeof stack === 'string')
                                return stack;
                            if (error.name !== void 0 && error.message !== void 0) {
                                return error.name + '. ' + error.message;
                            }
                            return formatNonError(error);
                        };
                        var captureStackTrace = Error.captureStackTrace;
                        return function CapturedTrace$_captureStackTrace(receiver, ignoreUntil) {
                            captureStackTrace(receiver, ignoreUntil);
                        };
                    }
                    var err = new Error();
                    if (typeof err.stack === 'string' && typeof ''.startsWith === 'function' && err.stack.startsWith('stackDetection@') && stackDetection.name === 'stackDetection') {
                        defineProperty(Error, 'stackTraceLimit', {
                            writable: true,
                            enumerable: false,
                            configurable: false,
                            value: 25
                        });
                        rtraceline = /@/;
                        var rline = /[@\n]/;
                        formatStack = function (stack, error) {
                            if (typeof stack === 'string') {
                                return error.name + '. ' + error.message + '\n' + stack;
                            }
                            if (error.name !== void 0 && error.message !== void 0) {
                                return error.name + '. ' + error.message;
                            }
                            return formatNonError(error);
                        };
                        return function captureStackTrace(o) {
                            var stack = new Error().stack;
                            var split = stack.split(rline);
                            var len = split.length;
                            var ret = '';
                            for (var i = 0; i < len; i += 2) {
                                ret += split[i];
                                ret += '@';
                                ret += split[i + 1];
                                ret += '\n';
                            }
                            o.stack = ret;
                        };
                    } else {
                        formatStack = function (stack, error) {
                            if (typeof stack === 'string')
                                return stack;
                            if ((typeof error === 'object' || typeof error === 'function') && error.name !== void 0 && error.message !== void 0) {
                                return error.name + '. ' + error.message;
                            }
                            return formatNonError(error);
                        };
                        return null;
                    }
                }();
                return CapturedTrace;
            };
        });
        _define(80, function (module, exports) {
            'use strict';
            module.exports = function (NEXT_FILTER) {
                var util = require(69);
                var errors = require(76);
                var tryCatch1 = util.tryCatch1;
                var errorObj = util.errorObj;
                var keys = require(131).keys;
                var TypeError = errors.TypeError;
                function CatchFilter(instances, callback, promise) {
                    this._instances = instances;
                    this._callback = callback;
                    this._promise = promise;
                }
                function CatchFilter$_safePredicate(predicate, e) {
                    var safeObject = {};
                    var retfilter = tryCatch1(predicate, safeObject, e);
                    if (retfilter === errorObj)
                        return retfilter;
                    var safeKeys = keys(safeObject);
                    if (safeKeys.length) {
                        errorObj.e = new TypeError('Catch filter must inherit from Error ' + 'or be a simple predicate function');
                        return errorObj;
                    }
                    return retfilter;
                }
                CatchFilter.prototype.doFilter = function CatchFilter$_doFilter(e) {
                    var cb = this._callback;
                    var promise = this._promise;
                    var boundTo = promise._boundTo;
                    for (var i = 0, len = this._instances.length; i < len; ++i) {
                        var item = this._instances[i];
                        var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;
                        if (itemIsErrorType && e instanceof item) {
                            var ret = tryCatch1(cb, boundTo, e);
                            if (ret === errorObj) {
                                NEXT_FILTER.e = ret.e;
                                return NEXT_FILTER;
                            }
                            return ret;
                        } else if (typeof item === 'function' && !itemIsErrorType) {
                            var shouldHandle = CatchFilter$_safePredicate(item, e);
                            if (shouldHandle === errorObj) {
                                var trace = errors.canAttach(errorObj.e) ? errorObj.e : new Error(errorObj.e + '');
                                this._promise._attachExtraTrace(trace);
                                e = errorObj.e;
                                break;
                            } else if (shouldHandle) {
                                var ret = tryCatch1(cb, boundTo, e);
                                if (ret === errorObj) {
                                    NEXT_FILTER.e = ret.e;
                                    return NEXT_FILTER;
                                }
                                return ret;
                            }
                        }
                    }
                    NEXT_FILTER.e = e;
                    return NEXT_FILTER;
                };
                return CatchFilter;
            };
        });
        _define(81, function (module, exports) {
            'use strict';
            var util = require(69);
            var maybeWrapAsError = util.maybeWrapAsError;
            var errors = require(76);
            var TimeoutError = errors.TimeoutError;
            var OperationalError = errors.OperationalError;
            var async = require(73);
            var haveGetters = util.haveGetters;
            var es5 = require(131);
            function isUntypedError(obj) {
                return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
            }
            function wrapAsOperationalError(obj) {
                var ret;
                if (isUntypedError(obj)) {
                    ret = new OperationalError(obj);
                } else {
                    ret = obj;
                }
                errors.markAsOriginatingFromRejection(ret);
                return ret;
            }
            function nodebackForPromise(promise) {
                function PromiseResolver$_callback(err, value) {
                    if (promise === null)
                        return;
                    if (err) {
                        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                        promise._attachExtraTrace(wrapped);
                        promise._reject(wrapped);
                    } else if (arguments.length > 2) {
                        var $_len = arguments.length;
                        var args = new Array($_len - 1);
                        for (var $_i = 1; $_i < $_len; ++$_i) {
                            args[$_i - 1] = arguments[$_i];
                        }
                        promise._fulfill(args);
                    } else {
                        promise._fulfill(value);
                    }
                    promise = null;
                }
                return PromiseResolver$_callback;
            }
            var PromiseResolver;
            if (!haveGetters) {
                PromiseResolver = function PromiseResolver(promise) {
                    this.promise = promise;
                    this.asCallback = nodebackForPromise(promise);
                    this.callback = this.asCallback;
                };
            } else {
                PromiseResolver = function PromiseResolver(promise) {
                    this.promise = promise;
                };
            }
            if (haveGetters) {
                var prop = {
                    get: function () {
                        return nodebackForPromise(this.promise);
                    }
                };
                es5.defineProperty(PromiseResolver.prototype, 'asCallback', prop);
                es5.defineProperty(PromiseResolver.prototype, 'callback', prop);
            }
            PromiseResolver._nodebackForPromise = nodebackForPromise;
            PromiseResolver.prototype.toString = function PromiseResolver$toString() {
                return '[object PromiseResolver]';
            };
            PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function PromiseResolver$resolve(value) {
                if (!(this instanceof PromiseResolver)) {
                    throw new TypeError('Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.');
                }
                var promise = this.promise;
                if (promise._tryFollow(value)) {
                    return;
                }
                async.invoke(promise._fulfill, promise, value);
            };
            PromiseResolver.prototype.reject = function PromiseResolver$reject(reason) {
                if (!(this instanceof PromiseResolver)) {
                    throw new TypeError('Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.');
                }
                var promise = this.promise;
                errors.markAsOriginatingFromRejection(reason);
                var trace = errors.canAttach(reason) ? reason : new Error(reason + '');
                promise._attachExtraTrace(trace);
                async.invoke(promise._reject, promise, reason);
                if (trace !== reason) {
                    async.invoke(this._setCarriedStackTrace, this, trace);
                }
            };
            PromiseResolver.prototype.progress = function PromiseResolver$progress(value) {
                if (!(this instanceof PromiseResolver)) {
                    throw new TypeError('Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.');
                }
                async.invoke(this.promise._progress, this.promise, value);
            };
            PromiseResolver.prototype.cancel = function PromiseResolver$cancel() {
                async.invoke(this.promise.cancel, this.promise, void 0);
            };
            PromiseResolver.prototype.timeout = function PromiseResolver$timeout() {
                this.reject(new TimeoutError('timeout'));
            };
            PromiseResolver.prototype.isResolved = function PromiseResolver$isResolved() {
                return this.promise.isResolved();
            };
            PromiseResolver.prototype.toJSON = function PromiseResolver$toJSON() {
                return this.promise.toJSON();
            };
            PromiseResolver.prototype._setCarriedStackTrace = function PromiseResolver$_setCarriedStackTrace(trace) {
                if (this.promise.isRejected()) {
                    this.promise._setCarriedStackTrace(trace);
                }
            };
            module.exports = PromiseResolver;
        });
        _define(82, function (module, exports) {
            'use strict';
            module.exports = function (Promise, NEXT_FILTER, cast) {
                var util = require(69);
                var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
                var isPrimitive = util.isPrimitive;
                var thrower = util.thrower;
                function returnThis() {
                    return this;
                }
                function throwThis() {
                    throw this;
                }
                function return$(r) {
                    return function Promise$_returner() {
                        return r;
                    };
                }
                function throw$(r) {
                    return function Promise$_thrower() {
                        throw r;
                    };
                }
                function promisedFinally(ret, reasonOrValue, isFulfilled) {
                    var then;
                    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
                        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
                    } else {
                        then = isFulfilled ? returnThis : throwThis;
                    }
                    return ret._then(then, thrower, void 0, reasonOrValue, void 0);
                }
                function finallyHandler(reasonOrValue) {
                    var promise = this.promise;
                    var handler = this.handler;
                    var ret = promise._isBound() ? handler.call(promise._boundTo) : handler();
                    if (ret !== void 0) {
                        var maybePromise = cast(ret, void 0);
                        if (maybePromise instanceof Promise) {
                            return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());
                        }
                    }
                    if (promise.isRejected()) {
                        NEXT_FILTER.e = reasonOrValue;
                        return NEXT_FILTER;
                    } else {
                        return reasonOrValue;
                    }
                }
                function tapHandler(value) {
                    var promise = this.promise;
                    var handler = this.handler;
                    var ret = promise._isBound() ? handler.call(promise._boundTo, value) : handler(value);
                    if (ret !== void 0) {
                        var maybePromise = cast(ret, void 0);
                        if (maybePromise instanceof Promise) {
                            return promisedFinally(maybePromise, value, true);
                        }
                    }
                    return value;
                }
                Promise.prototype._passThroughHandler = function Promise$_passThroughHandler(handler, isFinally) {
                    if (typeof handler !== 'function')
                        return this.then();
                    var promiseAndHandler = {
                        promise: this,
                        handler: handler
                    };
                    return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : void 0, void 0, promiseAndHandler, void 0);
                };
                Promise.prototype.lastly = Promise.prototype['finally'] = function Promise$finally(handler) {
                    return this._passThroughHandler(handler, true);
                };
                Promise.prototype.tap = function Promise$tap(handler) {
                    return this._passThroughHandler(handler, false);
                };
            };
        });
        _define(83, function (module, exports) {
            'use strict';
            var util = require(69);
            var isPrimitive = util.isPrimitive;
            var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
            module.exports = function (Promise) {
                var returner = function Promise$_returner() {
                    return this;
                };
                var thrower = function Promise$_thrower() {
                    throw this;
                };
                var wrapper = function Promise$_wrapper(value, action) {
                    if (action === 1) {
                        return function Promise$_thrower() {
                            throw value;
                        };
                    } else if (action === 2) {
                        return function Promise$_returner() {
                            return value;
                        };
                    }
                };
                Promise.prototype['return'] = Promise.prototype.thenReturn = function Promise$thenReturn(value) {
                    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
                        return this._then(wrapper(value, 2), void 0, void 0, void 0, void 0);
                    }
                    return this._then(returner, void 0, void 0, value, void 0);
                };
                Promise.prototype['throw'] = Promise.prototype.thenThrow = function Promise$thenThrow(reason) {
                    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
                        return this._then(wrapper(reason, 1), void 0, void 0, void 0, void 0);
                    }
                    return this._then(thrower, void 0, void 0, reason, void 0);
                };
            };
        });
        _define(84, function (module, exports) {
            'use strict';
            module.exports = function (Promise) {
                function PromiseInspection(promise) {
                    if (promise !== void 0) {
                        this._bitField = promise._bitField;
                        this._settledValue = promise.isResolved() ? promise._settledValue : void 0;
                    } else {
                        this._bitField = 0;
                        this._settledValue = void 0;
                    }
                }
                PromiseInspection.prototype.isFulfilled = Promise.prototype.isFulfilled = function Promise$isFulfilled() {
                    return (this._bitField & 268435456) > 0;
                };
                PromiseInspection.prototype.isRejected = Promise.prototype.isRejected = function Promise$isRejected() {
                    return (this._bitField & 134217728) > 0;
                };
                PromiseInspection.prototype.isPending = Promise.prototype.isPending = function Promise$isPending() {
                    return (this._bitField & 402653184) === 0;
                };
                PromiseInspection.prototype.value = Promise.prototype.value = function Promise$value() {
                    if (!this.isFulfilled()) {
                        throw new TypeError('cannot get fulfillment value of a non-fulfilled promise');
                    }
                    return this._settledValue;
                };
                PromiseInspection.prototype.error = PromiseInspection.prototype.reason = Promise.prototype.reason = function Promise$reason() {
                    if (!this.isRejected()) {
                        throw new TypeError('cannot get rejection reason of a non-rejected promise');
                    }
                    return this._settledValue;
                };
                PromiseInspection.prototype.isResolved = Promise.prototype.isResolved = function Promise$isResolved() {
                    return (this._bitField & 402653184) > 0;
                };
                Promise.PromiseInspection = PromiseInspection;
            };
        });
        _define(85, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, cast, INTERNAL) {
                var util = require(69);
                var canEvaluate = util.canEvaluate;
                var tryCatch1 = util.tryCatch1;
                var errorObj = util.errorObj;
                if (canEvaluate) {
                    var thenCallback = function (i) {
                        return new Function('value', 'holder', '                             \n            \'use strict\';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            '.replace(/Index/g, i));
                    };
                    var caller = function (count) {
                        var values = [];
                        for (var i = 1; i <= count; ++i)
                            values.push('holder.p' + i);
                        return new Function('holder', '                                      \n            \'use strict\';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            '.replace(/values/g, values.join(', ')));
                    };
                    var thenCallbacks = [];
                    var callers = [void 0];
                    for (var i = 1; i <= 5; ++i) {
                        thenCallbacks.push(thenCallback(i));
                        callers.push(caller(i));
                    }
                    var Holder = function (total, fn) {
                        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
                        this.fn = fn;
                        this.total = total;
                        this.now = 0;
                    };
                    Holder.prototype.callers = callers;
                    Holder.prototype.checkFulfillment = function (promise) {
                        var now = this.now;
                        now++;
                        var total = this.total;
                        if (now >= total) {
                            var handler = this.callers[total];
                            var ret = tryCatch1(handler, void 0, this);
                            if (ret === errorObj) {
                                promise._rejectUnchecked(ret.e);
                            } else if (!promise._tryFollow(ret)) {
                                promise._fulfillUnchecked(ret);
                            }
                        } else {
                            this.now = now;
                        }
                    };
                }
                function reject(reason) {
                    this._reject(reason);
                }
                Promise.join = function Promise$Join() {
                    var last = arguments.length - 1;
                    var fn;
                    if (last > 0 && typeof arguments[last] === 'function') {
                        fn = arguments[last];
                        if (last < 6 && canEvaluate) {
                            var ret = new Promise(INTERNAL);
                            ret._setTrace(void 0);
                            var holder = new Holder(last, fn);
                            var callbacks = thenCallbacks;
                            for (var i = 0; i < last; ++i) {
                                var maybePromise = cast(arguments[i], void 0);
                                if (maybePromise instanceof Promise) {
                                    if (maybePromise.isPending()) {
                                        maybePromise._then(callbacks[i], reject, void 0, ret, holder);
                                    } else if (maybePromise.isFulfilled()) {
                                        callbacks[i].call(ret, maybePromise._settledValue, holder);
                                    } else {
                                        ret._reject(maybePromise._settledValue);
                                        maybePromise._unsetRejectionIsUnhandled();
                                    }
                                } else {
                                    callbacks[i].call(ret, maybePromise, holder);
                                }
                            }
                            return ret;
                        }
                    }
                    var $_len = arguments.length;
                    var args = new Array($_len);
                    for (var $_i = 0; $_i < $_len; ++$_i) {
                        args[$_i] = arguments[$_i];
                    }
                    var ret = new PromiseArray(args).promise();
                    return fn !== void 0 ? ret.spread(fn) : ret;
                };
            };
        });
        _define(86, function (module, exports) {
            'use strict';
            var _setTimeout = function (fn, ms) {
                var len = arguments.length;
                var arg0 = arguments[2];
                var arg1 = arguments[3];
                var arg2 = len >= 5 ? arguments[4] : void 0;
                return setTimeout(function () {
                    fn(arg0, arg1, arg2);
                }, ms | 0);
            };
            module.exports = function (Promise, INTERNAL, cast) {
                var util = require(69);
                var errors = require(76);
                var apiRejection = require(119)(Promise);
                var TimeoutError = Promise.TimeoutError;
                var afterTimeout = function Promise$_afterTimeout(promise, message, ms) {
                    if (!promise.isPending())
                        return;
                    if (typeof message !== 'string') {
                        message = 'operation timed out after' + ' ' + ms + ' ms';
                    }
                    var err = new TimeoutError(message);
                    errors.markAsOriginatingFromRejection(err);
                    promise._attachExtraTrace(err);
                    promise._cancel(err);
                };
                var afterDelay = function Promise$_afterDelay(value, promise) {
                    promise._fulfill(value);
                };
                var delay = Promise.delay = function Promise$Delay(value, ms) {
                    if (ms === void 0) {
                        ms = value;
                        value = void 0;
                    }
                    ms = +ms;
                    var maybePromise = cast(value, void 0);
                    var promise = new Promise(INTERNAL);
                    if (maybePromise instanceof Promise) {
                        promise._propagateFrom(maybePromise, 7);
                        promise._follow(maybePromise);
                        return promise.then(function (value) {
                            return Promise.delay(value, ms);
                        });
                    } else {
                        promise._setTrace(void 0);
                        _setTimeout(afterDelay, ms, value, promise);
                    }
                    return promise;
                };
                Promise.prototype.delay = function Promise$delay(ms) {
                    return delay(this, ms);
                };
                function successClear(value) {
                    var handle = this;
                    if (handle instanceof Number)
                        handle = +handle;
                    clearTimeout(handle);
                    return value;
                }
                function failureClear(reason) {
                    var handle = this;
                    if (handle instanceof Number)
                        handle = +handle;
                    clearTimeout(handle);
                    throw reason;
                }
                Promise.prototype.timeout = function Promise$timeout(ms, message) {
                    ms = +ms;
                    var ret = new Promise(INTERNAL);
                    ret._propagateFrom(this, 7);
                    ret._follow(this);
                    var handle = _setTimeout(afterTimeout, ms, ret, message, ms);
                    return ret.cancellable()._then(successClear, failureClear, void 0, handle, void 0);
                };
            };
        });
        _define(87, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL, cast) {
                var apiRejection = require(119)(Promise);
                var isArray = require(69).isArray;
                var raceLater = function Promise$_raceLater(promise) {
                    return promise.then(function (array) {
                        return Promise$_Race(array, promise);
                    });
                };
                var hasOwn = {}.hasOwnProperty;
                function Promise$_Race(promises, parent) {
                    var maybePromise = cast(promises, void 0);
                    if (maybePromise instanceof Promise) {
                        return raceLater(maybePromise);
                    } else if (!isArray(promises)) {
                        return apiRejection('expecting an array, a promise or a thenable');
                    }
                    var ret = new Promise(INTERNAL);
                    if (parent !== void 0) {
                        ret._propagateFrom(parent, 7);
                    } else {
                        ret._setTrace(void 0);
                    }
                    var fulfill = ret._fulfill;
                    var reject = ret._reject;
                    for (var i = 0, len = promises.length; i < len; ++i) {
                        var val = promises[i];
                        if (val === void 0 && !hasOwn.call(promises, i)) {
                            continue;
                        }
                        Promise.cast(val)._then(fulfill, reject, void 0, ret, null);
                    }
                    return ret;
                }
                Promise.race = function Promise$Race(promises) {
                    return Promise$_Race(promises, void 0);
                };
                Promise.prototype.race = function Promise$race() {
                    return Promise$_Race(this, void 0);
                };
            };
        });
        _define(88, function (module, exports) {
            'use strict';
            var cr = Object.create;
            if (cr) {
                var callerCache = cr(null);
                var getterCache = cr(null);
                callerCache[' size'] = getterCache[' size'] = 0;
            }
            module.exports = function (Promise) {
                var util = require(69);
                var canEvaluate = util.canEvaluate;
                var isIdentifier = util.isIdentifier;
                function makeMethodCaller(methodName) {
                    return new Function('obj', '                                             \n        \'use strict\'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        '.replace(/methodName/g, methodName));
                }
                function makeGetter(propertyName) {
                    return new Function('obj', '                                             \n        \'use strict\';                                                        \n        return obj.propertyName;                                             \n        '.replace('propertyName', propertyName));
                }
                function getCompiled(name, compiler, cache) {
                    var ret = cache[name];
                    if (typeof ret !== 'function') {
                        if (!isIdentifier(name)) {
                            return null;
                        }
                        ret = compiler(name);
                        cache[name] = ret;
                        cache[' size']++;
                        if (cache[' size'] > 512) {
                            var keys = Object.keys(cache);
                            for (var i = 0; i < 256; ++i)
                                delete cache[keys[i]];
                            cache[' size'] = keys.length - 256;
                        }
                    }
                    return ret;
                }
                function getMethodCaller(name) {
                    return getCompiled(name, makeMethodCaller, callerCache);
                }
                function getGetter(name) {
                    return getCompiled(name, makeGetter, getterCache);
                }
                function caller(obj) {
                    return obj[this.pop()].apply(obj, this);
                }
                Promise.prototype.call = function Promise$call(methodName) {
                    var $_len = arguments.length;
                    var args = new Array($_len - 1);
                    for (var $_i = 1; $_i < $_len; ++$_i) {
                        args[$_i - 1] = arguments[$_i];
                    }
                    if (canEvaluate) {
                        var maybeCaller = getMethodCaller(methodName);
                        if (maybeCaller !== null) {
                            return this._then(maybeCaller, void 0, void 0, args, void 0);
                        }
                    }
                    args.push(methodName);
                    return this._then(caller, void 0, void 0, args, void 0);
                };
                function namedGetter(obj) {
                    return obj[this];
                }
                function indexedGetter(obj) {
                    return obj[this];
                }
                Promise.prototype.get = function Promise$get(propertyName) {
                    var isIndex = typeof propertyName === 'number';
                    var getter;
                    if (!isIndex) {
                        if (canEvaluate) {
                            var maybeGetter = getGetter(propertyName);
                            getter = maybeGetter !== null ? maybeGetter : namedGetter;
                        } else {
                            getter = namedGetter;
                        }
                    } else {
                        getter = indexedGetter;
                    }
                    return this._then(getter, void 0, void 0, propertyName, void 0);
                };
            };
        });
        _define(89, function (module, exports) {
            'use strict';
            function readDir(file, cb) {
                cb(null, file);
            }
            module.exports = readDir;
        });
        _define(90, function (module, exports) {
            'use strict';
            module.exports = function (Promise, apiRejection, INTERNAL, cast) {
                var errors = require(76);
                var TypeError = errors.TypeError;
                var deprecated = require(69).deprecated;
                var util = require(69);
                var errorObj = util.errorObj;
                var tryCatch1 = util.tryCatch1;
                var yieldHandlers = [];
                function promiseFromYieldHandler(value, yieldHandlers) {
                    var _errorObj = errorObj;
                    var _Promise = Promise;
                    var len = yieldHandlers.length;
                    for (var i = 0; i < len; ++i) {
                        var result = tryCatch1(yieldHandlers[i], void 0, value);
                        if (result === _errorObj) {
                            return _Promise.reject(_errorObj.e);
                        }
                        var maybePromise = cast(result, promiseFromYieldHandler);
                        if (maybePromise instanceof _Promise)
                            return maybePromise;
                    }
                    return null;
                }
                function PromiseSpawn(generatorFunction, receiver, yieldHandler) {
                    var promise = this._promise = new Promise(INTERNAL);
                    promise._setTrace(void 0);
                    this._generatorFunction = generatorFunction;
                    this._receiver = receiver;
                    this._generator = void 0;
                    this._yieldHandlers = typeof yieldHandler === 'function' ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
                }
                PromiseSpawn.prototype.promise = function PromiseSpawn$promise() {
                    return this._promise;
                };
                PromiseSpawn.prototype._run = function PromiseSpawn$_run() {
                    this._generator = this._generatorFunction.call(this._receiver);
                    this._receiver = this._generatorFunction = void 0;
                    this._next(void 0);
                };
                PromiseSpawn.prototype._continue = function PromiseSpawn$_continue(result) {
                    if (result === errorObj) {
                        this._generator = void 0;
                        var trace = errors.canAttach(result.e) ? result.e : new Error(result.e + '');
                        this._promise._attachExtraTrace(trace);
                        this._promise._reject(result.e, trace);
                        return;
                    }
                    var value = result.value;
                    if (result.done === true) {
                        this._generator = void 0;
                        if (!this._promise._tryFollow(value)) {
                            this._promise._fulfill(value);
                        }
                    } else {
                        var maybePromise = cast(value, void 0);
                        if (!(maybePromise instanceof Promise)) {
                            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers);
                            if (maybePromise === null) {
                                this._throw(new TypeError('A value was yielded that could not be treated as a promise'));
                                return;
                            }
                        }
                        maybePromise._then(this._next, this._throw, void 0, this, null);
                    }
                };
                PromiseSpawn.prototype._throw = function PromiseSpawn$_throw(reason) {
                    if (errors.canAttach(reason))
                        this._promise._attachExtraTrace(reason);
                    this._continue(tryCatch1(this._generator['throw'], this._generator, reason));
                };
                PromiseSpawn.prototype._next = function PromiseSpawn$_next(value) {
                    this._continue(tryCatch1(this._generator.next, this._generator, value));
                };
                Promise.coroutine = function Promise$Coroutine(generatorFunction, options) {
                    if (typeof generatorFunction !== 'function') {
                        throw new TypeError('generatorFunction must be a function');
                    }
                    var yieldHandler = Object(options).yieldHandler;
                    var PromiseSpawn$ = PromiseSpawn;
                    return function () {
                        var generator = generatorFunction.apply(this, arguments);
                        var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler);
                        spawn._generator = generator;
                        spawn._next(void 0);
                        return spawn.promise();
                    };
                };
                Promise.coroutine.addYieldHandler = function (fn) {
                    if (typeof fn !== 'function')
                        throw new TypeError('fn must be a function');
                    yieldHandlers.push(fn);
                };
                Promise.spawn = function Promise$Spawn(generatorFunction) {
                    deprecated('Promise.spawn is deprecated. Use Promise.coroutine instead.');
                    if (typeof generatorFunction !== 'function') {
                        return apiRejection('generatorFunction must be a function');
                    }
                    var spawn = new PromiseSpawn(generatorFunction, this);
                    var ret = spawn.promise();
                    spawn._run(Promise.spawn);
                    return ret;
                };
            };
        });
        _define(91, function (module, exports) {
            'use strict';
            var fs = require(54);
            var stripBom = require(134);
            function bufferFile(file, cb) {
                fs.readFile(file.path, function (err, data) {
                    if (err) {
                        return cb(err);
                    }
                    file.contents = stripBom(data);
                    cb(null, file);
                });
            }
            module.exports = bufferFile;
        });
        _define(92, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, apiRejection, cast, INTERNAL) {
                var util = require(69);
                var tryCatch3 = util.tryCatch3;
                var errorObj = util.errorObj;
                var PENDING = {};
                var EMPTY_ARRAY = [];
                function MappingPromiseArray(promises, fn, limit, _filter) {
                    this.constructor$(promises);
                    this._callback = fn;
                    this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
                    this._limit = limit;
                    this._inFlight = 0;
                    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
                    this._init$(void 0, -2);
                }
                util.inherits(MappingPromiseArray, PromiseArray);
                MappingPromiseArray.prototype._init = function MappingPromiseArray$_init() {
                };
                MappingPromiseArray.prototype._promiseFulfilled = function MappingPromiseArray$_promiseFulfilled(value, index) {
                    var values = this._values;
                    if (values === null)
                        return;
                    var length = this.length();
                    var preservedValues = this._preservedValues;
                    var limit = this._limit;
                    if (values[index] === PENDING) {
                        values[index] = value;
                        if (limit >= 1) {
                            this._inFlight--;
                            this._drainQueue();
                            if (this._isResolved())
                                return;
                        }
                    } else {
                        if (limit >= 1 && this._inFlight >= limit) {
                            values[index] = value;
                            this._queue.push(index);
                            return;
                        }
                        if (preservedValues !== null)
                            preservedValues[index] = value;
                        var callback = this._callback;
                        var receiver = this._promise._boundTo;
                        var ret = tryCatch3(callback, receiver, value, index, length);
                        if (ret === errorObj)
                            return this._reject(ret.e);
                        var maybePromise = cast(ret, void 0);
                        if (maybePromise instanceof Promise) {
                            if (maybePromise.isPending()) {
                                if (limit >= 1)
                                    this._inFlight++;
                                values[index] = PENDING;
                                return maybePromise._proxyPromiseArray(this, index);
                            } else if (maybePromise.isFulfilled()) {
                                ret = maybePromise.value();
                            } else {
                                maybePromise._unsetRejectionIsUnhandled();
                                return this._reject(maybePromise.reason());
                            }
                        }
                        values[index] = ret;
                    }
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= length) {
                        if (preservedValues !== null) {
                            this._filter(values, preservedValues);
                        } else {
                            this._resolve(values);
                        }
                    }
                };
                MappingPromiseArray.prototype._drainQueue = function MappingPromiseArray$_drainQueue() {
                    var queue = this._queue;
                    var limit = this._limit;
                    var values = this._values;
                    while (queue.length > 0 && this._inFlight < limit) {
                        var index = queue.pop();
                        this._promiseFulfilled(values[index], index);
                    }
                };
                MappingPromiseArray.prototype._filter = function MappingPromiseArray$_filter(booleans, values) {
                    var len = values.length;
                    var ret = new Array(len);
                    var j = 0;
                    for (var i = 0; i < len; ++i) {
                        if (booleans[i])
                            ret[j++] = values[i];
                    }
                    ret.length = j;
                    this._resolve(ret);
                };
                MappingPromiseArray.prototype.preservedValues = function MappingPromiseArray$preserveValues() {
                    return this._preservedValues;
                };
                function map(promises, fn, options, _filter) {
                    var limit = typeof options === 'object' && options !== null ? options.concurrency : 0;
                    limit = typeof limit === 'number' && isFinite(limit) && limit >= 1 ? limit : 0;
                    return new MappingPromiseArray(promises, fn, limit, _filter);
                }
                Promise.prototype.map = function Promise$map(fn, options) {
                    if (typeof fn !== 'function')
                        return apiRejection('fn must be a function');
                    return map(this, fn, options, null).promise();
                };
                Promise.map = function Promise$Map(promises, fn, options, _filter) {
                    if (typeof fn !== 'function')
                        return apiRejection('fn must be a function');
                    return map(promises, fn, options, _filter).promise();
                };
            };
        });
        _define(93, function (module, exports) {
            'use strict';
            var fs = require(54);
            var stripBom = require(134);
            function streamFile(file, cb) {
                file.contents = fs.createReadStream(file.path).pipe(stripBom.stream());
                cb(null, file);
            }
            module.exports = streamFile;
        });
        _define(94, function (module, exports) {
            'use strict';
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            var util = {
                isArray: function (ar) {
                    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
                },
                isDate: function (d) {
                    return typeof d === 'object' && objectToString(d) === '[object Date]';
                },
                isRegExp: function (re) {
                    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
                },
                getRegExpFlags: function (re) {
                    var flags = '';
                    re.global && (flags += 'g');
                    re.ignoreCase && (flags += 'i');
                    re.multiline && (flags += 'm');
                    return flags;
                }
            };
            if (typeof module === 'object')
                module.exports = clone;
            function clone(parent, circular, depth, prototype) {
                var allParents = [];
                var allChildren = [];
                var useBuffer = typeof Buffer != 'undefined';
                if (typeof circular == 'undefined')
                    circular = true;
                if (typeof depth == 'undefined')
                    depth = Infinity;
                function _clone(parent, depth) {
                    if (parent === null)
                        return null;
                    if (depth == 0)
                        return parent;
                    var child;
                    var proto;
                    if (typeof parent != 'object') {
                        return parent;
                    }
                    if (util.isArray(parent)) {
                        child = [];
                    } else if (util.isRegExp(parent)) {
                        child = new RegExp(parent.source, util.getRegExpFlags(parent));
                        if (parent.lastIndex)
                            child.lastIndex = parent.lastIndex;
                    } else if (util.isDate(parent)) {
                        child = new Date(parent.getTime());
                    } else if (useBuffer && Buffer.isBuffer(parent)) {
                        child = new Buffer(parent.length);
                        parent.copy(child);
                        return child;
                    } else {
                        if (typeof prototype == 'undefined') {
                            proto = Object.getPrototypeOf(parent);
                            child = Object.create(proto);
                        } else {
                            child = Object.create(prototype);
                            proto = prototype;
                        }
                    }
                    if (circular) {
                        var index = allParents.indexOf(parent);
                        if (index != -1) {
                            return allChildren[index];
                        }
                        allParents.push(parent);
                        allChildren.push(child);
                    }
                    for (var i in parent) {
                        var attrs;
                        if (proto) {
                            attrs = Object.getOwnPropertyDescriptor(proto, i);
                        }
                        if (attrs && attrs.set == null) {
                            continue;
                        }
                        child[i] = _clone(parent[i], depth - 1);
                    }
                    return child;
                }
                return _clone(parent, depth);
            }
            clone.clonePrototype = function (parent) {
                if (parent === null)
                    return null;
                var c = function () {
                };
                c.prototype = parent;
                return new c();
            };
        });
        _define(95, function (module, exports) {
            'use strict';
            module.exports = function (Promise) {
                var util = require(69);
                var async = require(73);
                var tryCatch2 = util.tryCatch2;
                var tryCatch1 = util.tryCatch1;
                var errorObj = util.errorObj;
                function thrower(r) {
                    throw r;
                }
                function Promise$_spreadAdapter(val, receiver) {
                    if (!util.isArray(val))
                        return Promise$_successAdapter(val, receiver);
                    var ret = util.tryCatchApply(this, [null].concat(val), receiver);
                    if (ret === errorObj) {
                        async.invokeLater(thrower, void 0, ret.e);
                    }
                }
                function Promise$_successAdapter(val, receiver) {
                    var nodeback = this;
                    var ret = val === void 0 ? tryCatch1(nodeback, receiver, null) : tryCatch2(nodeback, receiver, null, val);
                    if (ret === errorObj) {
                        async.invokeLater(thrower, void 0, ret.e);
                    }
                }
                function Promise$_errorAdapter(reason, receiver) {
                    var nodeback = this;
                    var ret = tryCatch1(nodeback, receiver, reason);
                    if (ret === errorObj) {
                        async.invokeLater(thrower, void 0, ret.e);
                    }
                }
                Promise.prototype.nodeify = function Promise$nodeify(nodeback, options) {
                    if (typeof nodeback == 'function') {
                        var adapter = Promise$_successAdapter;
                        if (options !== void 0 && Object(options).spread) {
                            adapter = Promise$_spreadAdapter;
                        }
                        this._then(adapter, Promise$_errorAdapter, void 0, nodeback, this._boundTo);
                    }
                    return this;
                };
            };
        });
        _define(96, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
                var THIS = {};
                var util = require(69);
                var nodebackForPromise = require(81)._nodebackForPromise;
                var withAppended = util.withAppended;
                var maybeWrapAsError = util.maybeWrapAsError;
                var canEvaluate = util.canEvaluate;
                var TypeError = require(76).TypeError;
                var defaultSuffix = 'Async';
                var defaultFilter = function (name, func) {
                    return util.isIdentifier(name) && name.charAt(0) !== '_' && !util.isClass(func);
                };
                var defaultPromisified = { __isPromisified__: true };
                function escapeIdentRegex(str) {
                    return str.replace(/([$])/, '\\$');
                }
                function isPromisified(fn) {
                    try {
                        return fn.__isPromisified__ === true;
                    } catch (e) {
                        return false;
                    }
                }
                function hasPromisified(obj, key, suffix) {
                    var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
                    return val ? isPromisified(val) : false;
                }
                function checkValid(ret, suffix, suffixRegexp) {
                    for (var i = 0; i < ret.length; i += 2) {
                        var key = ret[i];
                        if (suffixRegexp.test(key)) {
                            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, '');
                            for (var j = 0; j < ret.length; j += 2) {
                                if (ret[j] === keyWithoutAsyncSuffix) {
                                    throw new TypeError('Cannot promisify an API ' + 'that has normal methods with \'' + suffix + '\'-suffix');
                                }
                            }
                        }
                    }
                }
                function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
                    var keys = util.inheritedDataKeys(obj);
                    var ret = [];
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        var value = obj[key];
                        if (typeof value === 'function' && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj)) {
                            ret.push(key, value);
                        }
                    }
                    checkValid(ret, suffix, suffixRegexp);
                    return ret;
                }
                function switchCaseArgumentOrder(likelyArgumentCount) {
                    var ret = [likelyArgumentCount];
                    var min = Math.max(0, likelyArgumentCount - 1 - 5);
                    for (var i = likelyArgumentCount - 1; i >= min; --i) {
                        if (i === likelyArgumentCount)
                            continue;
                        ret.push(i);
                    }
                    for (var i = likelyArgumentCount + 1; i <= 5; ++i) {
                        ret.push(i);
                    }
                    return ret;
                }
                function argumentSequence(argumentCount) {
                    return util.filledRange(argumentCount, 'arguments[', ']');
                }
                function parameterDeclaration(parameterCount) {
                    return util.filledRange(parameterCount, '_arg', '');
                }
                function parameterCount(fn) {
                    if (typeof fn.length === 'number') {
                        return Math.max(Math.min(fn.length, 1023 + 1), 0);
                    }
                    return 0;
                }
                function generatePropertyAccess(key) {
                    if (util.isIdentifier(key)) {
                        return '.' + key;
                    } else
                        return '[\'' + key.replace(/(['\\])/g, '\\$1') + '\']';
                }
                function makeNodePromisifiedEval(callback, receiver, originalName, fn, suffix) {
                    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
                    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
                    var callbackName = typeof originalName === 'string' && util.isIdentifier(originalName) ? originalName + suffix : 'promisified';
                    function generateCallForArgumentCount(count) {
                        var args = argumentSequence(count).join(', ');
                        var comma = count > 0 ? ', ' : '';
                        var ret;
                        if (typeof callback === 'string') {
                            ret = '                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            '.replace('.method', generatePropertyAccess(callback));
                        } else if (receiver === THIS) {
                            ret = '                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ';
                        } else if (receiver !== void 0) {
                            ret = '                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ';
                        } else {
                            ret = '                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ';
                        }
                        return ret.replace('{{args}}', args).replace(', ', comma);
                    }
                    function generateArgumentSwitchCase() {
                        var ret = '';
                        for (var i = 0; i < argumentOrder.length; ++i) {
                            ret += 'case ' + argumentOrder[i] + ':' + generateCallForArgumentCount(argumentOrder[i]);
                        }
                        var codeForCall;
                        if (typeof callback === 'string') {
                            codeForCall = '                                                  \n                this.property.apply(this, args);                             \n            '.replace('.property', generatePropertyAccess(callback));
                        } else if (receiver === THIS) {
                            codeForCall = '                                                  \n                callback.apply(this, args);                                  \n            ';
                        } else {
                            codeForCall = '                                                  \n                callback.apply(receiver, args);                              \n            ';
                        }
                        ret += '                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        '.replace('[CodeForCall]', codeForCall);
                        return ret;
                    }
                    return new Function('Promise', 'callback', 'receiver', 'withAppended', 'maybeWrapAsError', 'nodebackForPromise', 'INTERNAL', '                                         \n        var ret = function FunctionName(Parameters) {                        \n            \'use strict\';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        '.replace('FunctionName', callbackName).replace('Parameters', parameterDeclaration(newParameterCount)).replace('[CodeForSwitchCase]', generateArgumentSwitchCase()))(Promise, callback, receiver, withAppended, maybeWrapAsError, nodebackForPromise, INTERNAL);
                }
                function makeNodePromisifiedClosure(callback, receiver) {
                    function promisified() {
                        var _receiver = receiver;
                        if (receiver === THIS)
                            _receiver = this;
                        if (typeof callback === 'string') {
                            callback = _receiver[callback];
                        }
                        var promise = new Promise(INTERNAL);
                        promise._setTrace(void 0);
                        var fn = nodebackForPromise(promise);
                        try {
                            callback.apply(_receiver, withAppended(arguments, fn));
                        } catch (e) {
                            var wrapped = maybeWrapAsError(e);
                            promise._attachExtraTrace(wrapped);
                            promise._reject(wrapped);
                        }
                        return promise;
                    }
                    promisified.__isPromisified__ = true;
                    return promisified;
                }
                var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
                function promisifyAll(obj, suffix, filter, promisifier) {
                    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + '$');
                    var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
                    for (var i = 0, len = methods.length; i < len; i += 2) {
                        var key = methods[i];
                        var fn = methods[i + 1];
                        var promisifiedKey = key + suffix;
                        obj[promisifiedKey] = promisifier === makeNodePromisified ? makeNodePromisified(key, THIS, key, fn, suffix) : promisifier(fn);
                    }
                    util.toFastProperties(obj);
                    return obj;
                }
                function promisify(callback, receiver) {
                    return makeNodePromisified(callback, receiver, void 0, callback);
                }
                Promise.promisify = function Promise$Promisify(fn, receiver) {
                    if (typeof fn !== 'function') {
                        throw new TypeError('fn must be a function');
                    }
                    if (isPromisified(fn)) {
                        return fn;
                    }
                    return promisify(fn, arguments.length < 2 ? THIS : receiver);
                };
                Promise.promisifyAll = function Promise$PromisifyAll(target, options) {
                    if (typeof target !== 'function' && typeof target !== 'object') {
                        throw new TypeError('the target of promisifyAll must be an object or a function');
                    }
                    options = Object(options);
                    var suffix = options.suffix;
                    if (typeof suffix !== 'string')
                        suffix = defaultSuffix;
                    var filter = options.filter;
                    if (typeof filter !== 'function')
                        filter = defaultFilter;
                    var promisifier = options.promisifier;
                    if (typeof promisifier !== 'function')
                        promisifier = makeNodePromisified;
                    if (!util.isIdentifier(suffix)) {
                        throw new RangeError('suffix must be a valid identifier');
                    }
                    var keys = util.inheritedDataKeys(target, { includeHidden: true });
                    for (var i = 0; i < keys.length; ++i) {
                        var value = target[keys[i]];
                        if (keys[i] !== 'constructor' && util.isClass(value)) {
                            promisifyAll(value.prototype, suffix, filter, promisifier);
                            promisifyAll(value, suffix, filter, promisifier);
                        }
                    }
                    return promisifyAll(target, suffix, filter, promisifier);
                };
            };
        });
        _define(97, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, cast) {
                var util = require(69);
                var apiRejection = require(119)(Promise);
                var isObject = util.isObject;
                var es5 = require(131);
                function PropertiesPromiseArray(obj) {
                    var keys = es5.keys(obj);
                    var len = keys.length;
                    var values = new Array(len * 2);
                    for (var i = 0; i < len; ++i) {
                        var key = keys[i];
                        values[i] = obj[key];
                        values[i + len] = key;
                    }
                    this.constructor$(values);
                }
                util.inherits(PropertiesPromiseArray, PromiseArray);
                PropertiesPromiseArray.prototype._init = function PropertiesPromiseArray$_init() {
                    this._init$(void 0, -3);
                };
                PropertiesPromiseArray.prototype._promiseFulfilled = function PropertiesPromiseArray$_promiseFulfilled(value, index) {
                    if (this._isResolved())
                        return;
                    this._values[index] = value;
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= this._length) {
                        var val = {};
                        var keyOffset = this.length();
                        for (var i = 0, len = this.length(); i < len; ++i) {
                            val[this._values[i + keyOffset]] = this._values[i];
                        }
                        this._resolve(val);
                    }
                };
                PropertiesPromiseArray.prototype._promiseProgressed = function PropertiesPromiseArray$_promiseProgressed(value, index) {
                    if (this._isResolved())
                        return;
                    this._promise._progress({
                        key: this._values[index + this.length()],
                        value: value
                    });
                };
                PropertiesPromiseArray.prototype.shouldCopyValues = function PropertiesPromiseArray$_shouldCopyValues() {
                    return false;
                };
                PropertiesPromiseArray.prototype.getActualLength = function PropertiesPromiseArray$getActualLength(len) {
                    return len >> 1;
                };
                function Promise$_Props(promises) {
                    var ret;
                    var castValue = cast(promises, void 0);
                    if (!isObject(castValue)) {
                        return apiRejection('cannot await properties of a non-object');
                    } else if (castValue instanceof Promise) {
                        ret = castValue._then(Promise.props, void 0, void 0, void 0, void 0);
                    } else {
                        ret = new PropertiesPromiseArray(castValue).promise();
                    }
                    if (castValue instanceof Promise) {
                        ret._propagateFrom(castValue, 4);
                    }
                    return ret;
                }
                Promise.prototype.props = function Promise$props() {
                    return Promise$_Props(this);
                };
                Promise.props = function Promise$Props(promises) {
                    return Promise$_Props(promises);
                };
            };
        });
        _define(98, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, apiRejection, cast, INTERNAL) {
                var util = require(69);
                var tryCatch4 = util.tryCatch4;
                var tryCatch3 = util.tryCatch3;
                var errorObj = util.errorObj;
                function ReductionPromiseArray(promises, fn, accum, _each) {
                    this.constructor$(promises);
                    this._preservedValues = _each === INTERNAL ? [] : null;
                    this._zerothIsAccum = accum === void 0;
                    this._gotAccum = false;
                    this._reducingIndex = this._zerothIsAccum ? 1 : 0;
                    this._valuesPhase = undefined;
                    var maybePromise = cast(accum, void 0);
                    var rejected = false;
                    var isPromise = maybePromise instanceof Promise;
                    if (isPromise) {
                        if (maybePromise.isPending()) {
                            maybePromise._proxyPromiseArray(this, -1);
                        } else if (maybePromise.isFulfilled()) {
                            accum = maybePromise.value();
                            this._gotAccum = true;
                        } else {
                            maybePromise._unsetRejectionIsUnhandled();
                            this._reject(maybePromise.reason());
                            rejected = true;
                        }
                    }
                    if (!(isPromise || this._zerothIsAccum))
                        this._gotAccum = true;
                    this._callback = fn;
                    this._accum = accum;
                    if (!rejected)
                        this._init$(void 0, -5);
                }
                util.inherits(ReductionPromiseArray, PromiseArray);
                ReductionPromiseArray.prototype._init = function ReductionPromiseArray$_init() {
                };
                ReductionPromiseArray.prototype._resolveEmptyArray = function ReductionPromiseArray$_resolveEmptyArray() {
                    if (this._gotAccum || this._zerothIsAccum) {
                        this._resolve(this._preservedValues !== null ? [] : this._accum);
                    }
                };
                ReductionPromiseArray.prototype._promiseFulfilled = function ReductionPromiseArray$_promiseFulfilled(value, index) {
                    var values = this._values;
                    if (values === null)
                        return;
                    var length = this.length();
                    var preservedValues = this._preservedValues;
                    var isEach = preservedValues !== null;
                    var gotAccum = this._gotAccum;
                    var valuesPhase = this._valuesPhase;
                    var valuesPhaseIndex;
                    if (!valuesPhase) {
                        valuesPhase = this._valuesPhase = Array(length);
                        for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {
                            valuesPhase[valuesPhaseIndex] = 0;
                        }
                    }
                    valuesPhaseIndex = valuesPhase[index];
                    if (index === 0 && this._zerothIsAccum) {
                        if (!gotAccum) {
                            this._accum = value;
                            this._gotAccum = gotAccum = true;
                        }
                        valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;
                    } else if (index === -1) {
                        if (!gotAccum) {
                            this._accum = value;
                            this._gotAccum = gotAccum = true;
                        }
                    } else {
                        if (valuesPhaseIndex === 0) {
                            valuesPhase[index] = 1;
                        } else {
                            valuesPhase[index] = 2;
                            if (gotAccum) {
                                this._accum = value;
                            }
                        }
                    }
                    if (!gotAccum)
                        return;
                    var callback = this._callback;
                    var receiver = this._promise._boundTo;
                    var ret;
                    for (var i = this._reducingIndex; i < length; ++i) {
                        valuesPhaseIndex = valuesPhase[i];
                        if (valuesPhaseIndex === 2) {
                            this._reducingIndex = i + 1;
                            continue;
                        }
                        if (valuesPhaseIndex !== 1)
                            return;
                        value = values[i];
                        if (value instanceof Promise) {
                            if (value.isFulfilled()) {
                                value = value._settledValue;
                            } else if (value.isPending()) {
                                return;
                            } else {
                                value._unsetRejectionIsUnhandled();
                                return this._reject(value.reason());
                            }
                        }
                        if (isEach) {
                            preservedValues.push(value);
                            ret = tryCatch3(callback, receiver, value, i, length);
                        } else {
                            ret = tryCatch4(callback, receiver, this._accum, value, i, length);
                        }
                        if (ret === errorObj)
                            return this._reject(ret.e);
                        var maybePromise = cast(ret, void 0);
                        if (maybePromise instanceof Promise) {
                            if (maybePromise.isPending()) {
                                valuesPhase[i] = 4;
                                return maybePromise._proxyPromiseArray(this, i);
                            } else if (maybePromise.isFulfilled()) {
                                ret = maybePromise.value();
                            } else {
                                maybePromise._unsetRejectionIsUnhandled();
                                return this._reject(maybePromise.reason());
                            }
                        }
                        this._reducingIndex = i + 1;
                        this._accum = ret;
                    }
                    if (this._reducingIndex < length)
                        return;
                    this._resolve(isEach ? preservedValues : this._accum);
                };
                function reduce(promises, fn, initialValue, _each) {
                    if (typeof fn !== 'function')
                        return apiRejection('fn must be a function');
                    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
                    return array.promise();
                }
                Promise.prototype.reduce = function Promise$reduce(fn, initialValue) {
                    return reduce(this, fn, initialValue, null);
                };
                Promise.reduce = function Promise$Reduce(promises, fn, initialValue, _each) {
                    return reduce(promises, fn, initialValue, _each);
                };
            };
        });
        _define(99, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray) {
                var PromiseInspection = Promise.PromiseInspection;
                var util = require(69);
                function SettledPromiseArray(values) {
                    this.constructor$(values);
                }
                util.inherits(SettledPromiseArray, PromiseArray);
                SettledPromiseArray.prototype._promiseResolved = function SettledPromiseArray$_promiseResolved(index, inspection) {
                    this._values[index] = inspection;
                    var totalResolved = ++this._totalResolved;
                    if (totalResolved >= this._length) {
                        this._resolve(this._values);
                    }
                };
                SettledPromiseArray.prototype._promiseFulfilled = function SettledPromiseArray$_promiseFulfilled(value, index) {
                    if (this._isResolved())
                        return;
                    var ret = new PromiseInspection();
                    ret._bitField = 268435456;
                    ret._settledValue = value;
                    this._promiseResolved(index, ret);
                };
                SettledPromiseArray.prototype._promiseRejected = function SettledPromiseArray$_promiseRejected(reason, index) {
                    if (this._isResolved())
                        return;
                    var ret = new PromiseInspection();
                    ret._bitField = 134217728;
                    ret._settledValue = reason;
                    this._promiseResolved(index, ret);
                };
                Promise.settle = function Promise$Settle(promises) {
                    return new SettledPromiseArray(promises).promise();
                };
                Promise.prototype.settle = function Promise$settle() {
                    return new SettledPromiseArray(this).promise();
                };
            };
        });
        _define(100, function (module, exports) {
            var Readable = require('stream').Readable;
            var util = require('util');
            function addStream(streams, stream) {
                if (!stream.readable)
                    throw new Error('All input streams must be readable');
                if (this._readableState.ended)
                    throw new Error('Adding streams after ended');
                var self = this;
                stream._buffer = [];
                stream.on('data', function (chunk) {
                    if (this === streams[0])
                        self.push(chunk);
                    else
                        this._buffer.push(chunk);
                });
                stream.on('end', function () {
                    for (var stream = streams[0]; stream && stream._readableState.ended; stream = streams[0]) {
                        while (stream._buffer.length)
                            self.push(stream._buffer.shift());
                        streams.shift();
                    }
                    if (!streams.length)
                        self.push(null);
                });
                stream.on('error', this.emit.bind(this, 'error'));
                streams.push(stream);
            }
            function OrderedStreams(streams, options) {
                if (!(this instanceof OrderedStreams)) {
                    return new OrderedStreams(streams, options);
                }
                streams = streams || [];
                options = options || {};
                options.objectMode = true;
                Readable.call(this, options);
                if (!Array.isArray(streams))
                    streams = [streams];
                if (!streams.length)
                    return this.push(null);
                var addStream_bind = addStream.bind(this, []);
                this.concat = function () {
                    Array.prototype.forEach.call(arguments, function (item) {
                        if (Array.isArray(item))
                            item.forEach(addStream_bind);
                        else
                            addStream_bind(item);
                    });
                };
                this.concat(streams);
            }
            util.inherits(OrderedStreams, Readable);
            OrderedStreams.prototype._read = function () {
            };
            module.exports = OrderedStreams;
        });
        _define(101, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray, apiRejection) {
                var util = require(69);
                var RangeError = require(76).RangeError;
                var AggregateError = require(76).AggregateError;
                var isArray = util.isArray;
                function SomePromiseArray(values) {
                    this.constructor$(values);
                    this._howMany = 0;
                    this._unwrap = false;
                    this._initialized = false;
                }
                util.inherits(SomePromiseArray, PromiseArray);
                SomePromiseArray.prototype._init = function SomePromiseArray$_init() {
                    if (!this._initialized) {
                        return;
                    }
                    if (this._howMany === 0) {
                        this._resolve([]);
                        return;
                    }
                    this._init$(void 0, -5);
                    var isArrayResolved = isArray(this._values);
                    if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                        this._reject(this._getRangeError(this.length()));
                    }
                };
                SomePromiseArray.prototype.init = function SomePromiseArray$init() {
                    this._initialized = true;
                    this._init();
                };
                SomePromiseArray.prototype.setUnwrap = function SomePromiseArray$setUnwrap() {
                    this._unwrap = true;
                };
                SomePromiseArray.prototype.howMany = function SomePromiseArray$howMany() {
                    return this._howMany;
                };
                SomePromiseArray.prototype.setHowMany = function SomePromiseArray$setHowMany(count) {
                    if (this._isResolved())
                        return;
                    this._howMany = count;
                };
                SomePromiseArray.prototype._promiseFulfilled = function SomePromiseArray$_promiseFulfilled(value) {
                    if (this._isResolved())
                        return;
                    this._addFulfilled(value);
                    if (this._fulfilled() === this.howMany()) {
                        this._values.length = this.howMany();
                        if (this.howMany() === 1 && this._unwrap) {
                            this._resolve(this._values[0]);
                        } else {
                            this._resolve(this._values);
                        }
                    }
                };
                SomePromiseArray.prototype._promiseRejected = function SomePromiseArray$_promiseRejected(reason) {
                    if (this._isResolved())
                        return;
                    this._addRejected(reason);
                    if (this.howMany() > this._canPossiblyFulfill()) {
                        var e = new AggregateError();
                        for (var i = this.length(); i < this._values.length; ++i) {
                            e.push(this._values[i]);
                        }
                        this._reject(e);
                    }
                };
                SomePromiseArray.prototype._fulfilled = function SomePromiseArray$_fulfilled() {
                    return this._totalResolved;
                };
                SomePromiseArray.prototype._rejected = function SomePromiseArray$_rejected() {
                    return this._values.length - this.length();
                };
                SomePromiseArray.prototype._addRejected = function SomePromiseArray$_addRejected(reason) {
                    this._values.push(reason);
                };
                SomePromiseArray.prototype._addFulfilled = function SomePromiseArray$_addFulfilled(value) {
                    this._values[this._totalResolved++] = value;
                };
                SomePromiseArray.prototype._canPossiblyFulfill = function SomePromiseArray$_canPossiblyFulfill() {
                    return this.length() - this._rejected();
                };
                SomePromiseArray.prototype._getRangeError = function SomePromiseArray$_getRangeError(count) {
                    var message = 'Input array must contain at least ' + this._howMany + ' items but contains only ' + count + ' items';
                    return new RangeError(message);
                };
                SomePromiseArray.prototype._resolveEmptyArray = function SomePromiseArray$_resolveEmptyArray() {
                    this._reject(this._getRangeError(0));
                };
                function Promise$_Some(promises, howMany) {
                    if ((howMany | 0) !== howMany || howMany < 0) {
                        return apiRejection('expecting a positive integer');
                    }
                    var ret = new SomePromiseArray(promises);
                    var promise = ret.promise();
                    if (promise.isRejected()) {
                        return promise;
                    }
                    ret.setHowMany(howMany);
                    ret.init();
                    return promise;
                }
                Promise.some = function Promise$Some(promises, howMany) {
                    return Promise$_Some(promises, howMany);
                };
                Promise.prototype.some = function Promise$some(howMany) {
                    return Promise$_Some(this, howMany);
                };
                Promise._SomePromiseArray = SomePromiseArray;
            };
        });
        _define(102, function (module, exports) {
            'use strict';
            var mkdirp = require(55);
            function writeDir(writePath, file, cb) {
                mkdirp(writePath, file.stat.mode, cb);
            }
            module.exports = writeDir;
        });
        _define(103, function (module, exports) {
            var mod = require('module');
            var pre = '(function (exports, require, module, __filename, __dirname) { ';
            var post = '});';
            var src = pre + process.binding('natives').fs + post;
            var vm = require('vm');
            var fn = vm.runInThisContext(src);
            fn(exports, require, module, __filename, __dirname);
        });
        _define(104, function (module, exports) {
            var Stream = require('stream');
            function prop(propName) {
                return function (data) {
                    return data[propName];
                };
            }
            module.exports = unique;
            function unique(propName) {
                var keyfn = JSON.stringify;
                if (typeof propName === 'string') {
                    keyfn = prop(propName);
                } else if (typeof propName === 'function') {
                    keyfn = propName;
                }
                var seen = {};
                var s = new Stream();
                s.readable = true;
                s.writable = true;
                var pipes = 0;
                s.write = function (data) {
                    var key = keyfn(data);
                    if (seen[key] === undefined) {
                        seen[key] = true;
                        s.emit('data', data);
                    }
                };
                var ended = 0;
                s.end = function (data) {
                    if (arguments.length)
                        s.write(data);
                    ended++;
                    if (ended === pipes || pipes === 0) {
                        s.writable = false;
                        s.emit('end');
                    }
                };
                s.destroy = function (data) {
                    s.writable = false;
                };
                s.on('pipe', function () {
                    pipes++;
                });
                s.on('unpipe', function () {
                    pipes--;
                });
                return s;
            }
        });
        _define(105, function (module, exports) {
            'use strict';
            module.exports = function (Promise, PromiseArray) {
                var util = require(69);
                var async = require(73);
                var errors = require(76);
                var tryCatch1 = util.tryCatch1;
                var errorObj = util.errorObj;
                Promise.prototype.progressed = function Promise$progressed(handler) {
                    return this._then(void 0, void 0, handler, void 0, void 0);
                };
                Promise.prototype._progress = function Promise$_progress(progressValue) {
                    if (this._isFollowingOrFulfilledOrRejected())
                        return;
                    this._progressUnchecked(progressValue);
                };
                Promise.prototype._clearFirstHandlerData$Base = Promise.prototype._clearFirstHandlerData;
                Promise.prototype._clearFirstHandlerData = function Promise$_clearFirstHandlerData() {
                    this._clearFirstHandlerData$Base();
                    this._progressHandler0 = void 0;
                };
                Promise.prototype._progressHandlerAt = function Promise$_progressHandlerAt(index) {
                    return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];
                };
                Promise.prototype._doProgressWith = function Promise$_doProgressWith(progression) {
                    var progressValue = progression.value;
                    var handler = progression.handler;
                    var promise = progression.promise;
                    var receiver = progression.receiver;
                    var ret = tryCatch1(handler, receiver, progressValue);
                    if (ret === errorObj) {
                        if (ret.e != null && ret.e.name !== 'StopProgressPropagation') {
                            var trace = errors.canAttach(ret.e) ? ret.e : new Error(ret.e + '');
                            promise._attachExtraTrace(trace);
                            promise._progress(ret.e);
                        }
                    } else if (ret instanceof Promise) {
                        ret._then(promise._progress, null, null, promise, void 0);
                    } else {
                        promise._progress(ret);
                    }
                };
                Promise.prototype._progressUnchecked = function Promise$_progressUnchecked(progressValue) {
                    if (!this.isPending())
                        return;
                    var len = this._length();
                    var progress = this._progress;
                    for (var i = 0; i < len; i++) {
                        var handler = this._progressHandlerAt(i);
                        var promise = this._promiseAt(i);
                        if (!(promise instanceof Promise)) {
                            var receiver = this._receiverAt(i);
                            if (typeof handler === 'function') {
                                handler.call(receiver, progressValue, promise);
                            } else if (receiver instanceof Promise && receiver._isProxied()) {
                                receiver._progressUnchecked(progressValue);
                            } else if (receiver instanceof PromiseArray) {
                                receiver._promiseProgressed(progressValue, promise);
                            }
                            continue;
                        }
                        if (typeof handler === 'function') {
                            async.invoke(this._doProgressWith, this, {
                                handler: handler,
                                promise: promise,
                                receiver: this._receiverAt(i),
                                value: progressValue
                            });
                        } else {
                            async.invoke(progress, promise, progressValue);
                        }
                    }
                };
            };
        });
        _define(106, function (module, exports) {
            'use strict';
            var streamFile = require(93);
            var fs = require(54);
            function writeStream(writePath, file, cb) {
                var opt = { mode: file.stat.mode };
                var outStream = fs.createWriteStream(writePath, opt);
                file.contents.once('error', cb);
                outStream.once('error', cb);
                outStream.once('finish', function () {
                    streamFile(file, cb);
                });
                file.contents.pipe(outStream);
            }
            module.exports = writeStream;
        });
        _define(107, function (module, exports) {
            var fs = require(103);
            var constants = require('constants');
            var origCwd = process.cwd;
            var cwd = null;
            process.cwd = function () {
                if (!cwd)
                    cwd = origCwd.call(process);
                return cwd;
            };
            var chdir = process.chdir;
            process.chdir = function (d) {
                cwd = null;
                chdir.call(process, d);
            };
            if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
                fs.lchmod = function (path, mode, callback) {
                    callback = callback || noop;
                    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        fs.fchmod(fd, mode, function (err) {
                            fs.close(fd, function (err2) {
                                callback(err || err2);
                            });
                        });
                    });
                };
                fs.lchmodSync = function (path, mode) {
                    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
                    var err, err2;
                    try {
                        var ret = fs.fchmodSync(fd, mode);
                    } catch (er) {
                        err = er;
                    }
                    try {
                        fs.closeSync(fd);
                    } catch (er) {
                        err2 = er;
                    }
                    if (err || err2)
                        throw err || err2;
                    return ret;
                };
            }
            if (!fs.lutimes) {
                if (constants.hasOwnProperty('O_SYMLINK')) {
                    fs.lutimes = function (path, at, mt, cb) {
                        fs.open(path, constants.O_SYMLINK, function (er, fd) {
                            cb = cb || noop;
                            if (er)
                                return cb(er);
                            fs.futimes(fd, at, mt, function (er) {
                                fs.close(fd, function (er2) {
                                    return cb(er || er2);
                                });
                            });
                        });
                    };
                    fs.lutimesSync = function (path, at, mt) {
                        var fd = fs.openSync(path, constants.O_SYMLINK), err, err2, ret;
                        try {
                            var ret = fs.futimesSync(fd, at, mt);
                        } catch (er) {
                            err = er;
                        }
                        try {
                            fs.closeSync(fd);
                        } catch (er) {
                            err2 = er;
                        }
                        if (err || err2)
                            throw err || err2;
                        return ret;
                    };
                } else if (fs.utimensat && constants.hasOwnProperty('AT_SYMLINK_NOFOLLOW')) {
                    fs.lutimes = function (path, at, mt, cb) {
                        fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb);
                    };
                    fs.lutimesSync = function (path, at, mt) {
                        return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW);
                    };
                } else {
                    fs.lutimes = function (_a, _b, _c, cb) {
                        process.nextTick(cb);
                    };
                    fs.lutimesSync = function () {
                    };
                }
            }
            fs.chown = chownFix(fs.chown);
            fs.fchown = chownFix(fs.fchown);
            fs.lchown = chownFix(fs.lchown);
            fs.chmod = chownFix(fs.chmod);
            fs.fchmod = chownFix(fs.fchmod);
            fs.lchmod = chownFix(fs.lchmod);
            fs.chownSync = chownFixSync(fs.chownSync);
            fs.fchownSync = chownFixSync(fs.fchownSync);
            fs.lchownSync = chownFixSync(fs.lchownSync);
            fs.chmodSync = chownFix(fs.chmodSync);
            fs.fchmodSync = chownFix(fs.fchmodSync);
            fs.lchmodSync = chownFix(fs.lchmodSync);
            function chownFix(orig) {
                if (!orig)
                    return orig;
                return function (target, uid, gid, cb) {
                    return orig.call(fs, target, uid, gid, function (er, res) {
                        if (chownErOk(er))
                            er = null;
                        cb(er, res);
                    });
                };
            }
            function chownFixSync(orig) {
                if (!orig)
                    return orig;
                return function (target, uid, gid) {
                    try {
                        return orig.call(fs, target, uid, gid);
                    } catch (er) {
                        if (!chownErOk(er))
                            throw er;
                    }
                };
            }
            function chownErOk(er) {
                if (!er)
                    return true;
                if (er.code === 'ENOSYS')
                    return true;
                var nonroot = !process.getuid || process.getuid() !== 0;
                if (nonroot) {
                    if (er.code === 'EINVAL' || er.code === 'EPERM')
                        return true;
                }
                return false;
            }
            if (!fs.lchmod) {
                fs.lchmod = function (path, mode, cb) {
                    process.nextTick(cb);
                };
                fs.lchmodSync = function () {
                };
            }
            if (!fs.lchown) {
                fs.lchown = function (path, uid, gid, cb) {
                    process.nextTick(cb);
                };
                fs.lchownSync = function () {
                };
            }
            if (process.platform === 'win32') {
                var rename_ = fs.rename;
                fs.rename = function rename(from, to, cb) {
                    var start = Date.now();
                    rename_(from, to, function CB(er) {
                        if (er && (er.code === 'EACCES' || er.code === 'EPERM') && Date.now() - start < 1000) {
                            return rename_(from, to, CB);
                        }
                        cb(er);
                    });
                };
            }
            var read = fs.read;
            fs.read = function (fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === 'function') {
                    var eagCounter = 0;
                    callback = function (er, _, __) {
                        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            return read.call(fs, fd, buffer, offset, length, position, callback);
                        }
                        callback_.apply(this, arguments);
                    };
                }
                return read.call(fs, fd, buffer, offset, length, position, callback);
            };
            var readSync = fs.readSync;
            fs.readSync = function (fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while (true) {
                    try {
                        return readSync.call(fs, fd, buffer, offset, length, position);
                    } catch (er) {
                        if (er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            continue;
                        }
                        throw er;
                    }
                }
            };
        });
        _define(108, function (module, exports) {
            module.exports = glob;
            var fs = require('fs');
            var minimatch = require(111);
            var Minimatch = minimatch.Minimatch;
            var inherits = require(139);
            var EE = require('events').EventEmitter;
            var path = require('path');
            var assert = require('assert');
            var globSync = require(135);
            var common = require(136);
            var alphasort = common.alphasort;
            var isAbsolute = common.isAbsolute;
            var setopts = common.setopts;
            var ownProp = common.ownProp;
            var inflight = require(138);
            var util = require('util');
            var once = require(137);
            function glob(pattern, options, cb) {
                if (typeof options === 'function')
                    cb = options, options = {};
                if (!options)
                    options = {};
                if (options.sync) {
                    if (cb)
                        throw new TypeError('callback provided to sync glob');
                    return globSync(pattern, options);
                }
                return new Glob(pattern, options, cb);
            }
            glob.sync = globSync;
            var GlobSync = glob.GlobSync = globSync.GlobSync;
            glob.glob = glob;
            glob.hasMagic = function (pattern, options_) {
                var options = util._extend({}, options_);
                options.noprocess = true;
                var g = new Glob(pattern, options);
                var set = g.minimatch.set;
                if (set.length > 1)
                    return true;
                for (var j = 0; j < set[0].length; j++) {
                    if (typeof set[0][j] !== 'string')
                        return true;
                }
                return false;
            };
            glob.Glob = Glob;
            inherits(Glob, EE);
            function Glob(pattern, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                if (options && options.sync) {
                    if (cb)
                        throw new TypeError('callback provided to sync glob');
                    return new GlobSync(pattern, options);
                }
                if (!(this instanceof Glob))
                    return new Glob(pattern, options, cb);
                setopts(this, pattern, options);
                var n = this.minimatch.set.length;
                this.matches = new Array(n);
                if (typeof cb === 'function') {
                    cb = once(cb);
                    this.on('error', cb);
                    this.on('end', function (matches) {
                        cb(null, matches);
                    });
                }
                var self = this;
                var n = this.minimatch.set.length;
                this._processing = 0;
                this.matches = new Array(n);
                this._emitQueue = [];
                this._processQueue = [];
                this.paused = false;
                if (this.noprocess)
                    return this;
                if (n === 0)
                    return done();
                for (var i = 0; i < n; i++) {
                    this._process(this.minimatch.set[i], i, false, done);
                }
                function done() {
                    --self._processing;
                    if (self._processing <= 0)
                        self._finish();
                }
            }
            Glob.prototype._finish = function () {
                assert(this instanceof Glob);
                if (this.aborted)
                    return;
                common.finish(this);
                this.emit('end', this.found);
            };
            Glob.prototype._mark = function (p) {
                return common.mark(this, p);
            };
            Glob.prototype._makeAbs = function (f) {
                return common.makeAbs(this, f);
            };
            Glob.prototype.abort = function () {
                this.aborted = true;
                this.emit('abort');
            };
            Glob.prototype.pause = function () {
                if (!this.paused) {
                    this.paused = true;
                    this.emit('pause');
                }
            };
            Glob.prototype.resume = function () {
                if (this.paused) {
                    this.emit('resume');
                    this.paused = false;
                    if (this._emitQueue.length) {
                        var eq = this._emitQueue.slice(0);
                        this._emitQueue.length = 0;
                        for (var i = 0; i < eq.length; i++) {
                            var e = eq[i];
                            this._emitMatch(e[0], e[1]);
                        }
                    }
                    if (this._processQueue.length) {
                        var pq = this._processQueue.slice(0);
                        this._processQueue.length = 0;
                        for (var i = 0; i < pq.length; i++) {
                            var p = pq[i];
                            this._processing--;
                            this._process(p[0], p[1], p[2], p[3]);
                        }
                    }
                }
            };
            Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
                assert(this instanceof Glob);
                assert(typeof cb === 'function');
                if (this.aborted)
                    return;
                this._processing++;
                if (this.paused) {
                    this._processQueue.push([
                        pattern,
                        index,
                        inGlobStar,
                        cb
                    ]);
                    return;
                }
                var n = 0;
                while (typeof pattern[n] === 'string') {
                    n++;
                }
                var prefix;
                switch (n) {
                case pattern.length:
                    this._processSimple(pattern.join('/'), index, cb);
                    return;
                case 0:
                    prefix = null;
                    break;
                default:
                    prefix = pattern.slice(0, n).join('/');
                    break;
                }
                var remain = pattern.slice(n);
                var read;
                if (prefix === null)
                    read = '.';
                else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
                    if (!prefix || !isAbsolute(prefix))
                        prefix = '/' + prefix;
                    read = prefix;
                } else
                    read = prefix;
                var abs = this._makeAbs(read);
                var isGlobStar = remain[0] === minimatch.GLOBSTAR;
                if (isGlobStar)
                    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
                else
                    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
            };
            Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
                var self = this;
                this._readdir(abs, inGlobStar, function (er, entries) {
                    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
                });
            };
            Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
                if (!entries)
                    return cb();
                var pn = remain[0];
                var negate = !!this.minimatch.negate;
                var rawGlob = pn._glob;
                var dotOk = this.dot || rawGlob.charAt(0) === '.';
                var matchedEntries = [];
                for (var i = 0; i < entries.length; i++) {
                    var e = entries[i];
                    if (e.charAt(0) !== '.' || dotOk) {
                        var m;
                        if (negate && !prefix) {
                            m = !e.match(pn);
                        } else {
                            m = e.match(pn);
                        }
                        if (m)
                            matchedEntries.push(e);
                    }
                }
                var len = matchedEntries.length;
                if (len === 0)
                    return cb();
                if (remain.length === 1 && !this.mark && !this.stat) {
                    if (!this.matches[index])
                        this.matches[index] = Object.create(null);
                    for (var i = 0; i < len; i++) {
                        var e = matchedEntries[i];
                        if (prefix) {
                            if (prefix !== '/')
                                e = prefix + '/' + e;
                            else
                                e = prefix + e;
                        }
                        if (e.charAt(0) === '/' && !this.nomount) {
                            e = path.join(this.root, e);
                        }
                        this._emitMatch(index, e);
                    }
                    return cb();
                }
                remain.shift();
                for (var i = 0; i < len; i++) {
                    var e = matchedEntries[i];
                    var newPattern;
                    if (prefix) {
                        if (prefix !== '/')
                            e = prefix + '/' + e;
                        else
                            e = prefix + e;
                    }
                    this._process([e].concat(remain), index, inGlobStar, cb);
                }
                cb();
            };
            Glob.prototype._emitMatch = function (index, e) {
                if (this.aborted)
                    return;
                if (!this.matches[index][e]) {
                    if (this.paused) {
                        this._emitQueue.push([
                            index,
                            e
                        ]);
                        return;
                    }
                    if (this.nodir) {
                        var c = this.cache[this._makeAbs(e)];
                        if (c === 'DIR' || Array.isArray(c))
                            return;
                    }
                    this.matches[index][e] = true;
                    if (!this.stat && !this.mark)
                        return this.emit('match', e);
                    var self = this;
                    this._stat(this._makeAbs(e), function (er, c, st) {
                        self.emit('stat', e, st);
                        self.emit('match', e);
                    });
                }
            };
            Glob.prototype._readdirInGlobStar = function (abs, cb) {
                if (this.aborted)
                    return;
                var lstatkey = 'lstat\0' + abs;
                var self = this;
                var lstatcb = inflight(lstatkey, lstatcb_);
                if (lstatcb)
                    fs.lstat(abs, lstatcb);
                function lstatcb_(er, lstat) {
                    if (er)
                        return cb();
                    var isSym = lstat.isSymbolicLink();
                    self.symlinks[abs] = isSym;
                    if (!isSym && !lstat.isDirectory()) {
                        self.cache[abs] = 'FILE';
                        cb();
                    } else
                        self._readdir(abs, false, cb);
                }
            };
            Glob.prototype._readdir = function (abs, inGlobStar, cb) {
                if (this.aborted)
                    return;
                cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
                if (!cb)
                    return;
                if (inGlobStar && !ownProp(this.symlinks, abs))
                    return this._readdirInGlobStar(abs, cb);
                if (ownProp(this.cache, abs)) {
                    var c = this.cache[abs];
                    if (!c || c === 'FILE')
                        return cb();
                    if (Array.isArray(c))
                        return cb(null, c);
                }
                var self = this;
                fs.readdir(abs, readdirCb(this, abs, cb));
            };
            function readdirCb(self, abs, cb) {
                return function (er, entries) {
                    if (er)
                        self._readdirError(abs, er, cb);
                    else
                        self._readdirEntries(abs, entries.sort(alphasort), cb);
                };
            }
            Glob.prototype._readdirEntries = function (abs, entries, cb) {
                if (this.aborted)
                    return;
                if (!this.mark && !this.stat) {
                    for (var i = 0; i < entries.length; i++) {
                        var e = entries[i];
                        if (abs === '/')
                            e = abs + e;
                        else
                            e = abs + '/' + e;
                        this.cache[e] = true;
                    }
                }
                this.cache[abs] = entries;
                return cb(null, entries);
            };
            Glob.prototype._readdirError = function (f, er, cb) {
                if (this.aborted)
                    return;
                switch (er.code) {
                case 'ENOTDIR':
                    this.cache[f] = 'FILE';
                    break;
                case 'ENOENT':
                case 'ELOOP':
                case 'ENAMETOOLONG':
                case 'UNKNOWN':
                    this.cache[f] = false;
                    break;
                default:
                    this.cache[f] = false;
                    if (this.strict)
                        return this.emit('error', er);
                    if (!this.silent)
                        console.error('glob error', er);
                    break;
                }
                return cb();
            };
            Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
                var self = this;
                this._readdir(abs, inGlobStar, function (er, entries) {
                    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
                });
            };
            Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
                if (!entries)
                    return cb();
                var remainWithoutGlobStar = remain.slice(1);
                var gspref = prefix ? [prefix] : [];
                var noGlobStar = gspref.concat(remainWithoutGlobStar);
                this._process(noGlobStar, index, false, cb);
                var isSym = this.symlinks[abs];
                var len = entries.length;
                if (isSym && inGlobStar)
                    return cb();
                for (var i = 0; i < len; i++) {
                    var e = entries[i];
                    if (e.charAt(0) === '.' && !this.dot)
                        continue;
                    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
                    this._process(instead, index, true, cb);
                    var below = gspref.concat(entries[i], remain);
                    this._process(below, index, true, cb);
                }
                cb();
            };
            Glob.prototype._processSimple = function (prefix, index, cb) {
                var self = this;
                this._stat(prefix, function (er, exists) {
                    self._processSimple2(prefix, index, er, exists, cb);
                });
            };
            Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
                if (!this.matches[index])
                    this.matches[index] = Object.create(null);
                if (!exists)
                    return cb();
                if (prefix && isAbsolute(prefix) && !this.nomount) {
                    if (prefix.charAt(0) === '/') {
                        prefix = path.join(this.root, prefix);
                    } else {
                        prefix = path.resolve(this.root, prefix);
                    }
                }
                if (process.platform === 'win32')
                    prefix = prefix.replace(/\\/g, '/');
                this._emitMatch(index, prefix);
                cb();
            };
            Glob.prototype._stat = function (f, cb) {
                var abs = f;
                if (f.charAt(0) === '/')
                    abs = path.join(this.root, f);
                else if (this.changedCwd)
                    abs = path.resolve(this.cwd, f);
                if (f.length > this.maxLength)
                    return cb();
                if (!this.stat && ownProp(this.cache, f)) {
                    var c = this.cache[f];
                    if (Array.isArray(c))
                        c = 'DIR';
                    if (abs.slice(-1) === '/' && c !== 'DIR')
                        return cb();
                    return cb(null, c);
                }
                var exists;
                var stat = this.statCache[abs];
                if (stat !== undefined) {
                    if (stat === false)
                        return cb(null, stat);
                    else
                        return cb(null, stat.isDirectory() ? 'DIR' : 'FILE', stat);
                }
                var self = this;
                var statcb = inflight('stat\0' + abs, statcb_);
                if (statcb)
                    fs.stat(abs, statcb);
                function statcb_(er, stat) {
                    self._stat2(f, abs, er, stat, cb);
                }
            };
            Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
                if (er) {
                    this.statCache[abs] = false;
                    return cb();
                }
                this.statCache[abs] = stat;
                if (abs.slice(-1) === '/' && !stat.isDirectory())
                    return cb(null, false, stat);
                var c = stat.isDirectory() ? 'DIR' : 'FILE';
                this.cache[f] = this.cache[f] || c;
                return cb(null, c, stat);
            };
        });
        _define(109, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
                var errors = require(76);
                var canAttach = errors.canAttach;
                var async = require(73);
                var CancellationError = errors.CancellationError;
                Promise.prototype._cancel = function Promise$_cancel(reason) {
                    if (!this.isCancellable())
                        return this;
                    var parent;
                    var promiseToReject = this;
                    while ((parent = promiseToReject._cancellationParent) !== void 0 && parent.isCancellable()) {
                        promiseToReject = parent;
                    }
                    this._unsetCancellable();
                    promiseToReject._attachExtraTrace(reason);
                    promiseToReject._rejectUnchecked(reason);
                };
                Promise.prototype.cancel = function Promise$cancel(reason) {
                    if (!this.isCancellable())
                        return this;
                    reason = reason !== void 0 ? canAttach(reason) ? reason : new Error(reason + '') : new CancellationError();
                    async.invokeLater(this._cancel, this, reason);
                    return this;
                };
                Promise.prototype.cancellable = function Promise$cancellable() {
                    if (this._cancellable())
                        return this;
                    this._setCancellable();
                    this._cancellationParent = void 0;
                    return this;
                };
                Promise.prototype.uncancellable = function Promise$uncancellable() {
                    var ret = new Promise(INTERNAL);
                    ret._propagateFrom(this, 2 | 4);
                    ret._follow(this);
                    ret._unsetCancellable();
                    return ret;
                };
                Promise.prototype.fork = function Promise$fork(didFulfill, didReject, didProgress) {
                    var ret = this._then(didFulfill, didReject, didProgress, void 0, void 0);
                    ret._setCancellable();
                    ret._cancellationParent = void 0;
                    return ret;
                };
            };
        });
        _define(110, function (module, exports) {
            'use strict';
            var fs = require(54);
            function writeBuffer(writePath, file, cb) {
                var opt = { mode: file.stat.mode };
                fs.writeFile(writePath, file.contents, opt, cb);
            }
            module.exports = writeBuffer;
        });
        _define(111, function (module, exports) {
            module.exports = minimatch;
            minimatch.Minimatch = Minimatch;
            var isWindows = false;
            if (typeof process !== 'undefined' && process.platform === 'win32')
                isWindows = true;
            var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, expand = require(140), qmark = '[^/]', star = qmark + '*?', twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?', twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?', reSpecials = charSet('().*{}+?[]^$\\!');
            function charSet(s) {
                return s.split('').reduce(function (set, c) {
                    set[c] = true;
                    return set;
                }, {});
            }
            var slashSplit = /\/+/;
            minimatch.filter = filter;
            function filter(pattern, options) {
                options = options || {};
                return function (p, i, list) {
                    return minimatch(p, pattern, options);
                };
            }
            function ext(a, b) {
                a = a || {};
                b = b || {};
                var t = {};
                Object.keys(b).forEach(function (k) {
                    t[k] = b[k];
                });
                Object.keys(a).forEach(function (k) {
                    t[k] = a[k];
                });
                return t;
            }
            minimatch.defaults = function (def) {
                if (!def || !Object.keys(def).length)
                    return minimatch;
                var orig = minimatch;
                var m = function minimatch(p, pattern, options) {
                    return orig.minimatch(p, pattern, ext(def, options));
                };
                m.Minimatch = function Minimatch(pattern, options) {
                    return new orig.Minimatch(pattern, ext(def, options));
                };
                return m;
            };
            Minimatch.defaults = function (def) {
                if (!def || !Object.keys(def).length)
                    return Minimatch;
                return minimatch.defaults(def).Minimatch;
            };
            function minimatch(p, pattern, options) {
                if (typeof pattern !== 'string') {
                    throw new TypeError('glob pattern string required');
                }
                if (!options)
                    options = {};
                if (!options.nocomment && pattern.charAt(0) === '#') {
                    return false;
                }
                if (pattern.trim() === '')
                    return p === '';
                return new Minimatch(pattern, options).match(p);
            }
            function Minimatch(pattern, options) {
                if (!(this instanceof Minimatch)) {
                    return new Minimatch(pattern, options);
                }
                if (typeof pattern !== 'string') {
                    throw new TypeError('glob pattern string required');
                }
                if (!options)
                    options = {};
                pattern = pattern.trim();
                if (isWindows)
                    pattern = pattern.split('\\').join('/');
                this.options = options;
                this.set = [];
                this.pattern = pattern;
                this.regexp = null;
                this.negate = false;
                this.comment = false;
                this.empty = false;
                this.make();
            }
            Minimatch.prototype.debug = function () {
            };
            Minimatch.prototype.make = make;
            function make() {
                if (this._made)
                    return;
                var pattern = this.pattern;
                var options = this.options;
                if (!options.nocomment && pattern.charAt(0) === '#') {
                    this.comment = true;
                    return;
                }
                if (!pattern) {
                    this.empty = true;
                    return;
                }
                this.parseNegate();
                var set = this.globSet = this.braceExpand();
                if (options.debug)
                    this.debug = console.error;
                this.debug(this.pattern, set);
                set = this.globParts = set.map(function (s) {
                    return s.split(slashSplit);
                });
                this.debug(this.pattern, set);
                set = set.map(function (s, si, set) {
                    return s.map(this.parse, this);
                }, this);
                this.debug(this.pattern, set);
                set = set.filter(function (s) {
                    return -1 === s.indexOf(false);
                });
                this.debug(this.pattern, set);
                this.set = set;
            }
            Minimatch.prototype.parseNegate = parseNegate;
            function parseNegate() {
                var pattern = this.pattern, negate = false, options = this.options, negateOffset = 0;
                if (options.nonegate)
                    return;
                for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
                    negate = !negate;
                    negateOffset++;
                }
                if (negateOffset)
                    this.pattern = pattern.substr(negateOffset);
                this.negate = negate;
            }
            minimatch.braceExpand = function (pattern, options) {
                return braceExpand(pattern, options);
            };
            Minimatch.prototype.braceExpand = braceExpand;
            function braceExpand(pattern, options) {
                if (!options) {
                    if (this instanceof Minimatch)
                        options = this.options;
                    else
                        options = {};
                }
                pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
                if (typeof pattern === 'undefined') {
                    throw new Error('undefined pattern');
                }
                if (options.nobrace || !pattern.match(/\{.*\}/)) {
                    return [pattern];
                }
                return expand(pattern);
            }
            Minimatch.prototype.parse = parse;
            var SUBPARSE = {};
            function parse(pattern, isSub) {
                var options = this.options;
                if (!options.noglobstar && pattern === '**')
                    return GLOBSTAR;
                if (pattern === '')
                    return '';
                var re = '', hasMagic = !!options.nocase, escaping = false, patternListStack = [], plType, stateChar, inClass = false, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))' : '(?!\\.)', self = this;
                function clearStateChar() {
                    if (stateChar) {
                        switch (stateChar) {
                        case '*':
                            re += star;
                            hasMagic = true;
                            break;
                        case '?':
                            re += qmark;
                            hasMagic = true;
                            break;
                        default:
                            re += '\\' + stateChar;
                            break;
                        }
                        self.debug('clearStateChar %j %j', stateChar, re);
                        stateChar = false;
                    }
                }
                for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
                    this.debug('%s\t%s %s %j', pattern, i, re, c);
                    if (escaping && reSpecials[c]) {
                        re += '\\' + c;
                        escaping = false;
                        continue;
                    }
                    SWITCH:
                        switch (c) {
                        case '/':
                            return false;
                        case '\\':
                            clearStateChar();
                            escaping = true;
                            continue;
                        case '?':
                        case '*':
                        case '+':
                        case '@':
                        case '!':
                            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
                            if (inClass) {
                                this.debug('  in class');
                                if (c === '!' && i === classStart + 1)
                                    c = '^';
                                re += c;
                                continue;
                            }
                            self.debug('call clearStateChar %j', stateChar);
                            clearStateChar();
                            stateChar = c;
                            if (options.noext)
                                clearStateChar();
                            continue;
                        case '(':
                            if (inClass) {
                                re += '(';
                                continue;
                            }
                            if (!stateChar) {
                                re += '\\(';
                                continue;
                            }
                            plType = stateChar;
                            patternListStack.push({
                                type: plType,
                                start: i - 1,
                                reStart: re.length
                            });
                            re += stateChar === '!' ? '(?:(?!' : '(?:';
                            this.debug('plType %j %j', stateChar, re);
                            stateChar = false;
                            continue;
                        case ')':
                            if (inClass || !patternListStack.length) {
                                re += '\\)';
                                continue;
                            }
                            clearStateChar();
                            hasMagic = true;
                            re += ')';
                            plType = patternListStack.pop().type;
                            switch (plType) {
                            case '!':
                                re += '[^/]*?)';
                                break;
                            case '?':
                            case '+':
                            case '*':
                                re += plType;
                            case '@':
                                break;
                            }
                            continue;
                        case '|':
                            if (inClass || !patternListStack.length || escaping) {
                                re += '\\|';
                                escaping = false;
                                continue;
                            }
                            clearStateChar();
                            re += '|';
                            continue;
                        case '[':
                            clearStateChar();
                            if (inClass) {
                                re += '\\' + c;
                                continue;
                            }
                            inClass = true;
                            classStart = i;
                            reClassStart = re.length;
                            re += c;
                            continue;
                        case ']':
                            if (i === classStart + 1 || !inClass) {
                                re += '\\' + c;
                                escaping = false;
                                continue;
                            }
                            hasMagic = true;
                            inClass = false;
                            re += c;
                            continue;
                        default:
                            clearStateChar();
                            if (escaping) {
                                escaping = false;
                            } else if (reSpecials[c] && !(c === '^' && inClass)) {
                                re += '\\';
                            }
                            re += c;
                        }
                }
                if (inClass) {
                    var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);
                    re = re.substr(0, reClassStart) + '\\[' + sp[0];
                    hasMagic = hasMagic || sp[1];
                }
                var pl;
                while (pl = patternListStack.pop()) {
                    var tail = re.slice(pl.reStart + 3);
                    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
                        if (!$2) {
                            $2 = '\\';
                        }
                        return $1 + $1 + $2 + '|';
                    });
                    this.debug('tail=%j\n   %s', tail, tail);
                    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
                    hasMagic = true;
                    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
                }
                clearStateChar();
                if (escaping) {
                    re += '\\\\';
                }
                var addPatternStart = false;
                switch (re.charAt(0)) {
                case '.':
                case '[':
                case '(':
                    addPatternStart = true;
                }
                if (re !== '' && hasMagic)
                    re = '(?=.)' + re;
                if (addPatternStart)
                    re = patternStart + re;
                if (isSub === SUBPARSE) {
                    return [
                        re,
                        hasMagic
                    ];
                }
                if (!hasMagic) {
                    return globUnescape(pattern);
                }
                var flags = options.nocase ? 'i' : '', regExp = new RegExp('^' + re + '$', flags);
                regExp._glob = pattern;
                regExp._src = re;
                return regExp;
            }
            minimatch.makeRe = function (pattern, options) {
                return new Minimatch(pattern, options || {}).makeRe();
            };
            Minimatch.prototype.makeRe = makeRe;
            function makeRe() {
                if (this.regexp || this.regexp === false)
                    return this.regexp;
                var set = this.set;
                if (!set.length)
                    return this.regexp = false;
                var options = this.options;
                var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = options.nocase ? 'i' : '';
                var re = set.map(function (pattern) {
                    return pattern.map(function (p) {
                        return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
                    }).join('\\/');
                }).join('|');
                re = '^(?:' + re + ')$';
                if (this.negate)
                    re = '^(?!' + re + ').*$';
                try {
                    return this.regexp = new RegExp(re, flags);
                } catch (ex) {
                    return this.regexp = false;
                }
            }
            minimatch.match = function (list, pattern, options) {
                options = options || {};
                var mm = new Minimatch(pattern, options);
                list = list.filter(function (f) {
                    return mm.match(f);
                });
                if (mm.options.nonull && !list.length) {
                    list.push(pattern);
                }
                return list;
            };
            Minimatch.prototype.match = match;
            function match(f, partial) {
                this.debug('match', f, this.pattern);
                if (this.comment)
                    return false;
                if (this.empty)
                    return f === '';
                if (f === '/' && partial)
                    return true;
                var options = this.options;
                if (isWindows)
                    f = f.split('\\').join('/');
                f = f.split(slashSplit);
                this.debug(this.pattern, 'split', f);
                var set = this.set;
                this.debug(this.pattern, 'set', set);
                var filename;
                for (var i = f.length - 1; i >= 0; i--) {
                    filename = f[i];
                    if (filename)
                        break;
                }
                for (var i = 0, l = set.length; i < l; i++) {
                    var pattern = set[i], file = f;
                    if (options.matchBase && pattern.length === 1) {
                        file = [filename];
                    }
                    var hit = this.matchOne(file, pattern, partial);
                    if (hit) {
                        if (options.flipNegate)
                            return true;
                        return !this.negate;
                    }
                }
                if (options.flipNegate)
                    return false;
                return this.negate;
            }
            Minimatch.prototype.matchOne = function (file, pattern, partial) {
                var options = this.options;
                this.debug('matchOne', {
                    'this': this,
                    file: file,
                    pattern: pattern
                });
                this.debug('matchOne', file.length, pattern.length);
                for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
                    this.debug('matchOne loop');
                    var p = pattern[pi], f = file[fi];
                    this.debug(pattern, p, f);
                    if (p === false)
                        return false;
                    if (p === GLOBSTAR) {
                        this.debug('GLOBSTAR', [
                            pattern,
                            p,
                            f
                        ]);
                        var fr = fi, pr = pi + 1;
                        if (pr === pl) {
                            this.debug('** at the end');
                            for (; fi < fl; fi++) {
                                if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.')
                                    return false;
                            }
                            return true;
                        }
                        WHILE:
                            while (fr < fl) {
                                var swallowee = file[fr];
                                this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                                    this.debug('globstar found match!', fr, fl, swallowee);
                                    return true;
                                } else {
                                    if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
                                        this.debug('dot detected!', file, fr, pattern, pr);
                                        break WHILE;
                                    }
                                    this.debug('globstar swallow a segment, and continue');
                                    fr++;
                                }
                            }
                        if (partial) {
                            this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                            if (fr === fl)
                                return true;
                        }
                        return false;
                    }
                    var hit;
                    if (typeof p === 'string') {
                        if (options.nocase) {
                            hit = f.toLowerCase() === p.toLowerCase();
                        } else {
                            hit = f === p;
                        }
                        this.debug('string match', p, f, hit);
                    } else {
                        hit = f.match(p);
                        this.debug('pattern match', p, f, hit);
                    }
                    if (!hit)
                        return false;
                }
                if (fi === fl && pi === pl) {
                    return true;
                } else if (fi === fl) {
                    return partial;
                } else if (pi === pl) {
                    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
                    return emptyFileEnd;
                }
                throw new Error('wtf?');
            };
            function globUnescape(s) {
                return s.replace(/\\(.)/g, '$1');
            }
            function regExpEscape(s) {
                return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            }
        });
        _define(112, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
                var PromiseMap = Promise.map;
                Promise.prototype.filter = function Promise$filter(fn, options) {
                    return PromiseMap(this, fn, options, INTERNAL);
                };
                Promise.filter = function Promise$Filter(promises, fn, options) {
                    return PromiseMap(promises, fn, options, INTERNAL);
                };
            };
        });
        _define(113, function (module, exports) {
            'use strict';
            var path = require('path');
            var findIndex = require(141);
            var flattenGlob = function (arr) {
                var out = [];
                var flat = true;
                for (var i = 0; i < arr.length; i++) {
                    if (typeof arr[i] !== 'string') {
                        flat = false;
                        break;
                    }
                    out.push(arr[i]);
                }
                if (flat) {
                    out.pop();
                }
                return out;
            };
            var flattenExpansion = function (set) {
                var first = set[0];
                var toCompare = set.slice(1);
                var idx = findIndex(first, function (v, idx) {
                    if (typeof v !== 'string') {
                        return true;
                    }
                    var matched = toCompare.every(function (arr) {
                        return v === arr[idx];
                    });
                    return !matched;
                });
                return first.slice(0, idx);
            };
            var setToBase = function (set) {
                if (set.length <= 1) {
                    return flattenGlob(set[0]);
                }
                return flattenExpansion(set);
            };
            module.exports = function (glob) {
                var set = glob.minimatch.set;
                var baseParts = setToBase(set);
                var basePath = path.normalize(baseParts.join(path.sep)) + path.sep;
                return basePath;
            };
        });
        _define(114, function (module, exports) {
            'use strict';
            module.exports = function (Promise) {
                var SomePromiseArray = Promise._SomePromiseArray;
                function Promise$_Any(promises) {
                    var ret = new SomePromiseArray(promises);
                    var promise = ret.promise();
                    if (promise.isRejected()) {
                        return promise;
                    }
                    ret.setHowMany(1);
                    ret.setUnwrap();
                    ret.init();
                    return promise;
                }
                Promise.any = function Promise$Any(promises) {
                    return Promise$_Any(promises);
                };
                Promise.prototype.any = function Promise$any() {
                    return Promise$_Any(this);
                };
            };
        });
        _define(115, function (module, exports) {
            'use strict';
            var path = require('path');
            var helper = module.exports = {};
            helper.isDir = function isDir(dir) {
                if (typeof dir !== 'string') {
                    return false;
                }
                return dir.slice(-path.sep.length) === path.sep;
            };
            helper.objectPush = function objectPush(obj, key, val) {
                if (obj[key] == null) {
                    obj[key] = [];
                }
                if (Array.isArray(val)) {
                    obj[key] = obj[key].concat(val);
                } else if (val) {
                    obj[key].push(val);
                }
                return obj[key] = helper.unique(obj[key]);
            };
            helper.markDir = function markDir(dir) {
                if (typeof dir === 'string' && dir.slice(-path.sep.length) !== path.sep && dir !== '.') {
                    dir += path.sep;
                }
                return dir;
            };
            helper.unixifyPathSep = function unixifyPathSep(filepath) {
                return process.platform === 'win32' ? String(filepath).replace(/\\/g, '/') : filepath;
            };
            helper.unique = function unique() {
                var array = Array.prototype.concat.apply(Array.prototype, arguments);
                var result = [];
                for (var i = 0; i < array.length; i++) {
                    if (result.indexOf(array[i]) === -1) {
                        result.push(array[i]);
                    }
                }
                return result;
            };
            helper.forEachSeries = function forEachSeries(arr, iterator, callback) {
                if (!arr.length) {
                    return callback();
                }
                var completed = 0;
                var iterate = function () {
                    iterator(arr[completed], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {
                            };
                        } else {
                            completed += 1;
                            if (completed === arr.length) {
                                callback(null);
                            } else {
                                iterate();
                            }
                        }
                    });
                };
                iterate();
            };
        });
        _define(116, function (module, exports) {
            'use strict';
            module.exports = function (Promise, INTERNAL) {
                var PromiseReduce = Promise.reduce;
                Promise.prototype.each = function Promise$each(fn) {
                    return PromiseReduce(this, fn, null, INTERNAL);
                };
                Promise.each = function Promise$Each(promises, fn) {
                    return PromiseReduce(promises, fn, null, INTERNAL);
                };
            };
        });
        _define(117, function (module, exports) {
            'use strict';
            var fs = require('fs');
            var path = require('path');
            var _ = require(143);
            var glob = require(144);
            var minimatch = require(142);
            var globule = exports;
            function processPatterns(patterns, fn) {
                return _.flatten(patterns).reduce(function (result, pattern) {
                    if (pattern.indexOf('!') === 0) {
                        pattern = pattern.slice(1);
                        return _.difference(result, fn(pattern));
                    } else {
                        return _.union(result, fn(pattern));
                    }
                }, []);
            }
            globule.match = function (patterns, filepaths, options) {
                if (patterns == null || filepaths == null) {
                    return [];
                }
                if (!_.isArray(patterns)) {
                    patterns = [patterns];
                }
                if (!_.isArray(filepaths)) {
                    filepaths = [filepaths];
                }
                if (patterns.length === 0 || filepaths.length === 0) {
                    return [];
                }
                return processPatterns(patterns, function (pattern) {
                    return minimatch.match(filepaths, pattern, options || {});
                });
            };
            globule.isMatch = function () {
                return globule.match.apply(null, arguments).length > 0;
            };
            globule.find = function () {
                var args = _.toArray(arguments);
                var options = _.isPlainObject(args[args.length - 1]) ? args.pop() : {};
                var patterns = _.isArray(args[0]) ? args[0] : args;
                if (patterns.length === 0) {
                    return [];
                }
                var srcBase = options.srcBase || options.cwd;
                var globOptions = _.extend({}, options);
                if (srcBase) {
                    globOptions.cwd = srcBase;
                }
                var matches = processPatterns(patterns, function (pattern) {
                    return glob.sync(pattern, globOptions);
                });
                if (srcBase && options.prefixBase) {
                    matches = matches.map(function (filepath) {
                        return path.join(srcBase, filepath);
                    });
                }
                if (options.filter) {
                    matches = matches.filter(function (filepath) {
                        if (srcBase && !options.prefixBase) {
                            filepath = path.join(srcBase, filepath);
                        }
                        try {
                            if (_.isFunction(options.filter)) {
                                return options.filter(filepath, options);
                            } else {
                                return fs.statSync(filepath)[options.filter]();
                            }
                        } catch (err) {
                            return false;
                        }
                    });
                }
                return matches;
            };
            var pathSeparatorRe = /[\/\\]/g;
            var extDotRe = {
                first: /(\.[^\/]*)?$/,
                last: /(\.[^\/\.]*)?$/
            };
            function rename(dest, options) {
                if (options.flatten) {
                    dest = path.basename(dest);
                }
                if (options.ext) {
                    dest = dest.replace(extDotRe[options.extDot], options.ext);
                }
                if (options.destBase) {
                    dest = path.join(options.destBase, dest);
                }
                return dest;
            }
            globule.mapping = function (filepaths, options) {
                if (filepaths == null) {
                    return [];
                }
                options = _.defaults({}, options, {
                    extDot: 'first',
                    rename: rename
                });
                var files = [];
                var fileByDest = {};
                filepaths.forEach(function (src) {
                    var dest = options.rename(src, options);
                    if (options.srcBase) {
                        src = path.join(options.srcBase, src);
                    }
                    dest = dest.replace(pathSeparatorRe, '/');
                    src = src.replace(pathSeparatorRe, '/');
                    if (fileByDest[dest]) {
                        fileByDest[dest].src.push(src);
                    } else {
                        files.push({
                            src: [src],
                            dest: dest
                        });
                        fileByDest[dest] = files[files.length - 1];
                    }
                });
                return files;
            };
            globule.findMapping = function (patterns, options) {
                return globule.mapping(globule.find(patterns, options), options);
            };
        });
        _define(118, function (module, exports) {
            'use strict';
            module.exports = function (Promise, apiRejection, cast) {
                var TypeError = require(76).TypeError;
                var inherits = require(69).inherits;
                var PromiseInspection = Promise.PromiseInspection;
                function inspectionMapper(inspections) {
                    var len = inspections.length;
                    for (var i = 0; i < len; ++i) {
                        var inspection = inspections[i];
                        if (inspection.isRejected()) {
                            return Promise.reject(inspection.error());
                        }
                        inspections[i] = inspection.value();
                    }
                    return inspections;
                }
                function thrower(e) {
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }
                function castPreservingDisposable(thenable) {
                    var maybePromise = cast(thenable, void 0);
                    if (maybePromise !== thenable && typeof thenable._isDisposable === 'function' && typeof thenable._getDisposer === 'function' && thenable._isDisposable()) {
                        maybePromise._setDisposable(thenable._getDisposer());
                    }
                    return maybePromise;
                }
                function dispose(resources, inspection) {
                    var i = 0;
                    var len = resources.length;
                    var ret = Promise.defer();
                    function iterator() {
                        if (i >= len)
                            return ret.resolve();
                        var maybePromise = castPreservingDisposable(resources[i++]);
                        if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                            try {
                                maybePromise = cast(maybePromise._getDisposer().tryDispose(inspection), void 0);
                            } catch (e) {
                                return thrower(e);
                            }
                            if (maybePromise instanceof Promise) {
                                return maybePromise._then(iterator, thrower, null, null, null);
                            }
                        }
                        iterator();
                    }
                    iterator();
                    return ret.promise;
                }
                function disposerSuccess(value) {
                    var inspection = new PromiseInspection();
                    inspection._settledValue = value;
                    inspection._bitField = 268435456;
                    return dispose(this, inspection).thenReturn(value);
                }
                function disposerFail(reason) {
                    var inspection = new PromiseInspection();
                    inspection._settledValue = reason;
                    inspection._bitField = 134217728;
                    return dispose(this, inspection).thenThrow(reason);
                }
                function Disposer(data, promise) {
                    this._data = data;
                    this._promise = promise;
                }
                Disposer.prototype.data = function Disposer$data() {
                    return this._data;
                };
                Disposer.prototype.promise = function Disposer$promise() {
                    return this._promise;
                };
                Disposer.prototype.resource = function Disposer$resource() {
                    if (this.promise().isFulfilled()) {
                        return this.promise().value();
                    }
                    return null;
                };
                Disposer.prototype.tryDispose = function (inspection) {
                    var resource = this.resource();
                    var ret = resource !== null ? this.doDispose(resource, inspection) : null;
                    this._promise._unsetDisposable();
                    this._data = this._promise = null;
                    return ret;
                };
                Disposer.isDisposer = function Disposer$isDisposer(d) {
                    return d != null && typeof d.resource === 'function' && typeof d.tryDispose === 'function';
                };
                function FunctionDisposer(fn, promise) {
                    this.constructor$(fn, promise);
                }
                inherits(FunctionDisposer, Disposer);
                FunctionDisposer.prototype.doDispose = function (resource, inspection) {
                    var fn = this.data();
                    return fn.call(resource, resource, inspection);
                };
                Promise.using = function Promise$using() {
                    var len = arguments.length;
                    if (len < 2)
                        return apiRejection('you must pass at least 2 arguments to Promise.using');
                    var fn = arguments[len - 1];
                    if (typeof fn !== 'function')
                        return apiRejection('fn must be a function');
                    len--;
                    var resources = new Array(len);
                    for (var i = 0; i < len; ++i) {
                        var resource = arguments[i];
                        if (Disposer.isDisposer(resource)) {
                            var disposer = resource;
                            resource = resource.promise();
                            resource._setDisposable(disposer);
                        }
                        resources[i] = resource;
                    }
                    return Promise.settle(resources).then(inspectionMapper).spread(fn)._then(disposerSuccess, disposerFail, void 0, resources, void 0);
                };
                Promise.prototype._setDisposable = function Promise$_setDisposable(disposer) {
                    this._bitField = this._bitField | 262144;
                    this._disposer = disposer;
                };
                Promise.prototype._isDisposable = function Promise$_isDisposable() {
                    return (this._bitField & 262144) > 0;
                };
                Promise.prototype._getDisposer = function Promise$_getDisposer() {
                    return this._disposer;
                };
                Promise.prototype._unsetDisposable = function Promise$_unsetDisposable() {
                    this._bitField = this._bitField & ~262144;
                    this._disposer = void 0;
                };
                Promise.prototype.disposer = function Promise$disposer(fn) {
                    if (typeof fn === 'function') {
                        return new FunctionDisposer(fn, this);
                    }
                    throw new TypeError();
                };
            };
        });
        _define(119, function (module, exports) {
            'use strict';
            module.exports = function (Promise) {
                var TypeError = require(76).TypeError;
                function apiRejection(msg) {
                    var error = new TypeError(msg);
                    var ret = Promise.rejected(error);
                    var parent = ret._peekContext();
                    if (parent != null) {
                        parent._attachExtraTrace(error);
                    }
                    return ret;
                }
                return apiRejection;
            };
        });
        _define(120, function (module, exports) {
            module.exports = Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) == '[object Array]';
            };
        });
        _define(121, function (module, exports) {
            module.exports = require('util').inherits;
        });
        _define(122, function (module, exports) {
            function isArray(ar) {
                return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
                return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
                return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
                return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
                return typeof arg === 'number';
            }
            exports.isNumber = isNumber;
            function isString(arg) {
                return typeof arg === 'string';
            }
            exports.isString = isString;
            function isSymbol(arg) {
                return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
                return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
                return isObject(re) && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
                return isObject(d) && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;
            function isError(e) {
                return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
            }
            exports.isError = isError;
            function isFunction(arg) {
                return typeof arg === 'function';
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
                return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
            }
            exports.isPrimitive = isPrimitive;
            function isBuffer(arg) {
                return Buffer.isBuffer(arg);
            }
            exports.isBuffer = isBuffer;
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
        });
        _define(123, function (module, exports) {
            var Buffer = require('buffer').Buffer;
            var isBufferEncoding = Buffer.isEncoding || function (encoding) {
                switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                    return true;
                default:
                    return false;
                }
            };
            function assertEncoding(encoding) {
                if (encoding && !isBufferEncoding(encoding)) {
                    throw new Error('Unknown encoding: ' + encoding);
                }
            }
            var StringDecoder = exports.StringDecoder = function (encoding) {
                this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
                assertEncoding(encoding);
                switch (this.encoding) {
                case 'utf8':
                    this.surrogateSize = 3;
                    break;
                case 'ucs2':
                case 'utf16le':
                    this.surrogateSize = 2;
                    this.detectIncompleteChar = utf16DetectIncompleteChar;
                    break;
                case 'base64':
                    this.surrogateSize = 3;
                    this.detectIncompleteChar = base64DetectIncompleteChar;
                    break;
                default:
                    this.write = passThroughWrite;
                    return;
                }
                this.charBuffer = new Buffer(6);
                this.charReceived = 0;
                this.charLength = 0;
            };
            StringDecoder.prototype.write = function (buffer) {
                var charStr = '';
                while (this.charLength) {
                    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
                    buffer.copy(this.charBuffer, this.charReceived, 0, available);
                    this.charReceived += available;
                    if (this.charReceived < this.charLength) {
                        return '';
                    }
                    buffer = buffer.slice(available, buffer.length);
                    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
                    var charCode = charStr.charCodeAt(charStr.length - 1);
                    if (charCode >= 55296 && charCode <= 56319) {
                        this.charLength += this.surrogateSize;
                        charStr = '';
                        continue;
                    }
                    this.charReceived = this.charLength = 0;
                    if (buffer.length === 0) {
                        return charStr;
                    }
                    break;
                }
                this.detectIncompleteChar(buffer);
                var end = buffer.length;
                if (this.charLength) {
                    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                    end -= this.charReceived;
                }
                charStr += buffer.toString(this.encoding, 0, end);
                var end = charStr.length - 1;
                var charCode = charStr.charCodeAt(end);
                if (charCode >= 55296 && charCode <= 56319) {
                    var size = this.surrogateSize;
                    this.charLength += size;
                    this.charReceived += size;
                    this.charBuffer.copy(this.charBuffer, size, 0, size);
                    buffer.copy(this.charBuffer, 0, 0, size);
                    return charStr.substring(0, end);
                }
                return charStr;
            };
            StringDecoder.prototype.detectIncompleteChar = function (buffer) {
                var i = buffer.length >= 3 ? 3 : buffer.length;
                for (; i > 0; i--) {
                    var c = buffer[buffer.length - i];
                    if (i == 1 && c >> 5 == 6) {
                        this.charLength = 2;
                        break;
                    }
                    if (i <= 2 && c >> 4 == 14) {
                        this.charLength = 3;
                        break;
                    }
                    if (i <= 3 && c >> 3 == 30) {
                        this.charLength = 4;
                        break;
                    }
                }
                this.charReceived = i;
            };
            StringDecoder.prototype.end = function (buffer) {
                var res = '';
                if (buffer && buffer.length)
                    res = this.write(buffer);
                if (this.charReceived) {
                    var cr = this.charReceived;
                    var buf = this.charBuffer;
                    var enc = this.encoding;
                    res += buf.slice(0, cr).toString(enc);
                }
                return res;
            };
            function passThroughWrite(buffer) {
                return buffer.toString(this.encoding);
            }
            function utf16DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 2;
                this.charLength = this.charReceived ? 2 : 0;
            }
            function base64DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 3;
                this.charLength = this.charReceived ? 3 : 0;
            }
        });
        _define(124, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                var base64 = require(145);
                var VLQ_BASE_SHIFT = 5;
                var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
                var VLQ_BASE_MASK = VLQ_BASE - 1;
                var VLQ_CONTINUATION_BIT = VLQ_BASE;
                function toVLQSigned(aValue) {
                    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
                }
                function fromVLQSigned(aValue) {
                    var isNegative = (aValue & 1) === 1;
                    var shifted = aValue >> 1;
                    return isNegative ? -shifted : shifted;
                }
                exports.encode = function base64VLQ_encode(aValue) {
                    var encoded = '';
                    var digit;
                    var vlq = toVLQSigned(aValue);
                    do {
                        digit = vlq & VLQ_BASE_MASK;
                        vlq >>>= VLQ_BASE_SHIFT;
                        if (vlq > 0) {
                            digit |= VLQ_CONTINUATION_BIT;
                        }
                        encoded += base64.encode(digit);
                    } while (vlq > 0);
                    return encoded;
                };
                exports.decode = function base64VLQ_decode(aStr, aOutParam) {
                    var i = 0;
                    var strLen = aStr.length;
                    var result = 0;
                    var shift = 0;
                    var continuation, digit;
                    do {
                        if (i >= strLen) {
                            throw new Error('Expected more digits in base 64 VLQ value.');
                        }
                        digit = base64.decode(aStr.charAt(i++));
                        continuation = !!(digit & VLQ_CONTINUATION_BIT);
                        digit &= VLQ_BASE_MASK;
                        result = result + (digit << shift);
                        shift += VLQ_BASE_SHIFT;
                    } while (continuation);
                    aOutParam.value = fromVLQSigned(result);
                    aOutParam.rest = aStr.slice(i);
                };
            });
        });
        _define(125, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                function getArg(aArgs, aName, aDefaultValue) {
                    if (aName in aArgs) {
                        return aArgs[aName];
                    } else if (arguments.length === 3) {
                        return aDefaultValue;
                    } else {
                        throw new Error('"' + aName + '" is a required argument.');
                    }
                }
                exports.getArg = getArg;
                var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
                var dataUrlRegexp = /^data:.+\,.+$/;
                function urlParse(aUrl) {
                    var match = aUrl.match(urlRegexp);
                    if (!match) {
                        return null;
                    }
                    return {
                        scheme: match[1],
                        auth: match[2],
                        host: match[3],
                        port: match[4],
                        path: match[5]
                    };
                }
                exports.urlParse = urlParse;
                function urlGenerate(aParsedUrl) {
                    var url = '';
                    if (aParsedUrl.scheme) {
                        url += aParsedUrl.scheme + ':';
                    }
                    url += '//';
                    if (aParsedUrl.auth) {
                        url += aParsedUrl.auth + '@';
                    }
                    if (aParsedUrl.host) {
                        url += aParsedUrl.host;
                    }
                    if (aParsedUrl.port) {
                        url += ':' + aParsedUrl.port;
                    }
                    if (aParsedUrl.path) {
                        url += aParsedUrl.path;
                    }
                    return url;
                }
                exports.urlGenerate = urlGenerate;
                function normalize(aPath) {
                    var path = aPath;
                    var url = urlParse(aPath);
                    if (url) {
                        if (!url.path) {
                            return aPath;
                        }
                        path = url.path;
                    }
                    var isAbsolute = path.charAt(0) === '/';
                    var parts = path.split(/\/+/);
                    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
                        part = parts[i];
                        if (part === '.') {
                            parts.splice(i, 1);
                        } else if (part === '..') {
                            up++;
                        } else if (up > 0) {
                            if (part === '') {
                                parts.splice(i + 1, up);
                                up = 0;
                            } else {
                                parts.splice(i, 2);
                                up--;
                            }
                        }
                    }
                    path = parts.join('/');
                    if (path === '') {
                        path = isAbsolute ? '/' : '.';
                    }
                    if (url) {
                        url.path = path;
                        return urlGenerate(url);
                    }
                    return path;
                }
                exports.normalize = normalize;
                function join(aRoot, aPath) {
                    if (aRoot === '') {
                        aRoot = '.';
                    }
                    if (aPath === '') {
                        aPath = '.';
                    }
                    var aPathUrl = urlParse(aPath);
                    var aRootUrl = urlParse(aRoot);
                    if (aRootUrl) {
                        aRoot = aRootUrl.path || '/';
                    }
                    if (aPathUrl && !aPathUrl.scheme) {
                        if (aRootUrl) {
                            aPathUrl.scheme = aRootUrl.scheme;
                        }
                        return urlGenerate(aPathUrl);
                    }
                    if (aPathUrl || aPath.match(dataUrlRegexp)) {
                        return aPath;
                    }
                    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                        aRootUrl.host = aPath;
                        return urlGenerate(aRootUrl);
                    }
                    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
                    if (aRootUrl) {
                        aRootUrl.path = joined;
                        return urlGenerate(aRootUrl);
                    }
                    return joined;
                }
                exports.join = join;
                function relative(aRoot, aPath) {
                    if (aRoot === '') {
                        aRoot = '.';
                    }
                    aRoot = aRoot.replace(/\/$/, '');
                    var url = urlParse(aRoot);
                    if (aPath.charAt(0) == '/' && url && url.path == '/') {
                        return aPath.slice(1);
                    }
                    return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;
                }
                exports.relative = relative;
                function toSetString(aStr) {
                    return '$' + aStr;
                }
                exports.toSetString = toSetString;
                function fromSetString(aStr) {
                    return aStr.substr(1);
                }
                exports.fromSetString = fromSetString;
                function strcmp(aStr1, aStr2) {
                    var s1 = aStr1 || '';
                    var s2 = aStr2 || '';
                    return (s1 > s2) - (s1 < s2);
                }
                function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
                    var cmp;
                    cmp = strcmp(mappingA.source, mappingB.source);
                    if (cmp) {
                        return cmp;
                    }
                    cmp = mappingA.originalLine - mappingB.originalLine;
                    if (cmp) {
                        return cmp;
                    }
                    cmp = mappingA.originalColumn - mappingB.originalColumn;
                    if (cmp || onlyCompareOriginal) {
                        return cmp;
                    }
                    cmp = strcmp(mappingA.name, mappingB.name);
                    if (cmp) {
                        return cmp;
                    }
                    cmp = mappingA.generatedLine - mappingB.generatedLine;
                    if (cmp) {
                        return cmp;
                    }
                    return mappingA.generatedColumn - mappingB.generatedColumn;
                }
                ;
                exports.compareByOriginalPositions = compareByOriginalPositions;
                function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
                    var cmp;
                    cmp = mappingA.generatedLine - mappingB.generatedLine;
                    if (cmp) {
                        return cmp;
                    }
                    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
                    if (cmp || onlyCompareGenerated) {
                        return cmp;
                    }
                    cmp = strcmp(mappingA.source, mappingB.source);
                    if (cmp) {
                        return cmp;
                    }
                    cmp = mappingA.originalLine - mappingB.originalLine;
                    if (cmp) {
                        return cmp;
                    }
                    cmp = mappingA.originalColumn - mappingB.originalColumn;
                    if (cmp) {
                        return cmp;
                    }
                    return strcmp(mappingA.name, mappingB.name);
                }
                ;
                exports.compareByGeneratedPositions = compareByGeneratedPositions;
            });
        });
        _define(126, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                var util = require(125);
                function ArraySet() {
                    this._array = [];
                    this._set = {};
                }
                ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
                    var set = new ArraySet();
                    for (var i = 0, len = aArray.length; i < len; i++) {
                        set.add(aArray[i], aAllowDuplicates);
                    }
                    return set;
                };
                ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
                    var isDuplicate = this.has(aStr);
                    var idx = this._array.length;
                    if (!isDuplicate || aAllowDuplicates) {
                        this._array.push(aStr);
                    }
                    if (!isDuplicate) {
                        this._set[util.toSetString(aStr)] = idx;
                    }
                };
                ArraySet.prototype.has = function ArraySet_has(aStr) {
                    return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));
                };
                ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
                    if (this.has(aStr)) {
                        return this._set[util.toSetString(aStr)];
                    }
                    throw new Error('"' + aStr + '" is not in the set.');
                };
                ArraySet.prototype.at = function ArraySet_at(aIdx) {
                    if (aIdx >= 0 && aIdx < this._array.length) {
                        return this._array[aIdx];
                    }
                    throw new Error('No element indexed by ' + aIdx);
                };
                ArraySet.prototype.toArray = function ArraySet_toArray() {
                    return this._array.slice();
                };
                exports.ArraySet = ArraySet;
            });
        });
        _define(127, function (module, exports) {
            'use strict';
            function amdefine(module, requireFn) {
                'use strict';
                var defineCache = {}, loaderCache = {}, alreadyCalled = false, path = require('path'), makeRequire, stringRequire;
                function trimDots(ary) {
                    var i, part;
                    for (i = 0; ary[i]; i += 1) {
                        part = ary[i];
                        if (part === '.') {
                            ary.splice(i, 1);
                            i -= 1;
                        } else if (part === '..') {
                            if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                                break;
                            } else if (i > 0) {
                                ary.splice(i - 1, 2);
                                i -= 2;
                            }
                        }
                    }
                }
                function normalize(name, baseName) {
                    var baseParts;
                    if (name && name.charAt(0) === '.') {
                        if (baseName) {
                            baseParts = baseName.split('/');
                            baseParts = baseParts.slice(0, baseParts.length - 1);
                            baseParts = baseParts.concat(name.split('/'));
                            trimDots(baseParts);
                            name = baseParts.join('/');
                        }
                    }
                    return name;
                }
                function makeNormalize(relName) {
                    return function (name) {
                        return normalize(name, relName);
                    };
                }
                function makeLoad(id) {
                    function load(value) {
                        loaderCache[id] = value;
                    }
                    load.fromText = function (id, text) {
                        throw new Error('amdefine does not implement load.fromText');
                    };
                    return load;
                }
                makeRequire = function (systemRequire, exports, module, relId) {
                    function amdRequire(deps, callback) {
                        if (typeof deps === 'string') {
                            return stringRequire(systemRequire, exports, module, deps, relId);
                        } else {
                            deps = deps.map(function (depName) {
                                return stringRequire(systemRequire, exports, module, depName, relId);
                            });
                            process.nextTick(function () {
                                callback.apply(null, deps);
                            });
                        }
                    }
                    amdRequire.toUrl = function (filePath) {
                        if (filePath.indexOf('.') === 0) {
                            return normalize(filePath, path.dirname(module.filename));
                        } else {
                            return filePath;
                        }
                    };
                    return amdRequire;
                };
                requireFn = requireFn || function req() {
                    return module.require.apply(module, arguments);
                };
                function runFactory(id, deps, factory) {
                    var r, e, m, result;
                    if (id) {
                        e = loaderCache[id] = {};
                        m = {
                            id: id,
                            uri: __filename,
                            exports: e
                        };
                        r = makeRequire(requireFn, e, m, id);
                    } else {
                        if (alreadyCalled) {
                            throw new Error('amdefine with no module ID cannot be called more than once per file.');
                        }
                        alreadyCalled = true;
                        e = module.exports;
                        m = module;
                        r = makeRequire(requireFn, e, m, module.id);
                    }
                    if (deps) {
                        deps = deps.map(function (depName) {
                            return r(depName);
                        });
                    }
                    if (typeof factory === 'function') {
                        result = factory.apply(m.exports, deps);
                    } else {
                        result = factory;
                    }
                    if (result !== undefined) {
                        m.exports = result;
                        if (id) {
                            loaderCache[id] = m.exports;
                        }
                    }
                }
                stringRequire = function (systemRequire, exports, module, id, relId) {
                    var index = id.indexOf('!'), originalId = id, prefix, plugin;
                    if (index === -1) {
                        id = normalize(id, relId);
                        if (id === 'require') {
                            return makeRequire(systemRequire, exports, module, relId);
                        } else if (id === 'exports') {
                            return exports;
                        } else if (id === 'module') {
                            return module;
                        } else if (loaderCache.hasOwnProperty(id)) {
                            return loaderCache[id];
                        } else if (defineCache[id]) {
                            runFactory.apply(null, defineCache[id]);
                            return loaderCache[id];
                        } else {
                            if (systemRequire) {
                                return systemRequire(originalId);
                            } else {
                                throw new Error('No module with ID: ' + id);
                            }
                        }
                    } else {
                        prefix = id.substring(0, index);
                        id = id.substring(index + 1, id.length);
                        plugin = stringRequire(systemRequire, exports, module, prefix, relId);
                        if (plugin.normalize) {
                            id = plugin.normalize(id, makeNormalize(relId));
                        } else {
                            id = normalize(id, relId);
                        }
                        if (loaderCache[id]) {
                            return loaderCache[id];
                        } else {
                            plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
                            return loaderCache[id];
                        }
                    }
                };
                function define(id, deps, factory) {
                    if (Array.isArray(id)) {
                        factory = deps;
                        deps = id;
                        id = undefined;
                    } else if (typeof id !== 'string') {
                        factory = id;
                        id = deps = undefined;
                    }
                    if (deps && !Array.isArray(deps)) {
                        factory = deps;
                        deps = undefined;
                    }
                    if (!deps) {
                        deps = [
                            'require',
                            'exports',
                            'module'
                        ];
                    }
                    if (id) {
                        defineCache[id] = [
                            id,
                            deps,
                            factory
                        ];
                    } else {
                        runFactory(id, deps, factory);
                    }
                }
                define.require = function (id) {
                    if (loaderCache[id]) {
                        return loaderCache[id];
                    }
                    if (defineCache[id]) {
                        runFactory.apply(null, defineCache[id]);
                        return loaderCache[id];
                    }
                };
                define.amd = {};
                return define;
            }
            module.exports = amdefine;
        });
        _define(128, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
                    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
                    var cmp = aCompare(aNeedle, aHaystack[mid], true);
                    if (cmp === 0) {
                        return aHaystack[mid];
                    } else if (cmp > 0) {
                        if (aHigh - mid > 1) {
                            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
                        }
                        return aHaystack[mid];
                    } else {
                        if (mid - aLow > 1) {
                            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
                        }
                        return aLow < 0 ? null : aHaystack[aLow];
                    }
                }
                exports.search = function search(aNeedle, aHaystack, aCompare) {
                    return aHaystack.length > 0 ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare) : null;
                };
            });
        });
        _define(129, function (module, exports) {
            module.exports = Readable;
            var isArray = require(147);
            var Buffer = require('buffer').Buffer;
            Readable.ReadableState = ReadableState;
            var EE = require('events').EventEmitter;
            if (!EE.listenerCount)
                EE.listenerCount = function (emitter, type) {
                    return emitter.listeners(type).length;
                };
            var Stream = require('stream');
            var util = require(71);
            util.inherits = require(74);
            var StringDecoder;
            util.inherits(Readable, Stream);
            function ReadableState(options, stream) {
                options = options || {};
                var hwm = options.highWaterMark;
                this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
                this.highWaterMark = ~~this.highWaterMark;
                this.buffer = [];
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = false;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;
                this.calledRead = false;
                this.sync = true;
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.objectMode = !!options.objectMode;
                this.defaultEncoding = options.defaultEncoding || 'utf8';
                this.ranOut = false;
                this.awaitDrain = 0;
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                    if (!StringDecoder)
                        StringDecoder = require(146).StringDecoder;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                }
            }
            function Readable(options) {
                if (!(this instanceof Readable))
                    return new Readable(options);
                this._readableState = new ReadableState(options, this);
                this.readable = true;
                Stream.call(this);
            }
            Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState;
                if (typeof chunk === 'string' && !state.objectMode) {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                        chunk = new Buffer(chunk, encoding);
                        encoding = '';
                    }
                }
                return readableAddChunk(this, state, chunk, encoding, false);
            };
            Readable.prototype.unshift = function (chunk) {
                var state = this._readableState;
                return readableAddChunk(this, state, chunk, '', true);
            };
            function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                var er = chunkInvalid(state, chunk);
                if (er) {
                    stream.emit('error', er);
                } else if (chunk === null || chunk === undefined) {
                    state.reading = false;
                    if (!state.ended)
                        onEofChunk(stream, state);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (state.ended && !addToFront) {
                        var e = new Error('stream.push() after EOF');
                        stream.emit('error', e);
                    } else if (state.endEmitted && addToFront) {
                        var e = new Error('stream.unshift() after end event');
                        stream.emit('error', e);
                    } else {
                        if (state.decoder && !addToFront && !encoding)
                            chunk = state.decoder.write(chunk);
                        state.length += state.objectMode ? 1 : chunk.length;
                        if (addToFront) {
                            state.buffer.unshift(chunk);
                        } else {
                            state.reading = false;
                            state.buffer.push(chunk);
                        }
                        if (state.needReadable)
                            emitReadable(stream);
                        maybeReadMore(stream, state);
                    }
                } else if (!addToFront) {
                    state.reading = false;
                }
                return needMoreData(state);
            }
            function needMoreData(state) {
                return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
            }
            Readable.prototype.setEncoding = function (enc) {
                if (!StringDecoder)
                    StringDecoder = require(146).StringDecoder;
                this._readableState.decoder = new StringDecoder(enc);
                this._readableState.encoding = enc;
            };
            var MAX_HWM = 8388608;
            function roundUpToNextPowerOf2(n) {
                if (n >= MAX_HWM) {
                    n = MAX_HWM;
                } else {
                    n--;
                    for (var p = 1; p < 32; p <<= 1)
                        n |= n >> p;
                    n++;
                }
                return n;
            }
            function howMuchToRead(n, state) {
                if (state.length === 0 && state.ended)
                    return 0;
                if (state.objectMode)
                    return n === 0 ? 0 : 1;
                if (n === null || isNaN(n)) {
                    if (state.flowing && state.buffer.length)
                        return state.buffer[0].length;
                    else
                        return state.length;
                }
                if (n <= 0)
                    return 0;
                if (n > state.highWaterMark)
                    state.highWaterMark = roundUpToNextPowerOf2(n);
                if (n > state.length) {
                    if (!state.ended) {
                        state.needReadable = true;
                        return 0;
                    } else
                        return state.length;
                }
                return n;
            }
            Readable.prototype.read = function (n) {
                var state = this._readableState;
                state.calledRead = true;
                var nOrig = n;
                var ret;
                if (typeof n !== 'number' || n > 0)
                    state.emittedReadable = false;
                if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                    emitReadable(this);
                    return null;
                }
                n = howMuchToRead(n, state);
                if (n === 0 && state.ended) {
                    ret = null;
                    if (state.length > 0 && state.decoder) {
                        ret = fromList(n, state);
                        state.length -= ret.length;
                    }
                    if (state.length === 0)
                        endReadable(this);
                    return ret;
                }
                var doRead = state.needReadable;
                if (state.length - n <= state.highWaterMark)
                    doRead = true;
                if (state.ended || state.reading)
                    doRead = false;
                if (doRead) {
                    state.reading = true;
                    state.sync = true;
                    if (state.length === 0)
                        state.needReadable = true;
                    this._read(state.highWaterMark);
                    state.sync = false;
                }
                if (doRead && !state.reading)
                    n = howMuchToRead(nOrig, state);
                if (n > 0)
                    ret = fromList(n, state);
                else
                    ret = null;
                if (ret === null) {
                    state.needReadable = true;
                    n = 0;
                }
                state.length -= n;
                if (state.length === 0 && !state.ended)
                    state.needReadable = true;
                if (state.ended && !state.endEmitted && state.length === 0)
                    endReadable(this);
                return ret;
            };
            function chunkInvalid(state, chunk) {
                var er = null;
                if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {
                    er = new TypeError('Invalid non-string/buffer chunk');
                }
                return er;
            }
            function onEofChunk(stream, state) {
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                        state.buffer.push(chunk);
                        state.length += state.objectMode ? 1 : chunk.length;
                    }
                }
                state.ended = true;
                if (state.length > 0)
                    emitReadable(stream);
                else
                    endReadable(stream);
            }
            function emitReadable(stream) {
                var state = stream._readableState;
                state.needReadable = false;
                if (state.emittedReadable)
                    return;
                state.emittedReadable = true;
                if (state.sync)
                    process.nextTick(function () {
                        emitReadable_(stream);
                    });
                else
                    emitReadable_(stream);
            }
            function emitReadable_(stream) {
                stream.emit('readable');
            }
            function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                    state.readingMore = true;
                    process.nextTick(function () {
                        maybeReadMore_(stream, state);
                    });
                }
            }
            function maybeReadMore_(stream, state) {
                var len = state.length;
                while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                    stream.read(0);
                    if (len === state.length)
                        break;
                    else
                        len = state.length;
                }
                state.readingMore = false;
            }
            Readable.prototype._read = function (n) {
                this.emit('error', new Error('not implemented'));
            };
            Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                case 0:
                    state.pipes = dest;
                    break;
                case 1:
                    state.pipes = [
                        state.pipes,
                        dest
                    ];
                    break;
                default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                var endFn = doEnd ? onend : cleanup;
                if (state.endEmitted)
                    process.nextTick(endFn);
                else
                    src.once('end', endFn);
                dest.on('unpipe', onunpipe);
                function onunpipe(readable) {
                    if (readable !== src)
                        return;
                    cleanup();
                }
                function onend() {
                    dest.end();
                }
                var ondrain = pipeOnDrain(src);
                dest.on('drain', ondrain);
                function cleanup() {
                    dest.removeListener('close', onclose);
                    dest.removeListener('finish', onfinish);
                    dest.removeListener('drain', ondrain);
                    dest.removeListener('error', onerror);
                    dest.removeListener('unpipe', onunpipe);
                    src.removeListener('end', onend);
                    src.removeListener('end', cleanup);
                    if (!dest._writableState || dest._writableState.needDrain)
                        ondrain();
                }
                function onerror(er) {
                    unpipe();
                    dest.removeListener('error', onerror);
                    if (EE.listenerCount(dest, 'error') === 0)
                        dest.emit('error', er);
                }
                if (!dest._events || !dest._events.error)
                    dest.on('error', onerror);
                else if (isArray(dest._events.error))
                    dest._events.error.unshift(onerror);
                else
                    dest._events.error = [
                        onerror,
                        dest._events.error
                    ];
                function onclose() {
                    dest.removeListener('finish', onfinish);
                    unpipe();
                }
                dest.once('close', onclose);
                function onfinish() {
                    dest.removeListener('close', onclose);
                    unpipe();
                }
                dest.once('finish', onfinish);
                function unpipe() {
                    src.unpipe(dest);
                }
                dest.emit('pipe', src);
                if (!state.flowing) {
                    this.on('readable', pipeOnReadable);
                    state.flowing = true;
                    process.nextTick(function () {
                        flow(src);
                    });
                }
                return dest;
            };
            function pipeOnDrain(src) {
                return function () {
                    var dest = this;
                    var state = src._readableState;
                    state.awaitDrain--;
                    if (state.awaitDrain === 0)
                        flow(src);
                };
            }
            function flow(src) {
                var state = src._readableState;
                var chunk;
                state.awaitDrain = 0;
                function write(dest, i, list) {
                    var written = dest.write(chunk);
                    if (false === written) {
                        state.awaitDrain++;
                    }
                }
                while (state.pipesCount && null !== (chunk = src.read())) {
                    if (state.pipesCount === 1)
                        write(state.pipes, 0, null);
                    else
                        forEach(state.pipes, write);
                    src.emit('data', chunk);
                    if (state.awaitDrain > 0)
                        return;
                }
                if (state.pipesCount === 0) {
                    state.flowing = false;
                    if (EE.listenerCount(src, 'data') > 0)
                        emitDataEvents(src);
                    return;
                }
                state.ranOut = true;
            }
            function pipeOnReadable() {
                if (this._readableState.ranOut) {
                    this._readableState.ranOut = false;
                    flow(this);
                }
            }
            Readable.prototype.unpipe = function (dest) {
                var state = this._readableState;
                if (state.pipesCount === 0)
                    return this;
                if (state.pipesCount === 1) {
                    if (dest && dest !== state.pipes)
                        return this;
                    if (!dest)
                        dest = state.pipes;
                    state.pipes = null;
                    state.pipesCount = 0;
                    this.removeListener('readable', pipeOnReadable);
                    state.flowing = false;
                    if (dest)
                        dest.emit('unpipe', this);
                    return this;
                }
                if (!dest) {
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    this.removeListener('readable', pipeOnReadable);
                    state.flowing = false;
                    for (var i = 0; i < len; i++)
                        dests[i].emit('unpipe', this);
                    return this;
                }
                var i = indexOf(state.pipes, dest);
                if (i === -1)
                    return this;
                state.pipes.splice(i, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1)
                    state.pipes = state.pipes[0];
                dest.emit('unpipe', this);
                return this;
            };
            Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                if (ev === 'data' && !this._readableState.flowing)
                    emitDataEvents(this);
                if (ev === 'readable' && this.readable) {
                    var state = this._readableState;
                    if (!state.readableListening) {
                        state.readableListening = true;
                        state.emittedReadable = false;
                        state.needReadable = true;
                        if (!state.reading) {
                            this.read(0);
                        } else if (state.length) {
                            emitReadable(this, state);
                        }
                    }
                }
                return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.resume = function () {
                emitDataEvents(this);
                this.read(0);
                this.emit('resume');
            };
            Readable.prototype.pause = function () {
                emitDataEvents(this, true);
                this.emit('pause');
            };
            function emitDataEvents(stream, startPaused) {
                var state = stream._readableState;
                if (state.flowing) {
                    throw new Error('Cannot switch to old mode now.');
                }
                var paused = startPaused || false;
                var readable = false;
                stream.readable = true;
                stream.pipe = Stream.prototype.pipe;
                stream.on = stream.addListener = Stream.prototype.on;
                stream.on('readable', function () {
                    readable = true;
                    var c;
                    while (!paused && null !== (c = stream.read()))
                        stream.emit('data', c);
                    if (c === null) {
                        readable = false;
                        stream._readableState.needReadable = true;
                    }
                });
                stream.pause = function () {
                    paused = true;
                    this.emit('pause');
                };
                stream.resume = function () {
                    paused = false;
                    if (readable)
                        process.nextTick(function () {
                            stream.emit('readable');
                        });
                    else
                        this.read(0);
                    this.emit('resume');
                };
                stream.emit('readable');
            }
            Readable.prototype.wrap = function (stream) {
                var state = this._readableState;
                var paused = false;
                var self = this;
                stream.on('end', function () {
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length)
                            self.push(chunk);
                    }
                    self.push(null);
                });
                stream.on('data', function (chunk) {
                    if (state.decoder)
                        chunk = state.decoder.write(chunk);
                    if (state.objectMode && (chunk === null || chunk === undefined))
                        return;
                    else if (!state.objectMode && (!chunk || !chunk.length))
                        return;
                    var ret = self.push(chunk);
                    if (!ret) {
                        paused = true;
                        stream.pause();
                    }
                });
                for (var i in stream) {
                    if (typeof stream[i] === 'function' && typeof this[i] === 'undefined') {
                        this[i] = function (method) {
                            return function () {
                                return stream[method].apply(stream, arguments);
                            };
                        }(i);
                    }
                }
                var events = [
                    'error',
                    'close',
                    'destroy',
                    'pause',
                    'resume'
                ];
                forEach(events, function (ev) {
                    stream.on(ev, self.emit.bind(self, ev));
                });
                self._read = function (n) {
                    if (paused) {
                        paused = false;
                        stream.resume();
                    }
                };
                return self;
            };
            Readable._fromList = fromList;
            function fromList(n, state) {
                var list = state.buffer;
                var length = state.length;
                var stringMode = !!state.decoder;
                var objectMode = !!state.objectMode;
                var ret;
                if (list.length === 0)
                    return null;
                if (length === 0)
                    ret = null;
                else if (objectMode)
                    ret = list.shift();
                else if (!n || n >= length) {
                    if (stringMode)
                        ret = list.join('');
                    else
                        ret = Buffer.concat(list, length);
                    list.length = 0;
                } else {
                    if (n < list[0].length) {
                        var buf = list[0];
                        ret = buf.slice(0, n);
                        list[0] = buf.slice(n);
                    } else if (n === list[0].length) {
                        ret = list.shift();
                    } else {
                        if (stringMode)
                            ret = '';
                        else
                            ret = new Buffer(n);
                        var c = 0;
                        for (var i = 0, l = list.length; i < l && c < n; i++) {
                            var buf = list[0];
                            var cpy = Math.min(n - c, buf.length);
                            if (stringMode)
                                ret += buf.slice(0, cpy);
                            else
                                buf.copy(ret, c, 0, cpy);
                            if (cpy < buf.length)
                                list[0] = buf.slice(cpy);
                            else
                                list.shift();
                            c += cpy;
                        }
                    }
                }
                return ret;
            }
            function endReadable(stream) {
                var state = stream._readableState;
                if (state.length > 0)
                    throw new Error('endReadable called on non-empty stream');
                if (!state.endEmitted && state.calledRead) {
                    state.ended = true;
                    process.nextTick(function () {
                        if (!state.endEmitted && state.length === 0) {
                            state.endEmitted = true;
                            stream.readable = false;
                            stream.emit('end');
                        }
                    });
                }
            }
            function forEach(xs, f) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    f(xs[i], i);
                }
            }
            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x)
                        return i;
                }
                return -1;
            }
        });
        _define(130, function (module, exports) {
            module.exports = Writable;
            var Buffer = require('buffer').Buffer;
            Writable.WritableState = WritableState;
            var util = require(71);
            util.inherits = require(74);
            var Stream = require('stream');
            util.inherits(Writable, Stream);
            function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
            }
            function WritableState(options, stream) {
                options = options || {};
                var hwm = options.highWaterMark;
                this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
                this.objectMode = !!options.objectMode;
                this.highWaterMark = ~~this.highWaterMark;
                this.needDrain = false;
                this.ending = false;
                this.ended = false;
                this.finished = false;
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;
                this.defaultEncoding = options.defaultEncoding || 'utf8';
                this.length = 0;
                this.writing = false;
                this.sync = true;
                this.bufferProcessing = false;
                this.onwrite = function (er) {
                    onwrite(stream, er);
                };
                this.writecb = null;
                this.writelen = 0;
                this.buffer = [];
                this.errorEmitted = false;
            }
            function Writable(options) {
                var Duplex = require(67);
                if (!(this instanceof Writable) && !(this instanceof Duplex))
                    return new Writable(options);
                this._writableState = new WritableState(options, this);
                this.writable = true;
                Stream.call(this);
            }
            Writable.prototype.pipe = function () {
                this.emit('error', new Error('Cannot pipe. Not readable.'));
            };
            function writeAfterEnd(stream, state, cb) {
                var er = new Error('write after end');
                stream.emit('error', er);
                process.nextTick(function () {
                    cb(er);
                });
            }
            function validChunk(stream, state, chunk, cb) {
                var valid = true;
                if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {
                    var er = new TypeError('Invalid non-string/buffer chunk');
                    stream.emit('error', er);
                    process.nextTick(function () {
                        cb(er);
                    });
                    valid = false;
                }
                return valid;
            }
            Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }
                if (Buffer.isBuffer(chunk))
                    encoding = 'buffer';
                else if (!encoding)
                    encoding = state.defaultEncoding;
                if (typeof cb !== 'function')
                    cb = function () {
                    };
                if (state.ended)
                    writeAfterEnd(this, state, cb);
                else if (validChunk(this, state, chunk, cb))
                    ret = writeOrBuffer(this, state, chunk, encoding, cb);
                return ret;
            };
            function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
                    chunk = new Buffer(chunk, encoding);
                }
                return chunk;
            }
            function writeOrBuffer(stream, state, chunk, encoding, cb) {
                chunk = decodeChunk(state, chunk, encoding);
                if (Buffer.isBuffer(chunk))
                    encoding = 'buffer';
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark;
                if (!ret)
                    state.needDrain = true;
                if (state.writing)
                    state.buffer.push(new WriteReq(chunk, encoding, cb));
                else
                    doWrite(stream, state, len, chunk, encoding, cb);
                return ret;
            }
            function doWrite(stream, state, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
                if (sync)
                    process.nextTick(function () {
                        cb(er);
                    });
                else
                    cb(er);
                stream._writableState.errorEmitted = true;
                stream.emit('error', er);
            }
            function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
            }
            function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;
                onwriteStateUpdate(state);
                if (er)
                    onwriteError(stream, state, sync, er, cb);
                else {
                    var finished = needFinish(stream, state);
                    if (!finished && !state.bufferProcessing && state.buffer.length)
                        clearBuffer(stream, state);
                    if (sync) {
                        process.nextTick(function () {
                            afterWrite(stream, state, finished, cb);
                        });
                    } else {
                        afterWrite(stream, state, finished, cb);
                    }
                }
            }
            function afterWrite(stream, state, finished, cb) {
                if (!finished)
                    onwriteDrain(stream, state);
                cb();
                if (finished)
                    finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit('drain');
                }
            }
            function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                for (var c = 0; c < state.buffer.length; c++) {
                    var entry = state.buffer[c];
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream, state, len, chunk, encoding, cb);
                    if (state.writing) {
                        c++;
                        break;
                    }
                }
                state.bufferProcessing = false;
                if (c < state.buffer.length)
                    state.buffer = state.buffer.slice(c);
                else
                    state.buffer.length = 0;
            }
            Writable.prototype._write = function (chunk, encoding, cb) {
                cb(new Error('not implemented'));
            };
            Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState;
                if (typeof chunk === 'function') {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                } else if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }
                if (typeof chunk !== 'undefined' && chunk !== null)
                    this.write(chunk, encoding);
                if (!state.ending && !state.finished)
                    endWritable(this, state, cb);
            };
            function needFinish(stream, state) {
                return state.ending && state.length === 0 && !state.finished && !state.writing;
            }
            function finishMaybe(stream, state) {
                var need = needFinish(stream, state);
                if (need) {
                    state.finished = true;
                    stream.emit('finish');
                }
                return need;
            }
            function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                    if (state.finished)
                        process.nextTick(cb);
                    else
                        stream.once('finish', cb);
                }
                state.ended = true;
            }
        });
        _define(131, function (module, exports) {
            var isES5 = function () {
                'use strict';
                return this === void 0;
            }();
            if (isES5) {
                module.exports = {
                    freeze: Object.freeze,
                    defineProperty: Object.defineProperty,
                    keys: Object.keys,
                    getPrototypeOf: Object.getPrototypeOf,
                    isArray: Array.isArray,
                    isES5: isES5
                };
            } else {
                var has = {}.hasOwnProperty;
                var str = {}.toString;
                var proto = {}.constructor.prototype;
                var ObjectKeys = function ObjectKeys(o) {
                    var ret = [];
                    for (var key in o) {
                        if (has.call(o, key)) {
                            ret.push(key);
                        }
                    }
                    return ret;
                };
                var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
                    o[key] = desc.value;
                    return o;
                };
                var ObjectFreeze = function ObjectFreeze(obj) {
                    return obj;
                };
                var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
                    try {
                        return Object(obj).constructor.prototype;
                    } catch (e) {
                        return proto;
                    }
                };
                var ArrayIsArray = function ArrayIsArray(obj) {
                    try {
                        return str.call(obj) === '[object Array]';
                    } catch (e) {
                        return false;
                    }
                };
                module.exports = {
                    isArray: ArrayIsArray,
                    keys: ObjectKeys,
                    defineProperty: ObjectDefineProperty,
                    freeze: ObjectFreeze,
                    getPrototypeOf: ObjectGetPrototypeOf,
                    isES5: isES5
                };
            }
        });
        _define(132, function (module, exports) {
            'use strict';
            var schedule;
            var _MutationObserver;
            if (typeof process === 'object' && typeof process.version === 'string') {
                schedule = function Promise$_Scheduler(fn) {
                    process.nextTick(fn);
                };
            } else if (typeof MutationObserver !== 'undefined' && (_MutationObserver = MutationObserver) || typeof WebKitMutationObserver !== 'undefined' && (_MutationObserver = WebKitMutationObserver)) {
                schedule = function () {
                    var div = document.createElement('div');
                    var queuedFn = void 0;
                    var observer = new _MutationObserver(function Promise$_Scheduler() {
                        var fn = queuedFn;
                        queuedFn = void 0;
                        fn();
                    });
                    observer.observe(div, { attributes: true });
                    return function Promise$_Scheduler(fn) {
                        queuedFn = fn;
                        div.classList.toggle('foo');
                    };
                }();
            } else if (typeof setTimeout !== 'undefined') {
                schedule = function Promise$_Scheduler(fn) {
                    setTimeout(fn, 0);
                };
            } else
                throw new Error('no async scheduler available');
            module.exports = schedule;
        });
        _define(133, function (module, exports) {
            'use strict';
            function arrayCopy(src, srcIndex, dst, dstIndex, len) {
                for (var j = 0; j < len; ++j) {
                    dst[j + dstIndex] = src[j + srcIndex];
                }
            }
            function Queue(capacity) {
                this._capacity = capacity;
                this._length = 0;
                this._front = 0;
                this._makeCapacity();
            }
            Queue.prototype._willBeOverCapacity = function Queue$_willBeOverCapacity(size) {
                return this._capacity < size;
            };
            Queue.prototype._pushOne = function Queue$_pushOne(arg) {
                var length = this.length();
                this._checkCapacity(length + 1);
                var i = this._front + length & this._capacity - 1;
                this[i] = arg;
                this._length = length + 1;
            };
            Queue.prototype.push = function Queue$push(fn, receiver, arg) {
                var length = this.length() + 3;
                if (this._willBeOverCapacity(length)) {
                    this._pushOne(fn);
                    this._pushOne(receiver);
                    this._pushOne(arg);
                    return;
                }
                var j = this._front + length - 3;
                this._checkCapacity(length);
                var wrapMask = this._capacity - 1;
                this[j + 0 & wrapMask] = fn;
                this[j + 1 & wrapMask] = receiver;
                this[j + 2 & wrapMask] = arg;
                this._length = length;
            };
            Queue.prototype.shift = function Queue$shift() {
                var front = this._front, ret = this[front];
                this[front] = void 0;
                this._front = front + 1 & this._capacity - 1;
                this._length--;
                return ret;
            };
            Queue.prototype.length = function Queue$length() {
                return this._length;
            };
            Queue.prototype._makeCapacity = function Queue$_makeCapacity() {
                var len = this._capacity;
                for (var i = 0; i < len; ++i) {
                    this[i] = void 0;
                }
            };
            Queue.prototype._checkCapacity = function Queue$_checkCapacity(size) {
                if (this._capacity < size) {
                    this._resizeTo(this._capacity << 3);
                }
            };
            Queue.prototype._resizeTo = function Queue$_resizeTo(capacity) {
                var oldFront = this._front;
                var oldCapacity = this._capacity;
                var oldQueue = new Array(oldCapacity);
                var length = this.length();
                arrayCopy(this, 0, oldQueue, 0, oldCapacity);
                this._capacity = capacity;
                this._makeCapacity();
                this._front = 0;
                if (oldFront + length <= oldCapacity) {
                    arrayCopy(oldQueue, oldFront, this, 0, length);
                } else {
                    var lengthBeforeWrapping = length - (oldFront + length & oldCapacity - 1);
                    arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);
                    arrayCopy(oldQueue, 0, this, lengthBeforeWrapping, length - lengthBeforeWrapping);
                }
            };
            module.exports = Queue;
        });
        _define(134, function (module, exports) {
            'use strict';
            var isUtf8 = require(148);
            var stripBom = module.exports = function (arg) {
                if (typeof arg === 'string') {
                    return arg.replace(/^\ufeff/g, '');
                }
                if (Buffer.isBuffer(arg) && isUtf8(arg) && arg[0] === 239 && arg[1] === 187 && arg[2] === 191) {
                    return arg.slice(3);
                }
                return arg;
            };
            stripBom.stream = function () {
                var firstChunk = require(149);
                return firstChunk({ minSize: 3 }, function (chunk, enc, cb) {
                    this.push(stripBom(chunk));
                    cb();
                });
            };
        });
        _define(135, function (module, exports) {
            module.exports = globSync;
            globSync.GlobSync = GlobSync;
            var fs = require('fs');
            var minimatch = require(111);
            var Minimatch = minimatch.Minimatch;
            var Glob = require(108).Glob;
            var util = require('util');
            var path = require('path');
            var assert = require('assert');
            var common = require(136);
            var alphasort = common.alphasort;
            var isAbsolute = common.isAbsolute;
            var setopts = common.setopts;
            var ownProp = common.ownProp;
            function globSync(pattern, options) {
                if (typeof options === 'function' || arguments.length === 3)
                    throw new TypeError('callback provided to sync glob');
                return new GlobSync(pattern, options).found;
            }
            function GlobSync(pattern, options) {
                if (!pattern)
                    throw new Error('must provide pattern');
                if (typeof options === 'function' || arguments.length === 3)
                    throw new TypeError('callback provided to sync glob');
                if (!(this instanceof GlobSync))
                    return new GlobSync(pattern, options);
                setopts(this, pattern, options);
                if (this.noprocess)
                    return this;
                var n = this.minimatch.set.length;
                this.matches = new Array(n);
                for (var i = 0; i < n; i++) {
                    this._process(this.minimatch.set[i], i, false);
                }
                this._finish();
            }
            GlobSync.prototype._finish = function () {
                assert(this instanceof GlobSync);
                common.finish(this);
            };
            GlobSync.prototype._process = function (pattern, index, inGlobStar) {
                assert(this instanceof GlobSync);
                var n = 0;
                while (typeof pattern[n] === 'string') {
                    n++;
                }
                var prefix;
                switch (n) {
                case pattern.length:
                    this._processSimple(pattern.join('/'), index);
                    return;
                case 0:
                    prefix = null;
                    break;
                default:
                    prefix = pattern.slice(0, n).join('/');
                    break;
                }
                var remain = pattern.slice(n);
                var read;
                if (prefix === null)
                    read = '.';
                else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
                    if (!prefix || !isAbsolute(prefix))
                        prefix = '/' + prefix;
                    read = prefix;
                } else
                    read = prefix;
                var abs = this._makeAbs(read);
                var isGlobStar = remain[0] === minimatch.GLOBSTAR;
                if (isGlobStar)
                    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
                else
                    this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
            };
            GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
                var entries = this._readdir(abs, inGlobStar);
                if (!entries)
                    return;
                var pn = remain[0];
                var negate = !!this.minimatch.negate;
                var rawGlob = pn._glob;
                var dotOk = this.dot || rawGlob.charAt(0) === '.';
                var matchedEntries = [];
                for (var i = 0; i < entries.length; i++) {
                    var e = entries[i];
                    if (e.charAt(0) !== '.' || dotOk) {
                        var m;
                        if (negate && !prefix) {
                            m = !e.match(pn);
                        } else {
                            m = e.match(pn);
                        }
                        if (m)
                            matchedEntries.push(e);
                    }
                }
                var len = matchedEntries.length;
                if (len === 0)
                    return;
                if (remain.length === 1 && !this.mark && !this.stat) {
                    if (!this.matches[index])
                        this.matches[index] = Object.create(null);
                    for (var i = 0; i < len; i++) {
                        var e = matchedEntries[i];
                        if (prefix) {
                            if (prefix.slice(-1) !== '/')
                                e = prefix + '/' + e;
                            else
                                e = prefix + e;
                        }
                        if (e.charAt(0) === '/' && !this.nomount) {
                            e = path.join(this.root, e);
                        }
                        this.matches[index][e] = true;
                    }
                    return;
                }
                remain.shift();
                for (var i = 0; i < len; i++) {
                    var e = matchedEntries[i];
                    var newPattern;
                    if (prefix)
                        newPattern = [
                            prefix,
                            e
                        ];
                    else
                        newPattern = [e];
                    this._process(newPattern.concat(remain), index, inGlobStar);
                }
            };
            GlobSync.prototype._emitMatch = function (index, e) {
                if (!this.matches[index][e]) {
                    if (this.nodir) {
                        var c = this.cache[this._makeAbs(e)];
                        if (c === 'DIR' || Array.isArray(c))
                            return;
                    }
                    this.matches[index][e] = true;
                    if (this.stat || this.mark)
                        this._stat(this._makeAbs(e));
                }
            };
            GlobSync.prototype._readdirInGlobStar = function (abs) {
                var entries;
                var lstat;
                var stat;
                try {
                    lstat = fs.lstatSync(abs);
                } catch (er) {
                    return null;
                }
                var isSym = lstat.isSymbolicLink();
                this.symlinks[abs] = isSym;
                if (!isSym && !lstat.isDirectory())
                    this.cache[abs] = 'FILE';
                else
                    entries = this._readdir(abs, false);
                return entries;
            };
            GlobSync.prototype._readdir = function (abs, inGlobStar) {
                var entries;
                if (inGlobStar && !ownProp(this.symlinks, abs))
                    return this._readdirInGlobStar(abs);
                if (ownProp(this.cache, abs)) {
                    var c = this.cache[abs];
                    if (!c || c === 'FILE')
                        return null;
                    if (Array.isArray(c))
                        return c;
                }
                try {
                    return this._readdirEntries(abs, fs.readdirSync(abs).sort(alphasort));
                } catch (er) {
                    this._readdirError(abs, er);
                    return null;
                }
            };
            GlobSync.prototype._readdirEntries = function (abs, entries) {
                if (!this.mark && !this.stat) {
                    for (var i = 0; i < entries.length; i++) {
                        var e = entries[i];
                        if (abs === '/')
                            e = abs + e;
                        else
                            e = abs + '/' + e;
                        this.cache[e] = true;
                    }
                }
                this.cache[abs] = entries;
                return entries;
            };
            GlobSync.prototype._readdirError = function (f, er) {
                switch (er.code) {
                case 'ENOTDIR':
                    this.cache[f] = 'FILE';
                    break;
                case 'ENOENT':
                case 'ELOOP':
                case 'ENAMETOOLONG':
                case 'UNKNOWN':
                    this.cache[f] = false;
                    break;
                default:
                    this.cache[f] = false;
                    if (this.strict)
                        throw er;
                    if (!this.silent)
                        console.error('glob error', er);
                    break;
                }
            };
            GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
                var entries = this._readdir(abs, inGlobStar);
                if (!entries)
                    return;
                var remainWithoutGlobStar = remain.slice(1);
                var gspref = prefix ? [prefix] : [];
                var noGlobStar = gspref.concat(remainWithoutGlobStar);
                this._process(noGlobStar, index, false);
                var len = entries.length;
                var isSym = this.symlinks[abs];
                if (isSym && inGlobStar)
                    return;
                for (var i = 0; i < len; i++) {
                    var e = entries[i];
                    if (e.charAt(0) === '.' && !this.dot)
                        continue;
                    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
                    this._process(instead, index, true);
                    var below = gspref.concat(entries[i], remain);
                    this._process(below, index, true);
                }
            };
            GlobSync.prototype._processSimple = function (prefix, index) {
                var exists = this._stat(prefix);
                if (!this.matches[index])
                    this.matches[index] = Object.create(null);
                if (!exists)
                    return;
                if (prefix && isAbsolute(prefix) && !this.nomount) {
                    if (prefix.charAt(0) === '/') {
                        prefix = path.join(this.root, prefix);
                    } else {
                        prefix = path.resolve(this.root, prefix);
                    }
                }
                if (process.platform === 'win32')
                    prefix = prefix.replace(/\\/g, '/');
                this.matches[index][prefix] = true;
            };
            GlobSync.prototype._stat = function (f) {
                var abs = f;
                if (f.charAt(0) === '/')
                    abs = path.join(this.root, f);
                else if (this.changedCwd)
                    abs = path.resolve(this.cwd, f);
                if (f.length > this.maxLength)
                    return false;
                if (!this.stat && ownProp(this.cache, f)) {
                    var c = this.cache[f];
                    if (Array.isArray(c))
                        c = 'DIR';
                    if (abs.slice(-1) === '/' && c !== 'DIR')
                        return false;
                    return c;
                }
                var exists;
                var stat = this.statCache[abs];
                if (!stat) {
                    try {
                        stat = fs.statSync(abs);
                    } catch (er) {
                        return false;
                    }
                }
                this.statCache[abs] = stat;
                if (abs.slice(-1) === '/' && !stat.isDirectory())
                    return false;
                var c = stat.isDirectory() ? 'DIR' : 'FILE';
                this.cache[f] = this.cache[f] || c;
                return c;
            };
            GlobSync.prototype._mark = function (p) {
                return common.mark(this, p);
            };
            GlobSync.prototype._makeAbs = function (f) {
                return common.makeAbs(this, f);
            };
        });
        _define(136, function (module, exports) {
            exports.alphasort = alphasort;
            exports.alphasorti = alphasorti;
            exports.isAbsolute = process.platform === 'win32' ? absWin : absUnix;
            exports.setopts = setopts;
            exports.ownProp = ownProp;
            exports.makeAbs = makeAbs;
            exports.finish = finish;
            exports.mark = mark;
            function ownProp(obj, field) {
                return Object.prototype.hasOwnProperty.call(obj, field);
            }
            var path = require('path');
            var minimatch = require(111);
            var Minimatch = minimatch.Minimatch;
            function absWin(p) {
                if (absUnix(p))
                    return true;
                var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
                var result = splitDeviceRe.exec(p);
                var device = result[1] || '';
                var isUnc = device && device.charAt(1) !== ':';
                var isAbsolute = !!result[2] || isUnc;
                return isAbsolute;
            }
            function absUnix(p) {
                return p.charAt(0) === '/' || p === '';
            }
            function alphasorti(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            }
            function alphasort(a, b) {
                return a.localeCompare(b);
            }
            function setopts(self, pattern, options) {
                if (!options)
                    options = {};
                if (options.matchBase && -1 === pattern.indexOf('/')) {
                    if (options.noglobstar) {
                        throw new Error('base matching requires globstar');
                    }
                    pattern = '**/' + pattern;
                }
                self.pattern = pattern;
                self.strict = options.strict !== false;
                self.dot = !!options.dot;
                self.mark = !!options.mark;
                self.nodir = !!options.nodir;
                if (self.nodir)
                    self.mark = true;
                self.sync = !!options.sync;
                self.nounique = !!options.nounique;
                self.nonull = !!options.nonull;
                self.nosort = !!options.nosort;
                self.nocase = !!options.nocase;
                self.stat = !!options.stat;
                self.noprocess = !!options.noprocess;
                self.maxLength = options.maxLength || Infinity;
                self.cache = options.cache || Object.create(null);
                self.statCache = options.statCache || Object.create(null);
                self.symlinks = options.symlinks || Object.create(null);
                self.changedCwd = false;
                var cwd = process.cwd();
                if (!ownProp(options, 'cwd'))
                    self.cwd = cwd;
                else {
                    self.cwd = options.cwd;
                    self.changedCwd = path.resolve(options.cwd) !== cwd;
                }
                self.root = options.root || path.resolve(self.cwd, '/');
                self.root = path.resolve(self.root);
                if (process.platform === 'win32')
                    self.root = self.root.replace(/\\/g, '/');
                self.nomount = !!options.nomount;
                self.minimatch = new Minimatch(pattern, options);
                self.options = self.minimatch.options;
            }
            function finish(self) {
                var nou = self.nounique;
                var all = nou ? [] : Object.create(null);
                for (var i = 0, l = self.matches.length; i < l; i++) {
                    var matches = self.matches[i];
                    if (!matches) {
                        if (self.nonull) {
                            var literal = self.minimatch.globSet[i];
                            if (nou)
                                all.push(literal);
                            else
                                all[literal] = true;
                        }
                    } else {
                        var m = Object.keys(matches);
                        if (nou)
                            all.push.apply(all, m);
                        else
                            m.forEach(function (m) {
                                all[m] = true;
                            });
                    }
                }
                if (!nou)
                    all = Object.keys(all);
                if (!self.nosort)
                    all = all.sort(self.nocase ? alphasorti : alphasort);
                if (self.mark) {
                    for (var i = 0; i < all.length; i++) {
                        all[i] = self._mark(all[i]);
                    }
                    if (self.nodir) {
                        all = all.filter(function (e) {
                            return !/\/$/.test(e);
                        });
                    }
                }
                self.found = all;
            }
            function mark(self, p) {
                var c = self.cache[p];
                var m = p;
                if (c) {
                    var isDir = c === 'DIR' || Array.isArray(c);
                    var slash = p.slice(-1) === '/';
                    if (isDir && !slash)
                        m += '/';
                    else if (!isDir && slash)
                        m = m.slice(0, -1);
                    if (m !== p) {
                        self.statCache[m] = self.statCache[p];
                        self.cache[m] = self.cache[p];
                    }
                }
                return m;
            }
            function makeAbs(self, f) {
                var abs = f;
                if (f.charAt(0) === '/') {
                    abs = path.join(self.root, f);
                } else if (exports.isAbsolute(f)) {
                    abs = f;
                } else if (self.changedCwd) {
                    abs = path.resolve(self.cwd, f);
                }
                return abs;
            }
        });
        _define(137, function (module, exports) {
            var wrappy = require(150);
            module.exports = wrappy(once);
            once.proto = once(function () {
                Object.defineProperty(Function.prototype, 'once', {
                    value: function () {
                        return once(this);
                    },
                    configurable: true
                });
            });
            function once(fn) {
                var f = function () {
                    if (f.called)
                        return f.value;
                    f.called = true;
                    return f.value = fn.apply(this, arguments);
                };
                f.called = false;
                return f;
            }
        });
        _define(138, function (module, exports) {
            var wrappy = require(151);
            var reqs = Object.create(null);
            var once = require(137);
            module.exports = wrappy(inflight);
            function inflight(key, cb) {
                if (reqs[key]) {
                    reqs[key].push(cb);
                    return null;
                } else {
                    reqs[key] = [cb];
                    return makeres(key);
                }
            }
            function makeres(key) {
                return once(function RES() {
                    var cbs = reqs[key];
                    var len = cbs.length;
                    var args = slice(arguments);
                    for (var i = 0; i < len; i++) {
                        cbs[i].apply(null, args);
                    }
                    if (cbs.length > len) {
                        cbs.splice(0, len);
                        process.nextTick(function () {
                            RES.apply(null, args);
                        });
                    } else {
                        delete reqs[key];
                    }
                });
            }
            function slice(args) {
                var length = args.length;
                var array = [];
                for (var i = 0; i < length; i++)
                    array[i] = args[i];
                return array;
            }
        });
        _define(139, function (module, exports) {
            module.exports = require('util').inherits;
        });
        _define(140, function (module, exports) {
            var concatMap = require(152);
            var balanced = require(153);
            module.exports = expandTop;
            var escSlash = '\0SLASH' + Math.random() + '\0';
            var escOpen = '\0OPEN' + Math.random() + '\0';
            var escClose = '\0CLOSE' + Math.random() + '\0';
            var escComma = '\0COMMA' + Math.random() + '\0';
            var escPeriod = '\0PERIOD' + Math.random() + '\0';
            function numeric(str) {
                return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
            }
            function escapeBraces(str) {
                return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
            }
            function unescapeBraces(str) {
                return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
            }
            function parseCommaParts(str) {
                if (!str)
                    return [''];
                var parts = [];
                var m = balanced('{', '}', str);
                if (!m)
                    return str.split(',');
                var pre = m.pre;
                var body = m.body;
                var post = m.post;
                var p = pre.split(',');
                p[p.length - 1] += '{' + body + '}';
                var postParts = parseCommaParts(post);
                if (post.length) {
                    p[p.length - 1] += postParts.shift();
                    p.push.apply(p, postParts);
                }
                parts.push.apply(parts, p);
                return parts;
            }
            function expandTop(str) {
                if (!str)
                    return [];
                return expand(escapeBraces(str), true).map(unescapeBraces);
            }
            function identity(e) {
                return e;
            }
            function embrace(str) {
                return '{' + str + '}';
            }
            function isPadded(el) {
                return /^-?0\d/.test(el);
            }
            function lte(i, y) {
                return i <= y;
            }
            function gte(i, y) {
                return i >= y;
            }
            function expand(str, isTop) {
                var expansions = [];
                var m = balanced('{', '}', str);
                if (!m || /\$$/.test(m.pre))
                    return [str];
                var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
                var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
                var isSequence = isNumericSequence || isAlphaSequence;
                var isOptions = /^(.*,)+(.+)?$/.test(m.body);
                if (!isSequence && !isOptions) {
                    if (m.post.match(/,.*}/)) {
                        str = m.pre + '{' + m.body + escClose + m.post;
                        return expand(str);
                    }
                    return [str];
                }
                var n;
                if (isSequence) {
                    n = m.body.split(/\.\./);
                } else {
                    n = parseCommaParts(m.body);
                    if (n.length === 1) {
                        n = expand(n[0], false).map(embrace);
                        if (n.length === 1) {
                            var post = m.post.length ? expand(m.post, false) : [''];
                            return post.map(function (p) {
                                return m.pre + n[0] + p;
                            });
                        }
                    }
                }
                var pre = m.pre;
                var post = m.post.length ? expand(m.post, false) : [''];
                var N;
                if (isSequence) {
                    var x = numeric(n[0]);
                    var y = numeric(n[1]);
                    var width = Math.max(n[0].length, n[1].length);
                    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
                    var test = lte;
                    var reverse = y < x;
                    if (reverse) {
                        incr *= -1;
                        test = gte;
                    }
                    var pad = n.some(isPadded);
                    N = [];
                    for (var i = x; test(i, y); i += incr) {
                        var c;
                        if (isAlphaSequence) {
                            c = String.fromCharCode(i);
                            if (c === '\\')
                                c = '';
                        } else {
                            c = String(i);
                            if (pad) {
                                var need = width - c.length;
                                if (need > 0) {
                                    var z = new Array(need + 1).join('0');
                                    if (i < 0)
                                        c = '-' + z + c.slice(1);
                                    else
                                        c = z + c;
                                }
                            }
                        }
                        N.push(c);
                    }
                } else {
                    N = concatMap(n, function (el) {
                        return expand(el, false);
                    });
                }
                for (var j = 0; j < N.length; j++) {
                    for (var k = 0; k < post.length; k++) {
                        var expansion = pre + N[j] + post[k];
                        if (!isTop || isSequence || expansion)
                            expansions.push(expansion);
                    }
                }
                return expansions;
            }
        });
        _define(141, function (module, exports) {
            function findIndex(array, predicate, self) {
                var len = array.length;
                var i;
                if (len === 0)
                    return -1;
                if (typeof predicate !== 'function') {
                    throw new TypeError(predicate + ' must be a function');
                }
                if (self) {
                    for (i = 0; i < len; i++) {
                        if (predicate.call(self, array[i], i, array)) {
                            return i;
                        }
                    }
                } else {
                    for (i = 0; i < len; i++) {
                        if (predicate(array[i], i, array)) {
                            return i;
                        }
                    }
                }
                return -1;
            }
            module.exports = findIndex;
        });
        _define(142, function (module, exports) {
            ;
            (function (require, exports, module, platform) {
                if (module)
                    module.exports = minimatch;
                else
                    exports.minimatch = minimatch;
                if (!require) {
                    require = function (id) {
                        switch (id) {
                        case 'sigmund':
                            return function sigmund(obj) {
                                return JSON.stringify(obj);
                            };
                        case 'path':
                            return {
                                basename: function (f) {
                                    f = f.split(/[\/\\]/);
                                    var e = f.pop();
                                    if (!e)
                                        e = f.pop();
                                    return e;
                                }
                            };
                        case 'lru-cache':
                            return function LRUCache() {
                                var cache = {};
                                var cnt = 0;
                                this.set = function (k, v) {
                                    cnt++;
                                    if (cnt >= 100)
                                        cache = {};
                                    cache[k] = v;
                                };
                                this.get = function (k) {
                                    return cache[k];
                                };
                            };
                        }
                    };
                }
                minimatch.Minimatch = Minimatch;
                var LRU = require(154), cache = minimatch.cache = new LRU({ max: 100 }), GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, sigmund = require(155);
                var path = require('path'), qmark = '[^/]', star = qmark + '*?', twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?', twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?', reSpecials = charSet('().*{}+?[]^$\\!');
                function charSet(s) {
                    return s.split('').reduce(function (set, c) {
                        set[c] = true;
                        return set;
                    }, {});
                }
                var slashSplit = /\/+/;
                minimatch.filter = filter;
                function filter(pattern, options) {
                    options = options || {};
                    return function (p, i, list) {
                        return minimatch(p, pattern, options);
                    };
                }
                function ext(a, b) {
                    a = a || {};
                    b = b || {};
                    var t = {};
                    Object.keys(b).forEach(function (k) {
                        t[k] = b[k];
                    });
                    Object.keys(a).forEach(function (k) {
                        t[k] = a[k];
                    });
                    return t;
                }
                minimatch.defaults = function (def) {
                    if (!def || !Object.keys(def).length)
                        return minimatch;
                    var orig = minimatch;
                    var m = function minimatch(p, pattern, options) {
                        return orig.minimatch(p, pattern, ext(def, options));
                    };
                    m.Minimatch = function Minimatch(pattern, options) {
                        return new orig.Minimatch(pattern, ext(def, options));
                    };
                    return m;
                };
                Minimatch.defaults = function (def) {
                    if (!def || !Object.keys(def).length)
                        return Minimatch;
                    return minimatch.defaults(def).Minimatch;
                };
                function minimatch(p, pattern, options) {
                    if (typeof pattern !== 'string') {
                        throw new TypeError('glob pattern string required');
                    }
                    if (!options)
                        options = {};
                    if (!options.nocomment && pattern.charAt(0) === '#') {
                        return false;
                    }
                    if (pattern.trim() === '')
                        return p === '';
                    return new Minimatch(pattern, options).match(p);
                }
                function Minimatch(pattern, options) {
                    if (!(this instanceof Minimatch)) {
                        return new Minimatch(pattern, options, cache);
                    }
                    if (typeof pattern !== 'string') {
                        throw new TypeError('glob pattern string required');
                    }
                    if (!options)
                        options = {};
                    pattern = pattern.trim();
                    if (platform === 'win32') {
                        pattern = pattern.split('\\').join('/');
                    }
                    var cacheKey = pattern + '\n' + sigmund(options);
                    var cached = minimatch.cache.get(cacheKey);
                    if (cached)
                        return cached;
                    minimatch.cache.set(cacheKey, this);
                    this.options = options;
                    this.set = [];
                    this.pattern = pattern;
                    this.regexp = null;
                    this.negate = false;
                    this.comment = false;
                    this.empty = false;
                    this.make();
                }
                Minimatch.prototype.debug = function () {
                };
                Minimatch.prototype.make = make;
                function make() {
                    if (this._made)
                        return;
                    var pattern = this.pattern;
                    var options = this.options;
                    if (!options.nocomment && pattern.charAt(0) === '#') {
                        this.comment = true;
                        return;
                    }
                    if (!pattern) {
                        this.empty = true;
                        return;
                    }
                    this.parseNegate();
                    var set = this.globSet = this.braceExpand();
                    if (options.debug)
                        this.debug = console.error;
                    this.debug(this.pattern, set);
                    set = this.globParts = set.map(function (s) {
                        return s.split(slashSplit);
                    });
                    this.debug(this.pattern, set);
                    set = set.map(function (s, si, set) {
                        return s.map(this.parse, this);
                    }, this);
                    this.debug(this.pattern, set);
                    set = set.filter(function (s) {
                        return -1 === s.indexOf(false);
                    });
                    this.debug(this.pattern, set);
                    this.set = set;
                }
                Minimatch.prototype.parseNegate = parseNegate;
                function parseNegate() {
                    var pattern = this.pattern, negate = false, options = this.options, negateOffset = 0;
                    if (options.nonegate)
                        return;
                    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
                        negate = !negate;
                        negateOffset++;
                    }
                    if (negateOffset)
                        this.pattern = pattern.substr(negateOffset);
                    this.negate = negate;
                }
                minimatch.braceExpand = function (pattern, options) {
                    return new Minimatch(pattern, options).braceExpand();
                };
                Minimatch.prototype.braceExpand = braceExpand;
                function braceExpand(pattern, options) {
                    options = options || this.options;
                    pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
                    if (typeof pattern === 'undefined') {
                        throw new Error('undefined pattern');
                    }
                    if (options.nobrace || !pattern.match(/\{.*\}/)) {
                        return [pattern];
                    }
                    var escaping = false;
                    if (pattern.charAt(0) !== '{') {
                        this.debug(pattern);
                        var prefix = null;
                        for (var i = 0, l = pattern.length; i < l; i++) {
                            var c = pattern.charAt(i);
                            this.debug(i, c);
                            if (c === '\\') {
                                escaping = !escaping;
                            } else if (c === '{' && !escaping) {
                                prefix = pattern.substr(0, i);
                                break;
                            }
                        }
                        if (prefix === null) {
                            this.debug('no sets');
                            return [pattern];
                        }
                        var tail = braceExpand.call(this, pattern.substr(i), options);
                        return tail.map(function (t) {
                            return prefix + t;
                        });
                    }
                    var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/);
                    if (numset) {
                        this.debug('numset', numset[1], numset[2]);
                        var suf = braceExpand.call(this, pattern.substr(numset[0].length), options), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set = [];
                        for (var i = start; i != end + inc; i += inc) {
                            for (var ii = 0, ll = suf.length; ii < ll; ii++) {
                                set.push(i + suf[ii]);
                            }
                        }
                        return set;
                    }
                    var i = 1, depth = 1, set = [], member = '', sawEnd = false, escaping = false;
                    function addMember() {
                        set.push(member);
                        member = '';
                    }
                    this.debug('Entering for');
                    FOR:
                        for (i = 1, l = pattern.length; i < l; i++) {
                            var c = pattern.charAt(i);
                            this.debug('', i, c);
                            if (escaping) {
                                escaping = false;
                                member += '\\' + c;
                            } else {
                                switch (c) {
                                case '\\':
                                    escaping = true;
                                    continue;
                                case '{':
                                    depth++;
                                    member += '{';
                                    continue;
                                case '}':
                                    depth--;
                                    if (depth === 0) {
                                        addMember();
                                        i++;
                                        break FOR;
                                    } else {
                                        member += c;
                                        continue;
                                    }
                                case ',':
                                    if (depth === 1) {
                                        addMember();
                                    } else {
                                        member += c;
                                    }
                                    continue;
                                default:
                                    member += c;
                                    continue;
                                }
                            }
                        }
                    if (depth !== 0) {
                        this.debug('didn\'t close', pattern);
                        return braceExpand.call(this, '\\' + pattern, options);
                    }
                    this.debug('set', set);
                    this.debug('suffix', pattern.substr(i));
                    var suf = braceExpand.call(this, pattern.substr(i), options);
                    var addBraces = set.length === 1;
                    this.debug('set pre-expanded', set);
                    set = set.map(function (p) {
                        return braceExpand.call(this, p, options);
                    }, this);
                    this.debug('set expanded', set);
                    set = set.reduce(function (l, r) {
                        return l.concat(r);
                    });
                    if (addBraces) {
                        set = set.map(function (s) {
                            return '{' + s + '}';
                        });
                    }
                    var ret = [];
                    for (var i = 0, l = set.length; i < l; i++) {
                        for (var ii = 0, ll = suf.length; ii < ll; ii++) {
                            ret.push(set[i] + suf[ii]);
                        }
                    }
                    return ret;
                }
                Minimatch.prototype.parse = parse;
                var SUBPARSE = {};
                function parse(pattern, isSub) {
                    var options = this.options;
                    if (!options.noglobstar && pattern === '**')
                        return GLOBSTAR;
                    if (pattern === '')
                        return '';
                    var re = '', hasMagic = !!options.nocase, escaping = false, patternListStack = [], plType, stateChar, inClass = false, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))' : '(?!\\.)', self = this;
                    function clearStateChar() {
                        if (stateChar) {
                            switch (stateChar) {
                            case '*':
                                re += star;
                                hasMagic = true;
                                break;
                            case '?':
                                re += qmark;
                                hasMagic = true;
                                break;
                            default:
                                re += '\\' + stateChar;
                                break;
                            }
                            self.debug('clearStateChar %j %j', stateChar, re);
                            stateChar = false;
                        }
                    }
                    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
                        this.debug('%s\t%s %s %j', pattern, i, re, c);
                        if (escaping && reSpecials[c]) {
                            re += '\\' + c;
                            escaping = false;
                            continue;
                        }
                        SWITCH:
                            switch (c) {
                            case '/':
                                return false;
                            case '\\':
                                clearStateChar();
                                escaping = true;
                                continue;
                            case '?':
                            case '*':
                            case '+':
                            case '@':
                            case '!':
                                this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
                                if (inClass) {
                                    this.debug('  in class');
                                    if (c === '!' && i === classStart + 1)
                                        c = '^';
                                    re += c;
                                    continue;
                                }
                                self.debug('call clearStateChar %j', stateChar);
                                clearStateChar();
                                stateChar = c;
                                if (options.noext)
                                    clearStateChar();
                                continue;
                            case '(':
                                if (inClass) {
                                    re += '(';
                                    continue;
                                }
                                if (!stateChar) {
                                    re += '\\(';
                                    continue;
                                }
                                plType = stateChar;
                                patternListStack.push({
                                    type: plType,
                                    start: i - 1,
                                    reStart: re.length
                                });
                                re += stateChar === '!' ? '(?:(?!' : '(?:';
                                this.debug('plType %j %j', stateChar, re);
                                stateChar = false;
                                continue;
                            case ')':
                                if (inClass || !patternListStack.length) {
                                    re += '\\)';
                                    continue;
                                }
                                clearStateChar();
                                hasMagic = true;
                                re += ')';
                                plType = patternListStack.pop().type;
                                switch (plType) {
                                case '!':
                                    re += '[^/]*?)';
                                    break;
                                case '?':
                                case '+':
                                case '*':
                                    re += plType;
                                case '@':
                                    break;
                                }
                                continue;
                            case '|':
                                if (inClass || !patternListStack.length || escaping) {
                                    re += '\\|';
                                    escaping = false;
                                    continue;
                                }
                                clearStateChar();
                                re += '|';
                                continue;
                            case '[':
                                clearStateChar();
                                if (inClass) {
                                    re += '\\' + c;
                                    continue;
                                }
                                inClass = true;
                                classStart = i;
                                reClassStart = re.length;
                                re += c;
                                continue;
                            case ']':
                                if (i === classStart + 1 || !inClass) {
                                    re += '\\' + c;
                                    escaping = false;
                                    continue;
                                }
                                hasMagic = true;
                                inClass = false;
                                re += c;
                                continue;
                            default:
                                clearStateChar();
                                if (escaping) {
                                    escaping = false;
                                } else if (reSpecials[c] && !(c === '^' && inClass)) {
                                    re += '\\';
                                }
                                re += c;
                            }
                    }
                    if (inClass) {
                        var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);
                        re = re.substr(0, reClassStart) + '\\[' + sp[0];
                        hasMagic = hasMagic || sp[1];
                    }
                    var pl;
                    while (pl = patternListStack.pop()) {
                        var tail = re.slice(pl.reStart + 3);
                        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
                            if (!$2) {
                                $2 = '\\';
                            }
                            return $1 + $1 + $2 + '|';
                        });
                        this.debug('tail=%j\n   %s', tail, tail);
                        var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
                        hasMagic = true;
                        re = re.slice(0, pl.reStart) + t + '\\(' + tail;
                    }
                    clearStateChar();
                    if (escaping) {
                        re += '\\\\';
                    }
                    var addPatternStart = false;
                    switch (re.charAt(0)) {
                    case '.':
                    case '[':
                    case '(':
                        addPatternStart = true;
                    }
                    if (re !== '' && hasMagic)
                        re = '(?=.)' + re;
                    if (addPatternStart)
                        re = patternStart + re;
                    if (isSub === SUBPARSE) {
                        return [
                            re,
                            hasMagic
                        ];
                    }
                    if (!hasMagic) {
                        return globUnescape(pattern);
                    }
                    var flags = options.nocase ? 'i' : '', regExp = new RegExp('^' + re + '$', flags);
                    regExp._glob = pattern;
                    regExp._src = re;
                    return regExp;
                }
                minimatch.makeRe = function (pattern, options) {
                    return new Minimatch(pattern, options || {}).makeRe();
                };
                Minimatch.prototype.makeRe = makeRe;
                function makeRe() {
                    if (this.regexp || this.regexp === false)
                        return this.regexp;
                    var set = this.set;
                    if (!set.length)
                        return this.regexp = false;
                    var options = this.options;
                    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = options.nocase ? 'i' : '';
                    var re = set.map(function (pattern) {
                        return pattern.map(function (p) {
                            return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
                        }).join('\\/');
                    }).join('|');
                    re = '^(?:' + re + ')$';
                    if (this.negate)
                        re = '^(?!' + re + ').*$';
                    try {
                        return this.regexp = new RegExp(re, flags);
                    } catch (ex) {
                        return this.regexp = false;
                    }
                }
                minimatch.match = function (list, pattern, options) {
                    var mm = new Minimatch(pattern, options);
                    list = list.filter(function (f) {
                        return mm.match(f);
                    });
                    if (options.nonull && !list.length) {
                        list.push(pattern);
                    }
                    return list;
                };
                Minimatch.prototype.match = match;
                function match(f, partial) {
                    this.debug('match', f, this.pattern);
                    if (this.comment)
                        return false;
                    if (this.empty)
                        return f === '';
                    if (f === '/' && partial)
                        return true;
                    var options = this.options;
                    if (platform === 'win32') {
                        f = f.split('\\').join('/');
                    }
                    f = f.split(slashSplit);
                    this.debug(this.pattern, 'split', f);
                    var set = this.set;
                    this.debug(this.pattern, 'set', set);
                    var splitFile = path.basename(f.join('/')).split('/');
                    for (var i = 0, l = set.length; i < l; i++) {
                        var pattern = set[i], file = f;
                        if (options.matchBase && pattern.length === 1) {
                            file = splitFile;
                        }
                        var hit = this.matchOne(file, pattern, partial);
                        if (hit) {
                            if (options.flipNegate)
                                return true;
                            return !this.negate;
                        }
                    }
                    if (options.flipNegate)
                        return false;
                    return this.negate;
                }
                Minimatch.prototype.matchOne = function (file, pattern, partial) {
                    var options = this.options;
                    this.debug('matchOne', {
                        'this': this,
                        file: file,
                        pattern: pattern
                    });
                    this.debug('matchOne', file.length, pattern.length);
                    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
                        this.debug('matchOne loop');
                        var p = pattern[pi], f = file[fi];
                        this.debug(pattern, p, f);
                        if (p === false)
                            return false;
                        if (p === GLOBSTAR) {
                            this.debug('GLOBSTAR', [
                                pattern,
                                p,
                                f
                            ]);
                            var fr = fi, pr = pi + 1;
                            if (pr === pl) {
                                this.debug('** at the end');
                                for (; fi < fl; fi++) {
                                    if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.')
                                        return false;
                                }
                                return true;
                            }
                            WHILE:
                                while (fr < fl) {
                                    var swallowee = file[fr];
                                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                                        this.debug('globstar found match!', fr, fl, swallowee);
                                        return true;
                                    } else {
                                        if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
                                            this.debug('dot detected!', file, fr, pattern, pr);
                                            break WHILE;
                                        }
                                        this.debug('globstar swallow a segment, and continue');
                                        fr++;
                                    }
                                }
                            if (partial) {
                                this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                                if (fr === fl)
                                    return true;
                            }
                            return false;
                        }
                        var hit;
                        if (typeof p === 'string') {
                            if (options.nocase) {
                                hit = f.toLowerCase() === p.toLowerCase();
                            } else {
                                hit = f === p;
                            }
                            this.debug('string match', p, f, hit);
                        } else {
                            hit = f.match(p);
                            this.debug('pattern match', p, f, hit);
                        }
                        if (!hit)
                            return false;
                    }
                    if (fi === fl && pi === pl) {
                        return true;
                    } else if (fi === fl) {
                        return partial;
                    } else if (pi === pl) {
                        var emptyFileEnd = fi === fl - 1 && file[fi] === '';
                        return emptyFileEnd;
                    }
                    throw new Error('wtf?');
                };
                function globUnescape(s) {
                    return s.replace(/\\(.)/g, '$1');
                }
                function regExpEscape(s) {
                    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
                }
            }(typeof require === 'function' ? require : null, this, typeof module === 'object' ? module : null, typeof process === 'object' ? process.platform : 'win32'));
        });
        _define(143, function (module, exports) {
            ;
            (function (window, undefined) {
                var freeExports = typeof exports == 'object' && exports;
                var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
                var freeGlobal = typeof global == 'object' && global;
                if (freeGlobal.global === freeGlobal) {
                    window = freeGlobal;
                }
                var arrayRef = [], objectRef = {};
                var idCounter = 0;
                var indicatorObject = objectRef;
                var largeArraySize = 30;
                var oldDash = window._;
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reFlags = /\w*$/;
                var reNative = RegExp('^' + (objectRef.valueOf + '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/valueOf|for [^\]]+/g, '.+?') + '$');
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reNoMatch = /($^)/;
                var reUnescapedHtml = /[&<>"']/g;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var templateCounter = 0;
                var ceil = Math.ceil, concat = arrayRef.concat, floor = Math.floor, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectRef.hasOwnProperty, push = arrayRef.push, toString = objectRef.toString;
                var nativeBind = reNative.test(nativeBind = slice.bind) && nativeBind, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = window.isFinite, nativeIsNaN = window.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeRandom = Math.random;
                var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
                var isIeOpera = !!window.attachEvent, isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);
                var isBindFast = nativeBind && !isV8;
                var isKeysFast = nativeKeys && (isIeOpera || isV8);
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var ctorByClass = {};
                ctorByClass[arrayClass] = Array;
                ctorByClass[boolClass] = Boolean;
                ctorByClass[dateClass] = Date;
                ctorByClass[objectClass] = Object;
                ctorByClass[numberClass] = Number;
                ctorByClass[regexpClass] = RegExp;
                ctorByClass[stringClass] = String;
                var objectTypes = {
                    'boolean': false,
                    'function': true,
                    'object': true,
                    'number': false,
                    'string': false,
                    'undefined': false
                };
                var stringEscapes = {
                    '\\': '\\',
                    '\'': '\'',
                    '\n': 'n',
                    '\r': 'r',
                    '\t': 't',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };
                function lodash(value) {
                    if (value && typeof value == 'object' && value.__wrapped__) {
                        return value;
                    }
                    if (!(this instanceof lodash)) {
                        return new lodash(value);
                    }
                    this.__wrapped__ = value;
                }
                lodash.templateSettings = {
                    'escape': /<%-([\s\S]+?)%>/g,
                    'evaluate': /<%([\s\S]+?)%>/g,
                    'interpolate': reInterpolate,
                    'variable': '',
                    'imports': { '_': lodash }
                };
                var iteratorTemplate = function (obj) {
                    var __p = 'var index, iterable = ' + obj.firstArg + ', result = iterable;\nif (!iterable) return result;\n' + obj.top + ';\n';
                    if (obj.arrays) {
                        __p += 'var length = iterable.length; index = -1;\nif (' + obj.arrays + ') {\n  while (++index < length) {\n    ' + obj.loop + '\n  }\n}\nelse {  ';
                    }
                    ;
                    if (obj.isKeysFast && obj.useHas) {
                        __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] ? nativeKeys(iterable) : [],\n      length = ownProps.length;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n    ' + obj.loop + '\n  }  ';
                    } else {
                        __p += '\n  for (index in iterable) {';
                        if (obj.useHas) {
                            __p += '\n    if (';
                            if (obj.useHas) {
                                __p += 'hasOwnProperty.call(iterable, index)';
                            }
                            ;
                            __p += ') {    ';
                        }
                        ;
                        __p += obj.loop + ';    ';
                        if (obj.useHas) {
                            __p += '\n    }';
                        }
                        ;
                        __p += '\n  }  ';
                    }
                    ;
                    if (obj.arrays) {
                        __p += '\n}';
                    }
                    ;
                    __p += obj.bottom + ';\nreturn result';
                    return __p;
                };
                var defaultsIteratorOptions = {
                    'args': 'object, source, guard',
                    'top': 'var args = arguments,\n' + '    argsIndex = 0,\n' + '    argsLength = typeof guard == \'number\' ? 2 : args.length;\n' + 'while (++argsIndex < argsLength) {\n' + '  iterable = args[argsIndex];\n' + '  if (iterable && objectTypes[typeof iterable]) {',
                    'loop': 'if (typeof result[index] == \'undefined\') result[index] = iterable[index]',
                    'bottom': '  }\n}'
                };
                var eachIteratorOptions = {
                    'args': 'collection, callback, thisArg',
                    'top': 'callback = callback && typeof thisArg == \'undefined\' ? callback : createCallback(callback, thisArg)',
                    'arrays': 'typeof length == \'number\'',
                    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
                };
                var forOwnIteratorOptions = {
                    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
                    'arrays': false
                };
                function cachedContains(array, fromIndex, largeSize) {
                    fromIndex || (fromIndex = 0);
                    var length = array.length, isLarge = length - fromIndex >= (largeSize || largeArraySize);
                    if (isLarge) {
                        var cache = {}, index = fromIndex - 1;
                        while (++index < length) {
                            var key = array[index] + '';
                            (hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = []).push(array[index]);
                        }
                    }
                    return function (value) {
                        if (isLarge) {
                            var key = value + '';
                            return hasOwnProperty.call(cache, key) && indexOf(cache[key], value) > -1;
                        }
                        return indexOf(array, value, fromIndex) > -1;
                    };
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ai = a.index, bi = b.index;
                    a = a.criteria;
                    b = b.criteria;
                    if (a !== b) {
                        if (a > b || typeof a == 'undefined') {
                            return 1;
                        }
                        if (a < b || typeof b == 'undefined') {
                            return -1;
                        }
                    }
                    return ai < bi ? -1 : 1;
                }
                function createBound(func, thisArg, partialArgs, rightIndicator) {
                    var isFunc = isFunction(func), isPartial = !partialArgs, key = thisArg;
                    if (isPartial) {
                        partialArgs = thisArg;
                    }
                    if (!isFunc) {
                        thisArg = func;
                    }
                    function bound() {
                        var args = arguments, thisBinding = isPartial ? this : thisArg;
                        if (!isFunc) {
                            func = thisArg[key];
                        }
                        if (partialArgs.length) {
                            args = args.length ? (args = slice(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args)) : partialArgs;
                        }
                        if (this instanceof bound) {
                            noop.prototype = func.prototype;
                            thisBinding = new noop();
                            noop.prototype = null;
                            var result = func.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding;
                        }
                        return func.apply(thisBinding, args);
                    }
                    return bound;
                }
                function createCallback(func, thisArg, argCount) {
                    if (func == null) {
                        return identity;
                    }
                    var type = typeof func;
                    if (type != 'function') {
                        if (type != 'object') {
                            return function (object) {
                                return object[func];
                            };
                        }
                        var props = keys(func);
                        return function (object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    if (typeof thisArg != 'undefined') {
                        if (argCount === 1) {
                            return function (value) {
                                return func.call(thisArg, value);
                            };
                        }
                        if (argCount === 2) {
                            return function (a, b) {
                                return func.call(thisArg, a, b);
                            };
                        }
                        if (argCount === 4) {
                            return function (accumulator, value, index, object) {
                                return func.call(thisArg, accumulator, value, index, object);
                            };
                        }
                        return function (value, index, object) {
                            return func.call(thisArg, value, index, object);
                        };
                    }
                    return func;
                }
                function createIterator() {
                    var data = {
                        'isKeysFast': isKeysFast,
                        'arrays': 'isArray(iterable)',
                        'bottom': '',
                        'loop': '',
                        'top': '',
                        'useHas': true
                    };
                    for (var object, index = 0; object = arguments[index]; index++) {
                        for (var key in object) {
                            data[key] = object[key];
                        }
                    }
                    var args = data.args;
                    data.firstArg = /^[^,]+/.exec(args)[0];
                    var factory = Function('createCallback, hasOwnProperty, isArguments, isArray, isString, ' + 'objectTypes, nativeKeys', 'return function(' + args + ') {\n' + iteratorTemplate(data) + '\n}');
                    return factory(createCallback, hasOwnProperty, isArguments, isArray, isString, objectTypes, nativeKeys);
                }
                var each = createIterator(eachIteratorOptions);
                function escapeStringChar(match) {
                    return '\\' + stringEscapes[match];
                }
                function escapeHtmlChar(match) {
                    return htmlEscapes[match];
                }
                function isNode(value) {
                    return typeof value.toString != 'function' && typeof (value + '') == 'string';
                }
                function noop() {
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == 'undefined') {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function unescapeHtmlChar(match) {
                    return htmlUnescapes[match];
                }
                function isArguments(value) {
                    return toString.call(value) == argsClass;
                }
                var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, { 'useHas': false });
                var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
                var isArray = nativeIsArray || function (value) {
                    return value instanceof Array || toString.call(value) == arrayClass;
                };
                var keys = !nativeKeys ? shimKeys : function (object) {
                    if (!isObject(object)) {
                        return [];
                    }
                    return nativeKeys(object);
                };
                function shimIsPlainObject(value) {
                    var result = false;
                    if (!(value && typeof value == 'object') || isArguments(value)) {
                        return result;
                    }
                    var ctor = value.constructor;
                    if (!isFunction(ctor) || ctor instanceof ctor) {
                        forIn(value, function (value, key) {
                            result = key;
                        });
                        return result === false || hasOwnProperty.call(value, result);
                    }
                    return result;
                }
                function shimKeys(object) {
                    var result = [];
                    forOwn(object, function (value, key) {
                        result.push(key);
                    });
                    return result;
                }
                var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    '\'': '&#39;'
                };
                var htmlUnescapes = invert(htmlEscapes);
                var assign = createIterator(defaultsIteratorOptions, {
                    'top': defaultsIteratorOptions.top.replace(';', ';\n' + 'if (argsLength > 3 && typeof args[argsLength - 2] == \'function\') {\n' + '  var callback = createCallback(args[--argsLength - 1], args[argsLength--], 2);\n' + '} else if (argsLength > 2 && typeof args[argsLength - 1] == \'function\') {\n' + '  callback = args[--argsLength];\n' + '}'),
                    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
                });
                function clone(value, deep, callback, thisArg, stackA, stackB) {
                    var result = value;
                    if (typeof deep == 'function') {
                        thisArg = callback;
                        callback = deep;
                        deep = false;
                    }
                    if (typeof callback == 'function') {
                        callback = typeof thisArg == 'undefined' ? callback : createCallback(callback, thisArg, 1);
                        result = callback(result);
                        var done = typeof result != 'undefined';
                        if (!done) {
                            result = value;
                        }
                    }
                    var isObj = isObject(result);
                    if (isObj) {
                        var className = toString.call(result);
                        if (!cloneableClasses[className]) {
                            return result;
                        }
                        var isArr = isArray(result);
                    }
                    if (!isObj || !deep) {
                        return isObj && !done ? isArr ? slice(result) : assign({}, result) : result;
                    }
                    var ctor = ctorByClass[className];
                    switch (className) {
                    case boolClass:
                    case dateClass:
                        return done ? result : new ctor(+result);
                    case numberClass:
                    case stringClass:
                        return done ? result : new ctor(result);
                    case regexpClass:
                        return done ? result : ctor(result.source, reFlags.exec(result));
                    }
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    var length = stackA.length;
                    while (length--) {
                        if (stackA[length] == value) {
                            return stackB[length];
                        }
                    }
                    if (!done) {
                        result = isArr ? ctor(result.length) : {};
                        if (isArr) {
                            if (hasOwnProperty.call(value, 'index')) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, 'input')) {
                                result.input = value.input;
                            }
                        }
                    }
                    stackA.push(value);
                    stackB.push(result);
                    (isArr ? forEach : forOwn)(done ? result : value, function (objValue, key) {
                        result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
                    });
                    return result;
                }
                function cloneDeep(value, callback, thisArg) {
                    return clone(value, true, callback, thisArg);
                }
                var defaults = createIterator(defaultsIteratorOptions);
                function functions(object) {
                    var result = [];
                    forIn(object, function (value, key) {
                        if (isFunction(value)) {
                            result.push(key);
                        }
                    });
                    return result.sort();
                }
                function has(object, property) {
                    return object ? hasOwnProperty.call(object, property) : false;
                }
                function invert(object) {
                    var index = -1, props = keys(object), length = props.length, result = {};
                    while (++index < length) {
                        var key = props[index];
                        result[object[key]] = key;
                    }
                    return result;
                }
                function isBoolean(value) {
                    return value === true || value === false || toString.call(value) == boolClass;
                }
                function isDate(value) {
                    return value instanceof Date || toString.call(value) == dateClass;
                }
                function isElement(value) {
                    return value ? value.nodeType === 1 : false;
                }
                function isEmpty(value) {
                    var result = true;
                    if (!value) {
                        return result;
                    }
                    var className = toString.call(value), length = value.length;
                    if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
                        return !length;
                    }
                    forOwn(value, function () {
                        return result = false;
                    });
                    return result;
                }
                function isEqual(a, b, callback, thisArg, stackA, stackB) {
                    var whereIndicator = callback === indicatorObject;
                    if (callback && !whereIndicator) {
                        callback = typeof thisArg == 'undefined' ? callback : createCallback(callback, thisArg, 2);
                        var result = callback(a, b);
                        if (typeof result != 'undefined') {
                            return !!result;
                        }
                    }
                    if (a === b) {
                        return a !== 0 || 1 / a == 1 / b;
                    }
                    var type = typeof a, otherType = typeof b;
                    if (a === a && (!a || type != 'function' && type != 'object') && (!b || otherType != 'function' && otherType != 'object')) {
                        return false;
                    }
                    if (a == null || b == null) {
                        return a === b;
                    }
                    var className = toString.call(a), otherClass = toString.call(b);
                    if (className == argsClass) {
                        className = objectClass;
                    }
                    if (otherClass == argsClass) {
                        otherClass = objectClass;
                    }
                    if (className != otherClass) {
                        return false;
                    }
                    switch (className) {
                    case boolClass:
                    case dateClass:
                        return +a == +b;
                    case numberClass:
                        return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
                    case regexpClass:
                    case stringClass:
                        return a == b + '';
                    }
                    var isArr = className == arrayClass;
                    if (!isArr) {
                        if (a.__wrapped__ || b.__wrapped__) {
                            return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
                        }
                        if (className != objectClass) {
                            return false;
                        }
                        var ctorA = a.constructor, ctorB = b.constructor;
                        if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
                            return false;
                        }
                    }
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    var length = stackA.length;
                    while (length--) {
                        if (stackA[length] == a) {
                            return stackB[length] == b;
                        }
                    }
                    var size = 0;
                    result = true;
                    stackA.push(a);
                    stackB.push(b);
                    if (isArr) {
                        length = a.length;
                        size = b.length;
                        result = size == a.length;
                        if (!result && !whereIndicator) {
                            return result;
                        }
                        while (size--) {
                            var index = length, value = b[size];
                            if (whereIndicator) {
                                while (index--) {
                                    if (result = isEqual(a[index], value, callback, thisArg, stackA, stackB)) {
                                        break;
                                    }
                                }
                            } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
                                break;
                            }
                        }
                        return result;
                    }
                    forIn(b, function (value, key, b) {
                        if (hasOwnProperty.call(b, key)) {
                            size++;
                            return result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB);
                        }
                    });
                    if (result && !whereIndicator) {
                        forIn(a, function (value, key, a) {
                            if (hasOwnProperty.call(a, key)) {
                                return result = --size > -1;
                            }
                        });
                    }
                    return result;
                }
                function isFinite(value) {
                    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                }
                function isFunction(value) {
                    return typeof value == 'function';
                }
                if (isFunction(/x/)) {
                    isFunction = function (value) {
                        return value instanceof Function || toString.call(value) == funcClass;
                    };
                }
                function isObject(value) {
                    return value ? objectTypes[typeof value] : false;
                }
                function isNaN(value) {
                    return isNumber(value) && value != +value;
                }
                function isNull(value) {
                    return value === null;
                }
                function isNumber(value) {
                    return typeof value == 'number' || toString.call(value) == numberClass;
                }
                var isPlainObject = function (value) {
                    if (!(value && typeof value == 'object')) {
                        return false;
                    }
                    var valueOf = value.valueOf, objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                    return objProto ? value == objProto || getPrototypeOf(value) == objProto && !isArguments(value) : shimIsPlainObject(value);
                };
                function isRegExp(value) {
                    return value instanceof RegExp || toString.call(value) == regexpClass;
                }
                function isString(value) {
                    return typeof value == 'string' || toString.call(value) == stringClass;
                }
                function isUndefined(value) {
                    return typeof value == 'undefined';
                }
                function merge(object, source, deepIndicator) {
                    var args = arguments, index = 0, length = 2;
                    if (!isObject(object)) {
                        return object;
                    }
                    if (deepIndicator === indicatorObject) {
                        var callback = args[3], stackA = args[4], stackB = args[5];
                    } else {
                        stackA = [];
                        stackB = [];
                        if (typeof deepIndicator != 'number') {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == 'function') {
                            callback = createCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == 'function') {
                            callback = args[--length];
                        }
                    }
                    while (++index < length) {
                        (isArray(args[index]) ? forEach : forOwn)(args[index], function (source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    if (callback) {
                                        result = callback(value, source);
                                        if (typeof result != 'undefined') {
                                            value = result;
                                        }
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!callback) {
                                        value = merge(value, source, indicatorObject, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == 'undefined') {
                                        result = source;
                                    }
                                }
                                if (typeof result != 'undefined') {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    return object;
                }
                function omit(object, callback, thisArg) {
                    var isFunc = typeof callback == 'function', result = {};
                    if (isFunc) {
                        callback = createCallback(callback, thisArg);
                    } else {
                        var props = concat.apply(arrayRef, arguments);
                    }
                    forIn(object, function (value, key, object) {
                        if (isFunc ? !callback(value, key, object) : indexOf(props, key, 1) < 0) {
                            result[key] = value;
                        }
                    });
                    return result;
                }
                function pairs(object) {
                    var index = -1, props = keys(object), length = props.length, result = Array(length);
                    while (++index < length) {
                        var key = props[index];
                        result[index] = [
                            key,
                            object[key]
                        ];
                    }
                    return result;
                }
                function pick(object, callback, thisArg) {
                    var result = {};
                    if (typeof callback != 'function') {
                        var index = 0, props = concat.apply(arrayRef, arguments), length = isObject(object) ? props.length : 0;
                        while (++index < length) {
                            var key = props[index];
                            if (key in object) {
                                result[key] = object[key];
                            }
                        }
                    } else {
                        callback = createCallback(callback, thisArg);
                        forIn(object, function (value, key, object) {
                            if (callback(value, key, object)) {
                                result[key] = value;
                            }
                        });
                    }
                    return result;
                }
                function values(object) {
                    var index = -1, props = keys(object), length = props.length, result = Array(length);
                    while (++index < length) {
                        result[index] = object[props[index]];
                    }
                    return result;
                }
                function at(collection) {
                    var index = -1, props = concat.apply(arrayRef, slice(arguments, 1)), length = props.length, result = Array(length);
                    while (++index < length) {
                        result[index] = collection[props[index]];
                    }
                    return result;
                }
                function contains(collection, target, fromIndex) {
                    var index = -1, length = collection ? collection.length : 0, result = false;
                    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                    if (typeof length == 'number') {
                        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                    } else {
                        each(collection, function (value) {
                            if (++index >= fromIndex) {
                                return !(result = value === target);
                            }
                        });
                    }
                    return result;
                }
                function countBy(collection, callback, thisArg) {
                    var result = {};
                    callback = createCallback(callback, thisArg);
                    forEach(collection, function (value, key, collection) {
                        key = callback(value, key, collection) + '';
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    return result;
                }
                function every(collection, callback, thisArg) {
                    var result = true;
                    callback = createCallback(callback, thisArg);
                    if (isArray(collection)) {
                        var index = -1, length = collection.length;
                        while (++index < length) {
                            if (!(result = !!callback(collection[index], index, collection))) {
                                break;
                            }
                        }
                    } else {
                        each(collection, function (value, index, collection) {
                            return result = !!callback(value, index, collection);
                        });
                    }
                    return result;
                }
                function filter(collection, callback, thisArg) {
                    var result = [];
                    callback = createCallback(callback, thisArg);
                    if (isArray(collection)) {
                        var index = -1, length = collection.length;
                        while (++index < length) {
                            var value = collection[index];
                            if (callback(value, index, collection)) {
                                result.push(value);
                            }
                        }
                    } else {
                        each(collection, function (value, index, collection) {
                            if (callback(value, index, collection)) {
                                result.push(value);
                            }
                        });
                    }
                    return result;
                }
                function find(collection, callback, thisArg) {
                    var result;
                    callback = createCallback(callback, thisArg);
                    forEach(collection, function (value, index, collection) {
                        if (callback(value, index, collection)) {
                            result = value;
                            return false;
                        }
                    });
                    return result;
                }
                function forEach(collection, callback, thisArg) {
                    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
                        var index = -1, length = collection.length;
                        while (++index < length) {
                            if (callback(collection[index], index, collection) === false) {
                                break;
                            }
                        }
                    } else {
                        each(collection, callback, thisArg);
                    }
                    return collection;
                }
                function groupBy(collection, callback, thisArg) {
                    var result = {};
                    callback = createCallback(callback, thisArg);
                    forEach(collection, function (value, key, collection) {
                        key = callback(value, key, collection) + '';
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    return result;
                }
                function invoke(collection, methodName) {
                    var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                    forEach(collection, function (value) {
                        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                    });
                    return result;
                }
                function map(collection, callback, thisArg) {
                    var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                    callback = createCallback(callback, thisArg);
                    if (isArray(collection)) {
                        while (++index < length) {
                            result[index] = callback(collection[index], index, collection);
                        }
                    } else {
                        each(collection, function (value, key, collection) {
                            result[++index] = callback(value, key, collection);
                        });
                    }
                    return result;
                }
                function max(collection, callback, thisArg) {
                    var computed = -Infinity, result = computed;
                    if (!callback && isArray(collection)) {
                        var index = -1, length = collection.length;
                        while (++index < length) {
                            var value = collection[index];
                            if (value > result) {
                                result = value;
                            }
                        }
                    } else {
                        callback = !callback && isString(collection) ? charAtCallback : createCallback(callback, thisArg);
                        each(collection, function (value, index, collection) {
                            var current = callback(value, index, collection);
                            if (current > computed) {
                                computed = current;
                                result = value;
                            }
                        });
                    }
                    return result;
                }
                function min(collection, callback, thisArg) {
                    var computed = Infinity, result = computed;
                    if (!callback && isArray(collection)) {
                        var index = -1, length = collection.length;
                        while (++index < length) {
                            var value = collection[index];
                            if (value < result) {
                                result = value;
                            }
                        }
                    } else {
                        callback = !callback && isString(collection) ? charAtCallback : createCallback(callback, thisArg);
                        each(collection, function (value, index, collection) {
                            var current = callback(value, index, collection);
                            if (current < computed) {
                                computed = current;
                                result = value;
                            }
                        });
                    }
                    return result;
                }
                var pluck = map;
                function reduce(collection, callback, accumulator, thisArg) {
                    var noaccum = arguments.length < 3;
                    callback = createCallback(callback, thisArg, 4);
                    if (isArray(collection)) {
                        var index = -1, length = collection.length;
                        if (noaccum) {
                            accumulator = collection[++index];
                        }
                        while (++index < length) {
                            accumulator = callback(accumulator, collection[index], index, collection);
                        }
                    } else {
                        each(collection, function (value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                    }
                    return accumulator;
                }
                function reduceRight(collection, callback, accumulator, thisArg) {
                    var iterable = collection, length = collection ? collection.length : 0, noaccum = arguments.length < 3;
                    if (typeof length != 'number') {
                        var props = keys(collection);
                        length = props.length;
                    }
                    callback = createCallback(callback, thisArg, 4);
                    forEach(collection, function (value, index, collection) {
                        index = props ? props[--length] : --length;
                        accumulator = noaccum ? (noaccum = false, iterable[index]) : callback(accumulator, iterable[index], index, collection);
                    });
                    return accumulator;
                }
                function reject(collection, callback, thisArg) {
                    callback = createCallback(callback, thisArg);
                    return filter(collection, function (value, index, collection) {
                        return !callback(value, index, collection);
                    });
                }
                function shuffle(collection) {
                    var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                    forEach(collection, function (value) {
                        var rand = floor(nativeRandom() * (++index + 1));
                        result[index] = result[rand];
                        result[rand] = value;
                    });
                    return result;
                }
                function size(collection) {
                    var length = collection ? collection.length : 0;
                    return typeof length == 'number' ? length : keys(collection).length;
                }
                function some(collection, callback, thisArg) {
                    var result;
                    callback = createCallback(callback, thisArg);
                    if (isArray(collection)) {
                        var index = -1, length = collection.length;
                        while (++index < length) {
                            if (result = callback(collection[index], index, collection)) {
                                break;
                            }
                        }
                    } else {
                        each(collection, function (value, index, collection) {
                            return !(result = callback(value, index, collection));
                        });
                    }
                    return !!result;
                }
                function sortBy(collection, callback, thisArg) {
                    var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                    callback = createCallback(callback, thisArg);
                    forEach(collection, function (value, key, collection) {
                        result[++index] = {
                            'criteria': callback(value, key, collection),
                            'index': index,
                            'value': value
                        };
                    });
                    length = result.length;
                    result.sort(compareAscending);
                    while (length--) {
                        result[length] = result[length].value;
                    }
                    return result;
                }
                function toArray(collection) {
                    if (collection && typeof collection.length == 'number') {
                        return slice(collection);
                    }
                    return values(collection);
                }
                var where = filter;
                function compact(array) {
                    var index = -1, length = array ? array.length : 0, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (value) {
                            result.push(value);
                        }
                    }
                    return result;
                }
                function difference(array) {
                    var index = -1, length = array ? array.length : 0, flattened = concat.apply(arrayRef, arguments), contains = cachedContains(flattened, length), result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (!contains(value)) {
                            result.push(value);
                        }
                    }
                    return result;
                }
                function first(array, callback, thisArg) {
                    if (array) {
                        var n = 0, length = array.length;
                        if (typeof callback != 'number' && callback != null) {
                            var index = -1;
                            callback = createCallback(callback, thisArg);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array[0];
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                }
                function flatten(array, shallow) {
                    var index = -1, length = array ? array.length : 0, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (isArray(value)) {
                            push.apply(result, shallow ? value : flatten(value));
                        } else {
                            result.push(value);
                        }
                    }
                    return result;
                }
                function indexOf(array, value, fromIndex) {
                    var index = -1, length = array ? array.length : 0;
                    if (typeof fromIndex == 'number') {
                        index = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0) - 1;
                    } else if (fromIndex) {
                        index = sortedIndex(array, value);
                        return array[index] === value ? index : -1;
                    }
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function initial(array, callback, thisArg) {
                    if (!array) {
                        return [];
                    }
                    var n = 0, length = array.length;
                    if (typeof callback != 'number' && callback != null) {
                        var index = length;
                        callback = createCallback(callback, thisArg);
                        while (index-- && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback == null || thisArg ? 1 : callback || n;
                    }
                    return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                }
                function intersection(array) {
                    var args = arguments, argsLength = args.length, cache = { '0': {} }, index = -1, length = array ? array.length : 0, isLarge = length >= 100, result = [], seen = result;
                    outer:
                        while (++index < length) {
                            var value = array[index];
                            if (isLarge) {
                                var key = value + '';
                                var inited = hasOwnProperty.call(cache[0], key) ? !(seen = cache[0][key]) : seen = cache[0][key] = [];
                            }
                            if (inited || indexOf(seen, value) < 0) {
                                if (isLarge) {
                                    seen.push(value);
                                }
                                var argsIndex = argsLength;
                                while (--argsIndex) {
                                    if (!(cache[argsIndex] || (cache[argsIndex] = cachedContains(args[argsIndex], 0, 100)))(value)) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                    return result;
                }
                function last(array, callback, thisArg) {
                    if (array) {
                        var n = 0, length = array.length;
                        if (typeof callback != 'number' && callback != null) {
                            var index = length;
                            callback = createCallback(callback, thisArg);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array[length - 1];
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                }
                function lastIndexOf(array, value, fromIndex) {
                    var index = array ? array.length : 0;
                    if (typeof fromIndex == 'number') {
                        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                    }
                    while (index--) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function object(keys, values) {
                    var index = -1, length = keys ? keys.length : 0, result = {};
                    while (++index < length) {
                        var key = keys[index];
                        if (values) {
                            result[key] = values[index];
                        } else {
                            result[key[0]] = key[1];
                        }
                    }
                    return result;
                }
                function range(start, end, step) {
                    start = +start || 0;
                    step = +step || 1;
                    if (end == null) {
                        end = start;
                        start = 0;
                    }
                    var index = -1, length = nativeMax(0, ceil((end - start) / step)), result = Array(length);
                    while (++index < length) {
                        result[index] = start;
                        start += step;
                    }
                    return result;
                }
                function rest(array, callback, thisArg) {
                    if (typeof callback != 'number' && callback != null) {
                        var n = 0, index = -1, length = array ? array.length : 0;
                        callback = createCallback(callback, thisArg);
                        while (++index < length && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                    }
                    return slice(array, n);
                }
                function sortedIndex(array, value, callback, thisArg) {
                    var low = 0, high = array ? array.length : low;
                    callback = callback ? createCallback(callback, thisArg, 1) : identity;
                    value = callback(value);
                    while (low < high) {
                        var mid = low + high >>> 1;
                        callback(array[mid]) < value ? low = mid + 1 : high = mid;
                    }
                    return low;
                }
                function union() {
                    return uniq(concat.apply(arrayRef, arguments));
                }
                function uniq(array, isSorted, callback, thisArg) {
                    var index = -1, length = array ? array.length : 0, result = [], seen = result;
                    if (typeof isSorted == 'function') {
                        thisArg = callback;
                        callback = isSorted;
                        isSorted = false;
                    }
                    var isLarge = !isSorted && length >= 75;
                    if (isLarge) {
                        var cache = {};
                    }
                    if (callback) {
                        seen = [];
                        callback = createCallback(callback, thisArg);
                    }
                    while (++index < length) {
                        var value = array[index], computed = callback ? callback(value, index, array) : value;
                        if (isLarge) {
                            var key = computed + '';
                            var inited = hasOwnProperty.call(cache, key) ? !(seen = cache[key]) : seen = cache[key] = [];
                        }
                        if (isSorted ? !index || seen[seen.length - 1] !== computed : inited || indexOf(seen, computed) < 0) {
                            if (callback || isLarge) {
                                seen.push(computed);
                            }
                            result.push(value);
                        }
                    }
                    return result;
                }
                function without(array) {
                    var index = -1, length = array ? array.length : 0, contains = cachedContains(arguments, 1), result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (!contains(value)) {
                            result.push(value);
                        }
                    }
                    return result;
                }
                function zip(array) {
                    var index = -1, length = array ? max(pluck(arguments, 'length')) : 0, result = Array(length);
                    while (++index < length) {
                        result[index] = pluck(arguments, index);
                    }
                    return result;
                }
                function after(n, func) {
                    if (n < 1) {
                        return func();
                    }
                    return function () {
                        if (--n < 1) {
                            return func.apply(this, arguments);
                        }
                    };
                }
                function bind(func, thisArg) {
                    return isBindFast || nativeBind && arguments.length > 2 ? nativeBind.call.apply(nativeBind, arguments) : createBound(func, thisArg, slice(arguments, 2));
                }
                function bindAll(object) {
                    var funcs = concat.apply(arrayRef, arguments), index = funcs.length > 1 ? 0 : (funcs = functions(object), -1), length = funcs.length;
                    while (++index < length) {
                        var key = funcs[index];
                        object[key] = bind(object[key], object);
                    }
                    return object;
                }
                function bindKey(object, key) {
                    return createBound(object, key, slice(arguments, 2));
                }
                function compose() {
                    var funcs = arguments;
                    return function () {
                        var args = arguments, length = funcs.length;
                        while (length--) {
                            args = [funcs[length].apply(this, args)];
                        }
                        return args[0];
                    };
                }
                function debounce(func, wait, immediate) {
                    var args, result, thisArg, timeoutId;
                    function delayed() {
                        timeoutId = null;
                        if (!immediate) {
                            result = func.apply(thisArg, args);
                        }
                    }
                    return function () {
                        var isImmediate = immediate && !timeoutId;
                        args = arguments;
                        thisArg = this;
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(delayed, wait);
                        if (isImmediate) {
                            result = func.apply(thisArg, args);
                        }
                        return result;
                    };
                }
                function delay(func, wait) {
                    var args = slice(arguments, 2);
                    return setTimeout(function () {
                        func.apply(undefined, args);
                    }, wait);
                }
                function defer(func) {
                    var args = slice(arguments, 1);
                    return setTimeout(function () {
                        func.apply(undefined, args);
                    }, 1);
                }
                if (isV8 && freeModule && typeof setImmediate == 'function') {
                    defer = bind(setImmediate, window);
                }
                function memoize(func, resolver) {
                    var cache = {};
                    return function () {
                        var key = (resolver ? resolver.apply(this, arguments) : arguments[0]) + '';
                        return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                    };
                }
                function once(func) {
                    var ran, result;
                    return function () {
                        if (ran) {
                            return result;
                        }
                        ran = true;
                        result = func.apply(this, arguments);
                        func = null;
                        return result;
                    };
                }
                function partial(func) {
                    return createBound(func, slice(arguments, 1));
                }
                function partialRight(func) {
                    return createBound(func, slice(arguments, 1), null, indicatorObject);
                }
                function throttle(func, wait) {
                    var args, result, thisArg, timeoutId, lastCalled = 0;
                    function trailingCall() {
                        lastCalled = new Date();
                        timeoutId = null;
                        result = func.apply(thisArg, args);
                    }
                    return function () {
                        var now = new Date(), remaining = wait - (now - lastCalled);
                        args = arguments;
                        thisArg = this;
                        if (remaining <= 0) {
                            clearTimeout(timeoutId);
                            timeoutId = null;
                            lastCalled = now;
                            result = func.apply(thisArg, args);
                        } else if (!timeoutId) {
                            timeoutId = setTimeout(trailingCall, remaining);
                        }
                        return result;
                    };
                }
                function wrap(value, wrapper) {
                    return function () {
                        var args = [value];
                        push.apply(args, arguments);
                        return wrapper.apply(this, args);
                    };
                }
                function escape(string) {
                    return string == null ? '' : (string + '').replace(reUnescapedHtml, escapeHtmlChar);
                }
                function identity(value) {
                    return value;
                }
                function mixin(object) {
                    forEach(functions(object), function (methodName) {
                        var func = lodash[methodName] = object[methodName];
                        lodash.prototype[methodName] = function () {
                            var args = [this.__wrapped__];
                            push.apply(args, arguments);
                            return new lodash(func.apply(lodash, args));
                        };
                    });
                }
                function noConflict() {
                    window._ = oldDash;
                    return this;
                }
                function random(min, max) {
                    if (min == null && max == null) {
                        max = 1;
                    }
                    min = +min || 0;
                    if (max == null) {
                        max = min;
                        min = 0;
                    }
                    return min + floor(nativeRandom() * ((+max || 0) - min + 1));
                }
                function result(object, property) {
                    var value = object ? object[property] : undefined;
                    return isFunction(value) ? object[property]() : value;
                }
                function template(text, data, options) {
                    var settings = lodash.templateSettings;
                    text || (text = '');
                    options = defaults({}, options, settings);
                    var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                    var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
                    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
                    text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                        interpolateValue || (interpolateValue = esTemplateValue);
                        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                        if (escapeValue) {
                            source += '\' +\n__e(' + escapeValue + ') +\n\'';
                        }
                        if (evaluateValue) {
                            isEvaluating = true;
                            source += '\';\n' + evaluateValue + ';\n__p += \'';
                        }
                        if (interpolateValue) {
                            source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                        }
                        index = offset + match.length;
                        return match;
                    });
                    source += '\';\n';
                    var variable = options.variable, hasVariable = variable;
                    if (!hasVariable) {
                        variable = 'obj';
                        source = 'with (' + variable + ') {\n' + source + '\n}\n';
                    }
                    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
                    source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + 'var __t, __p = \'\', __e = _.escape' + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
                    var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
                    try {
                        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
                    } catch (e) {
                        e.source = source;
                        throw e;
                    }
                    if (data) {
                        return result(data);
                    }
                    result.source = source;
                    return result;
                }
                function times(n, callback, thisArg) {
                    n = +n || 0;
                    var index = -1, result = Array(n);
                    while (++index < n) {
                        result[index] = callback.call(thisArg, index);
                    }
                    return result;
                }
                function unescape(string) {
                    return string == null ? '' : (string + '').replace(reEscapedHtml, unescapeHtmlChar);
                }
                function uniqueId(prefix) {
                    var id = ++idCounter;
                    return (prefix == null ? '' : prefix + '') + id;
                }
                function tap(value, interceptor) {
                    interceptor(value);
                    return value;
                }
                function wrapperToString() {
                    return this.__wrapped__ + '';
                }
                function wrapperValueOf() {
                    return this.__wrapped__;
                }
                lodash.after = after;
                lodash.assign = assign;
                lodash.at = at;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.compact = compact;
                lodash.compose = compose;
                lodash.countBy = countBy;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.filter = filter;
                lodash.flatten = flatten;
                lodash.forEach = forEach;
                lodash.forIn = forIn;
                lodash.forOwn = forOwn;
                lodash.functions = functions;
                lodash.groupBy = groupBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.invert = invert;
                lodash.invoke = invoke;
                lodash.keys = keys;
                lodash.map = map;
                lodash.max = max;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.min = min;
                lodash.object = object;
                lodash.omit = omit;
                lodash.once = once;
                lodash.pairs = pairs;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.pick = pick;
                lodash.pluck = pluck;
                lodash.range = range;
                lodash.reject = reject;
                lodash.rest = rest;
                lodash.shuffle = shuffle;
                lodash.sortBy = sortBy;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.times = times;
                lodash.toArray = toArray;
                lodash.union = union;
                lodash.uniq = uniq;
                lodash.values = values;
                lodash.where = where;
                lodash.without = without;
                lodash.wrap = wrap;
                lodash.zip = zip;
                lodash.collect = map;
                lodash.drop = rest;
                lodash.each = forEach;
                lodash.extend = assign;
                lodash.methods = functions;
                lodash.select = filter;
                lodash.tail = rest;
                lodash.unique = uniq;
                mixin(lodash);
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.contains = contains;
                lodash.escape = escape;
                lodash.every = every;
                lodash.find = find;
                lodash.has = has;
                lodash.identity = identity;
                lodash.indexOf = indexOf;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isBoolean = isBoolean;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isNaN = isNaN;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isString = isString;
                lodash.isUndefined = isUndefined;
                lodash.lastIndexOf = lastIndexOf;
                lodash.mixin = mixin;
                lodash.noConflict = noConflict;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.result = result;
                lodash.size = size;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.template = template;
                lodash.unescape = unescape;
                lodash.uniqueId = uniqueId;
                lodash.all = every;
                lodash.any = some;
                lodash.detect = find;
                lodash.foldl = reduce;
                lodash.foldr = reduceRight;
                lodash.include = contains;
                lodash.inject = reduce;
                forOwn(lodash, function (func, methodName) {
                    if (!lodash.prototype[methodName]) {
                        lodash.prototype[methodName] = function () {
                            var args = [this.__wrapped__];
                            push.apply(args, arguments);
                            return func.apply(lodash, args);
                        };
                    }
                });
                lodash.first = first;
                lodash.last = last;
                lodash.take = first;
                lodash.head = first;
                forOwn(lodash, function (func, methodName) {
                    if (!lodash.prototype[methodName]) {
                        lodash.prototype[methodName] = function (callback, thisArg) {
                            var result = func(this.__wrapped__, callback, thisArg);
                            return callback == null || thisArg && typeof callback != 'function' ? result : new lodash(result);
                        };
                    }
                });
                lodash.VERSION = '1.0.1';
                lodash.prototype.toString = wrapperToString;
                lodash.prototype.value = wrapperValueOf;
                lodash.prototype.valueOf = wrapperValueOf;
                each([
                    'join',
                    'pop',
                    'shift'
                ], function (methodName) {
                    var func = arrayRef[methodName];
                    lodash.prototype[methodName] = function () {
                        return func.apply(this.__wrapped__, arguments);
                    };
                });
                each([
                    'push',
                    'reverse',
                    'sort',
                    'unshift'
                ], function (methodName) {
                    var func = arrayRef[methodName];
                    lodash.prototype[methodName] = function () {
                        func.apply(this.__wrapped__, arguments);
                        return this;
                    };
                });
                each([
                    'concat',
                    'slice',
                    'splice'
                ], function (methodName) {
                    var func = arrayRef[methodName];
                    lodash.prototype[methodName] = function () {
                        return new lodash(func.apply(this.__wrapped__, arguments));
                    };
                });
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    window._ = lodash;
                    define(function () {
                        return lodash;
                    });
                } else if (freeExports) {
                    if (freeModule) {
                        (freeModule.exports = lodash)._ = lodash;
                    } else {
                        freeExports._ = lodash;
                    }
                } else {
                    window._ = lodash;
                }
            }(this));
        });
        _define(144, function (module, exports) {
            module.exports = glob;
            var fs = require(156), minimatch = require(142), Minimatch = minimatch.Minimatch, inherits = require(157), EE = require('events').EventEmitter, path = require('path'), isDir = {}, assert = require('assert').ok;
            function glob(pattern, options, cb) {
                if (typeof options === 'function')
                    cb = options, options = {};
                if (!options)
                    options = {};
                if (typeof options === 'number') {
                    deprecated();
                    return;
                }
                var g = new Glob(pattern, options, cb);
                return g.sync ? g.found : g;
            }
            glob.fnmatch = deprecated;
            function deprecated() {
                throw new Error('glob\'s interface has changed. Please see the docs.');
            }
            glob.sync = globSync;
            function globSync(pattern, options) {
                if (typeof options === 'number') {
                    deprecated();
                    return;
                }
                options = options || {};
                options.sync = true;
                return glob(pattern, options);
            }
            glob.Glob = Glob;
            inherits(Glob, EE);
            function Glob(pattern, options, cb) {
                if (!(this instanceof Glob)) {
                    return new Glob(pattern, options, cb);
                }
                if (typeof cb === 'function') {
                    this.on('error', cb);
                    this.on('end', function (matches) {
                        cb(null, matches);
                    });
                }
                options = options || {};
                this.EOF = {};
                this._emitQueue = [];
                this.maxDepth = options.maxDepth || 1000;
                this.maxLength = options.maxLength || Infinity;
                this.statCache = options.statCache || {};
                this.changedCwd = false;
                var cwd = process.cwd();
                if (!options.hasOwnProperty('cwd'))
                    this.cwd = cwd;
                else {
                    this.cwd = options.cwd;
                    this.changedCwd = path.resolve(options.cwd) !== cwd;
                }
                this.root = options.root || path.resolve(this.cwd, '/');
                this.root = path.resolve(this.root);
                if (process.platform === 'win32')
                    this.root = this.root.replace(/\\/g, '/');
                this.nomount = !!options.nomount;
                if (!pattern) {
                    throw new Error('must provide pattern');
                }
                if (options.matchBase && -1 === pattern.indexOf('/')) {
                    if (options.noglobstar) {
                        throw new Error('base matching requires globstar');
                    }
                    pattern = '**/' + pattern;
                }
                this.strict = options.strict !== false;
                this.dot = !!options.dot;
                this.mark = !!options.mark;
                this.sync = !!options.sync;
                this.nounique = !!options.nounique;
                this.nonull = !!options.nonull;
                this.nosort = !!options.nosort;
                this.nocase = !!options.nocase;
                this.stat = !!options.stat;
                this.debug = !!options.debug || !!options.globDebug;
                if (this.debug)
                    this.log = console.error;
                this.silent = !!options.silent;
                var mm = this.minimatch = new Minimatch(pattern, options);
                this.options = mm.options;
                pattern = this.pattern = mm.pattern;
                this.error = null;
                this.aborted = false;
                EE.call(this);
                var n = this.minimatch.set.length;
                this.matches = new Array(n);
                this.minimatch.set.forEach(iterator.bind(this));
                function iterator(pattern, i, set) {
                    this._process(pattern, 0, i, function (er) {
                        if (er)
                            this.emit('error', er);
                        if (--n <= 0)
                            this._finish();
                    });
                }
            }
            Glob.prototype.log = function () {
            };
            Glob.prototype._finish = function () {
                assert(this instanceof Glob);
                var nou = this.nounique, all = nou ? [] : {};
                for (var i = 0, l = this.matches.length; i < l; i++) {
                    var matches = this.matches[i];
                    this.log('matches[%d] =', i, matches);
                    if (!matches) {
                        if (this.nonull) {
                            var literal = this.minimatch.globSet[i];
                            if (nou)
                                all.push(literal);
                            else
                                all[literal] = true;
                        }
                    } else {
                        var m = Object.keys(matches);
                        if (nou)
                            all.push.apply(all, m);
                        else
                            m.forEach(function (m) {
                                all[m] = true;
                            });
                    }
                }
                if (!nou)
                    all = Object.keys(all);
                if (!this.nosort) {
                    all = all.sort(this.nocase ? alphasorti : alphasort);
                }
                if (this.mark) {
                    all = all.map(function (m) {
                        var sc = this.statCache[m];
                        if (!sc)
                            return m;
                        var isDir = Array.isArray(sc) || sc === 2;
                        if (isDir && m.slice(-1) !== '/') {
                            return m + '/';
                        }
                        if (!isDir && m.slice(-1) === '/') {
                            return m.replace(/\/+$/, '');
                        }
                        return m;
                    }, this);
                }
                this.log('emitting end', all);
                this.EOF = this.found = all;
                this.emitMatch(this.EOF);
            };
            function alphasorti(a, b) {
                a = a.toLowerCase();
                b = b.toLowerCase();
                return alphasort(a, b);
            }
            function alphasort(a, b) {
                return a > b ? 1 : a < b ? -1 : 0;
            }
            Glob.prototype.abort = function () {
                this.aborted = true;
                this.emit('abort');
            };
            Glob.prototype.pause = function () {
                if (this.paused)
                    return;
                if (this.sync)
                    this.emit('error', new Error('Can\'t pause/resume sync glob'));
                this.paused = true;
                this.emit('pause');
            };
            Glob.prototype.resume = function () {
                if (!this.paused)
                    return;
                if (this.sync)
                    this.emit('error', new Error('Can\'t pause/resume sync glob'));
                this.paused = false;
                this.emit('resume');
                this._processEmitQueue();
            };
            Glob.prototype.emitMatch = function (m) {
                this._emitQueue.push(m);
                this._processEmitQueue();
            };
            Glob.prototype._processEmitQueue = function (m) {
                while (!this._processingEmitQueue && !this.paused) {
                    this._processingEmitQueue = true;
                    var m = this._emitQueue.shift();
                    if (!m) {
                        this._processingEmitQueue = false;
                        break;
                    }
                    this.log('emit!', m === this.EOF ? 'end' : 'match');
                    this.emit(m === this.EOF ? 'end' : 'match', m);
                    this._processingEmitQueue = false;
                }
            };
            Glob.prototype._process = function (pattern, depth, index, cb_) {
                assert(this instanceof Glob);
                var cb = function cb(er, res) {
                    assert(this instanceof Glob);
                    if (this.paused) {
                        if (!this._processQueue) {
                            this._processQueue = [];
                            this.once('resume', function () {
                                var q = this._processQueue;
                                this._processQueue = null;
                                q.forEach(function (cb) {
                                    cb();
                                });
                            });
                        }
                        this._processQueue.push(cb_.bind(this, er, res));
                    } else {
                        cb_.call(this, er, res);
                    }
                }.bind(this);
                if (this.aborted)
                    return cb();
                if (depth > this.maxDepth)
                    return cb();
                var n = 0;
                while (typeof pattern[n] === 'string') {
                    n++;
                }
                var prefix;
                switch (n) {
                case pattern.length:
                    prefix = pattern.join('/');
                    this._stat(prefix, function (exists, isDir) {
                        if (exists) {
                            if (prefix && isAbsolute(prefix) && !this.nomount) {
                                if (prefix.charAt(0) === '/') {
                                    prefix = path.join(this.root, prefix);
                                } else {
                                    prefix = path.resolve(this.root, prefix);
                                }
                            }
                            if (process.platform === 'win32')
                                prefix = prefix.replace(/\\/g, '/');
                            this.matches[index] = this.matches[index] || {};
                            this.matches[index][prefix] = true;
                            this.emitMatch(prefix);
                        }
                        return cb();
                    });
                    return;
                case 0:
                    prefix = null;
                    break;
                default:
                    prefix = pattern.slice(0, n);
                    prefix = prefix.join('/');
                    break;
                }
                var read;
                if (prefix === null)
                    read = '.';
                else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
                    if (!prefix || !isAbsolute(prefix)) {
                        prefix = path.join('/', prefix);
                    }
                    read = prefix = path.resolve(prefix);
                    this.log('absolute: ', prefix, this.root, pattern, read);
                } else {
                    read = prefix;
                }
                this.log('readdir(%j)', read, this.cwd, this.root);
                return this._readdir(read, function (er, entries) {
                    if (er) {
                        return cb();
                    }
                    if (pattern[n] === minimatch.GLOBSTAR) {
                        var s = [pattern.slice(0, n).concat(pattern.slice(n + 1))];
                        entries.forEach(function (e) {
                            if (e.charAt(0) === '.' && !this.dot)
                                return;
                            s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)));
                            s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)));
                        }, this);
                        var l = s.length, errState = null;
                        s.forEach(function (gsPattern) {
                            this._process(gsPattern, depth + 1, index, function (er) {
                                if (errState)
                                    return;
                                if (er)
                                    return cb(errState = er);
                                if (--l <= 0)
                                    return cb();
                            });
                        }, this);
                        return;
                    }
                    var pn = pattern[n];
                    if (typeof pn === 'string') {
                        var found = entries.indexOf(pn) !== -1;
                        entries = found ? entries[pn] : [];
                    } else {
                        var rawGlob = pattern[n]._glob, dotOk = this.dot || rawGlob.charAt(0) === '.';
                        entries = entries.filter(function (e) {
                            return (e.charAt(0) !== '.' || dotOk) && (typeof pattern[n] === 'string' && e === pattern[n] || e.match(pattern[n]));
                        });
                    }
                    if (n === pattern.length - 1 && !this.mark && !this.stat) {
                        entries.forEach(function (e) {
                            if (prefix) {
                                if (prefix !== '/')
                                    e = prefix + '/' + e;
                                else
                                    e = prefix + e;
                            }
                            if (e.charAt(0) === '/' && !this.nomount) {
                                e = path.join(this.root, e);
                            }
                            if (process.platform === 'win32')
                                e = e.replace(/\\/g, '/');
                            this.matches[index] = this.matches[index] || {};
                            this.matches[index][e] = true;
                            this.emitMatch(e);
                        }, this);
                        return cb.call(this);
                    }
                    var l = entries.length, errState = null;
                    if (l === 0)
                        return cb();
                    entries.forEach(function (e) {
                        var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1));
                        this._process(p, depth + 1, index, function (er) {
                            if (errState)
                                return;
                            if (er)
                                return cb(errState = er);
                            if (--l === 0)
                                return cb.call(this);
                        });
                    }, this);
                });
            };
            Glob.prototype._stat = function (f, cb) {
                assert(this instanceof Glob);
                var abs = f;
                if (f.charAt(0) === '/') {
                    abs = path.join(this.root, f);
                } else if (this.changedCwd) {
                    abs = path.resolve(this.cwd, f);
                }
                this.log('stat', [
                    this.cwd,
                    f,
                    '=',
                    abs
                ]);
                if (f.length > this.maxLength) {
                    var er = new Error('Path name too long');
                    er.code = 'ENAMETOOLONG';
                    er.path = f;
                    return this._afterStat(f, abs, cb, er);
                }
                if (this.statCache.hasOwnProperty(f)) {
                    var exists = this.statCache[f], isDir = exists && (Array.isArray(exists) || exists === 2);
                    if (this.sync)
                        return cb.call(this, !!exists, isDir);
                    return process.nextTick(cb.bind(this, !!exists, isDir));
                }
                if (this.sync) {
                    var er, stat;
                    try {
                        stat = fs.statSync(abs);
                    } catch (e) {
                        er = e;
                    }
                    this._afterStat(f, abs, cb, er, stat);
                } else {
                    fs.stat(abs, this._afterStat.bind(this, f, abs, cb));
                }
            };
            Glob.prototype._afterStat = function (f, abs, cb, er, stat) {
                var exists;
                assert(this instanceof Glob);
                if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) {
                    this.log('should be ENOTDIR, fake it');
                    er = new Error('ENOTDIR, not a directory \'' + abs + '\'');
                    er.path = abs;
                    er.code = 'ENOTDIR';
                    stat = null;
                }
                if (er || !stat) {
                    exists = false;
                } else {
                    exists = stat.isDirectory() ? 2 : 1;
                }
                this.statCache[f] = this.statCache[f] || exists;
                cb.call(this, !!exists, exists === 2);
            };
            Glob.prototype._readdir = function (f, cb) {
                assert(this instanceof Glob);
                var abs = f;
                if (f.charAt(0) === '/') {
                    abs = path.join(this.root, f);
                } else if (isAbsolute(f)) {
                    abs = f;
                } else if (this.changedCwd) {
                    abs = path.resolve(this.cwd, f);
                }
                this.log('readdir', [
                    this.cwd,
                    f,
                    abs
                ]);
                if (f.length > this.maxLength) {
                    var er = new Error('Path name too long');
                    er.code = 'ENAMETOOLONG';
                    er.path = f;
                    return this._afterReaddir(f, abs, cb, er);
                }
                if (this.statCache.hasOwnProperty(f)) {
                    var c = this.statCache[f];
                    if (Array.isArray(c)) {
                        if (this.sync)
                            return cb.call(this, null, c);
                        return process.nextTick(cb.bind(this, null, c));
                    }
                    if (!c || c === 1) {
                        var code = c ? 'ENOTDIR' : 'ENOENT', er = new Error((c ? 'Not a directory' : 'Not found') + ': ' + f);
                        er.path = f;
                        er.code = code;
                        this.log(f, er);
                        if (this.sync)
                            return cb.call(this, er);
                        return process.nextTick(cb.bind(this, er));
                    }
                }
                if (this.sync) {
                    var er, entries;
                    try {
                        entries = fs.readdirSync(abs);
                    } catch (e) {
                        er = e;
                    }
                    return this._afterReaddir(f, abs, cb, er, entries);
                }
                fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb));
            };
            Glob.prototype._afterReaddir = function (f, abs, cb, er, entries) {
                assert(this instanceof Glob);
                if (entries && !er) {
                    this.statCache[f] = entries;
                    if (!this.mark && !this.stat) {
                        entries.forEach(function (e) {
                            if (f === '/')
                                e = f + e;
                            else
                                e = f + '/' + e;
                            this.statCache[e] = true;
                        }, this);
                    }
                    return cb.call(this, er, entries);
                }
                if (er)
                    switch (er.code) {
                    case 'ENOTDIR':
                        this.statCache[f] = 1;
                        return cb.call(this, er);
                    case 'ENOENT':
                    case 'ELOOP':
                    case 'ENAMETOOLONG':
                    case 'UNKNOWN':
                        this.statCache[f] = false;
                        return cb.call(this, er);
                    default:
                        this.statCache[f] = false;
                        if (this.strict)
                            this.emit('error', er);
                        if (!this.silent)
                            console.error('glob error', er);
                        return cb.call(this, er);
                    }
            };
            var isAbsolute = process.platform === 'win32' ? absWin : absUnix;
            function absWin(p) {
                if (absUnix(p))
                    return true;
                var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/, result = splitDeviceRe.exec(p), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = !!result[2] || isUnc;
                return isAbsolute;
            }
            function absUnix(p) {
                return p.charAt(0) === '/' || p === '';
            }
        });
        _define(145, function (module, exports) {
            if (typeof define !== 'function') {
                var define = require(127)(module, require);
            }
            define(function (require, exports, module) {
                var charToIntMap = {};
                var intToCharMap = {};
                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function (ch, index) {
                    charToIntMap[ch] = index;
                    intToCharMap[index] = ch;
                });
                exports.encode = function base64_encode(aNumber) {
                    if (aNumber in intToCharMap) {
                        return intToCharMap[aNumber];
                    }
                    throw new TypeError('Must be between 0 and 63: ' + aNumber);
                };
                exports.decode = function base64_decode(aChar) {
                    if (aChar in charToIntMap) {
                        return charToIntMap[aChar];
                    }
                    throw new TypeError('Not a valid base 64 digit: ' + aChar);
                };
            });
        });
        _define(146, function (module, exports) {
            var Buffer = require('buffer').Buffer;
            var isBufferEncoding = Buffer.isEncoding || function (encoding) {
                switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                    return true;
                default:
                    return false;
                }
            };
            function assertEncoding(encoding) {
                if (encoding && !isBufferEncoding(encoding)) {
                    throw new Error('Unknown encoding: ' + encoding);
                }
            }
            var StringDecoder = exports.StringDecoder = function (encoding) {
                this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
                assertEncoding(encoding);
                switch (this.encoding) {
                case 'utf8':
                    this.surrogateSize = 3;
                    break;
                case 'ucs2':
                case 'utf16le':
                    this.surrogateSize = 2;
                    this.detectIncompleteChar = utf16DetectIncompleteChar;
                    break;
                case 'base64':
                    this.surrogateSize = 3;
                    this.detectIncompleteChar = base64DetectIncompleteChar;
                    break;
                default:
                    this.write = passThroughWrite;
                    return;
                }
                this.charBuffer = new Buffer(6);
                this.charReceived = 0;
                this.charLength = 0;
            };
            StringDecoder.prototype.write = function (buffer) {
                var charStr = '';
                while (this.charLength) {
                    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
                    buffer.copy(this.charBuffer, this.charReceived, 0, available);
                    this.charReceived += available;
                    if (this.charReceived < this.charLength) {
                        return '';
                    }
                    buffer = buffer.slice(available, buffer.length);
                    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
                    var charCode = charStr.charCodeAt(charStr.length - 1);
                    if (charCode >= 55296 && charCode <= 56319) {
                        this.charLength += this.surrogateSize;
                        charStr = '';
                        continue;
                    }
                    this.charReceived = this.charLength = 0;
                    if (buffer.length === 0) {
                        return charStr;
                    }
                    break;
                }
                this.detectIncompleteChar(buffer);
                var end = buffer.length;
                if (this.charLength) {
                    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                    end -= this.charReceived;
                }
                charStr += buffer.toString(this.encoding, 0, end);
                var end = charStr.length - 1;
                var charCode = charStr.charCodeAt(end);
                if (charCode >= 55296 && charCode <= 56319) {
                    var size = this.surrogateSize;
                    this.charLength += size;
                    this.charReceived += size;
                    this.charBuffer.copy(this.charBuffer, size, 0, size);
                    buffer.copy(this.charBuffer, 0, 0, size);
                    return charStr.substring(0, end);
                }
                return charStr;
            };
            StringDecoder.prototype.detectIncompleteChar = function (buffer) {
                var i = buffer.length >= 3 ? 3 : buffer.length;
                for (; i > 0; i--) {
                    var c = buffer[buffer.length - i];
                    if (i == 1 && c >> 5 == 6) {
                        this.charLength = 2;
                        break;
                    }
                    if (i <= 2 && c >> 4 == 14) {
                        this.charLength = 3;
                        break;
                    }
                    if (i <= 3 && c >> 3 == 30) {
                        this.charLength = 4;
                        break;
                    }
                }
                this.charReceived = i;
            };
            StringDecoder.prototype.end = function (buffer) {
                var res = '';
                if (buffer && buffer.length)
                    res = this.write(buffer);
                if (this.charReceived) {
                    var cr = this.charReceived;
                    var buf = this.charBuffer;
                    var enc = this.encoding;
                    res += buf.slice(0, cr).toString(enc);
                }
                return res;
            };
            function passThroughWrite(buffer) {
                return buffer.toString(this.encoding);
            }
            function utf16DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 2;
                this.charLength = this.charReceived ? 2 : 0;
            }
            function base64DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 3;
                this.charLength = this.charReceived ? 3 : 0;
            }
        });
        _define(147, function (module, exports) {
            module.exports = Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) == '[object Array]';
            };
        });
        _define(148, function (module, exports) {
            exports = module.exports = function (bytes) {
                var i = 0;
                while (i < bytes.length) {
                    if (bytes[i] == 9 || bytes[i] == 10 || bytes[i] == 13 || 32 <= bytes[i] && bytes[i] <= 126) {
                        i += 1;
                        continue;
                    }
                    if (194 <= bytes[i] && bytes[i] <= 223 && (128 <= bytes[i + 1] && bytes[i + 1] <= 191)) {
                        i += 2;
                        continue;
                    }
                    if (bytes[i] == 224 && (160 <= bytes[i + 1] && bytes[i + 1] <= 191) && (128 <= bytes[i + 2] && bytes[i + 2] <= 191) || (225 <= bytes[i] && bytes[i] <= 236 || bytes[i] == 238 || bytes[i] == 239) && (128 <= bytes[i + 1] && bytes[i + 1] <= 191) && (128 <= bytes[i + 2] && bytes[i + 2] <= 191) || bytes[i] == 237 && (128 <= bytes[i + 1] && bytes[i + 1] <= 159) && (128 <= bytes[i + 2] && bytes[i + 2] <= 191)) {
                        i += 3;
                        continue;
                    }
                    if (bytes[i] == 240 && (144 <= bytes[i + 1] && bytes[i + 1] <= 191) && (128 <= bytes[i + 2] && bytes[i + 2] <= 191) && (128 <= bytes[i + 3] && bytes[i + 3] <= 191) || 241 <= bytes[i] && bytes[i] <= 243 && (128 <= bytes[i + 1] && bytes[i + 1] <= 191) && (128 <= bytes[i + 2] && bytes[i + 2] <= 191) && (128 <= bytes[i + 3] && bytes[i + 3] <= 191) || bytes[i] == 244 && (128 <= bytes[i + 1] && bytes[i + 1] <= 143) && (128 <= bytes[i + 2] && bytes[i + 2] <= 191) && (128 <= bytes[i + 3] && bytes[i + 3] <= 191)) {
                        i += 4;
                        continue;
                    }
                    return false;
                }
                return true;
            };
        });
        _define(149, function (module, exports) {
            'use strict';
            var util = require('util');
            var Transform = require('stream').Transform;
            function ctor(options, transform) {
                util.inherits(FirstChunk, Transform);
                if (typeof options === 'function') {
                    transform = options;
                    options = {};
                }
                if (typeof transform !== 'function') {
                    throw new Error('transform function required');
                }
                function FirstChunk(options2) {
                    if (!(this instanceof FirstChunk)) {
                        return new FirstChunk(options2);
                    }
                    Transform.call(this, options2);
                    this._firstChunk = true;
                    this._transformCalled = false;
                    this._minSize = options.minSize;
                }
                FirstChunk.prototype._transform = function (chunk, enc, cb) {
                    this._enc = enc;
                    if (this._firstChunk) {
                        this._firstChunk = false;
                        if (this._minSize == null) {
                            transform.call(this, chunk, enc, cb);
                            this._transformCalled = true;
                            return;
                        }
                        this._buffer = chunk;
                        cb();
                        return;
                    }
                    if (this._minSize == null) {
                        this.push(chunk);
                        cb();
                        return;
                    }
                    if (this._buffer.length < this._minSize) {
                        this._buffer = Buffer.concat([
                            this._buffer,
                            chunk
                        ]);
                        cb();
                        return;
                    }
                    if (this._buffer.length >= this._minSize) {
                        transform.call(this, this._buffer.slice(), enc, function () {
                            this.push(chunk);
                            cb();
                        }.bind(this));
                        this._transformCalled = true;
                        this._buffer = false;
                        return;
                    }
                    this.push(chunk);
                    cb();
                };
                FirstChunk.prototype._flush = function (cb) {
                    if (!this._buffer) {
                        cb();
                        return;
                    }
                    if (this._transformCalled) {
                        this.push(this._buffer);
                        cb();
                    } else {
                        transform.call(this, this._buffer.slice(), this._enc, cb);
                    }
                };
                return FirstChunk;
            }
            module.exports = function () {
                return ctor.apply(ctor, arguments)();
            };
            module.exports.ctor = ctor;
        });
        _define(150, function (module, exports) {
            module.exports = wrappy;
            function wrappy(fn, cb) {
                if (fn && cb)
                    return wrappy(fn)(cb);
                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function');
                Object.keys(fn).forEach(function (k) {
                    wrapper[k] = fn[k];
                });
                return wrapper;
                function wrapper() {
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i];
                    }
                    var ret = fn.apply(this, args);
                    var cb = args[args.length - 1];
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function (k) {
                            ret[k] = cb[k];
                        });
                    }
                    return ret;
                }
            }
        });
        _define(151, function (module, exports) {
            module.exports = wrappy;
            function wrappy(fn, cb) {
                if (fn && cb)
                    return wrappy(fn)(cb);
                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function');
                Object.keys(fn).forEach(function (k) {
                    wrapper[k] = fn[k];
                });
                return wrapper;
                function wrapper() {
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i];
                    }
                    var ret = fn.apply(this, args);
                    var cb = args[args.length - 1];
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function (k) {
                            ret[k] = cb[k];
                        });
                    }
                    return ret;
                }
            }
        });
        _define(152, function (module, exports) {
            module.exports = function (xs, fn) {
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    var x = fn(xs[i], i);
                    if (Array.isArray(x))
                        res.push.apply(res, x);
                    else
                        res.push(x);
                }
                return res;
            };
        });
        _define(153, function (module, exports) {
            module.exports = balanced;
            function balanced(a, b, str) {
                var bal = 0;
                var m = {};
                var ended = false;
                for (var i = 0; i < str.length; i++) {
                    if (a == str.substr(i, a.length)) {
                        if (!('start' in m))
                            m.start = i;
                        bal++;
                    } else if (b == str.substr(i, b.length) && 'start' in m) {
                        ended = true;
                        bal--;
                        if (!bal) {
                            m.end = i;
                            m.pre = str.substr(0, m.start);
                            m.body = m.end - m.start > 1 ? str.substring(m.start + a.length, m.end) : '';
                            m.post = str.slice(m.end + b.length);
                            return m;
                        }
                    }
                }
                if (bal && ended) {
                    var start = m.start + a.length;
                    m = balanced(a, b, str.substr(start));
                    if (m) {
                        m.start += start;
                        m.end += start;
                        m.pre = str.slice(0, start) + m.pre;
                    }
                    return m;
                }
            }
        });
        _define(154, function (module, exports) {
            ;
            (function () {
                if (typeof module === 'object' && module.exports) {
                    module.exports = LRUCache;
                } else {
                    this.LRUCache = LRUCache;
                }
                function hOP(obj, key) {
                    return Object.prototype.hasOwnProperty.call(obj, key);
                }
                function naiveLength() {
                    return 1;
                }
                function LRUCache(options) {
                    if (!(this instanceof LRUCache))
                        return new LRUCache(options);
                    if (typeof options === 'number')
                        options = { max: options };
                    if (!options)
                        options = {};
                    this._max = options.max;
                    if (!this._max || !(typeof this._max === 'number') || this._max <= 0)
                        this._max = Infinity;
                    this._lengthCalculator = options.length || naiveLength;
                    if (typeof this._lengthCalculator !== 'function')
                        this._lengthCalculator = naiveLength;
                    this._allowStale = options.stale || false;
                    this._maxAge = options.maxAge || null;
                    this._dispose = options.dispose;
                    this.reset();
                }
                Object.defineProperty(LRUCache.prototype, 'max', {
                    set: function (mL) {
                        if (!mL || !(typeof mL === 'number') || mL <= 0)
                            mL = Infinity;
                        this._max = mL;
                        if (this._length > this._max)
                            trim(this);
                    },
                    get: function () {
                        return this._max;
                    },
                    enumerable: true
                });
                Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
                    set: function (lC) {
                        if (typeof lC !== 'function') {
                            this._lengthCalculator = naiveLength;
                            this._length = this._itemCount;
                            for (var key in this._cache) {
                                this._cache[key].length = 1;
                            }
                        } else {
                            this._lengthCalculator = lC;
                            this._length = 0;
                            for (var key in this._cache) {
                                this._cache[key].length = this._lengthCalculator(this._cache[key].value);
                                this._length += this._cache[key].length;
                            }
                        }
                        if (this._length > this._max)
                            trim(this);
                    },
                    get: function () {
                        return this._lengthCalculator;
                    },
                    enumerable: true
                });
                Object.defineProperty(LRUCache.prototype, 'length', {
                    get: function () {
                        return this._length;
                    },
                    enumerable: true
                });
                Object.defineProperty(LRUCache.prototype, 'itemCount', {
                    get: function () {
                        return this._itemCount;
                    },
                    enumerable: true
                });
                LRUCache.prototype.forEach = function (fn, thisp) {
                    thisp = thisp || this;
                    var i = 0;
                    for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
                        if (this._lruList[k]) {
                            i++;
                            var hit = this._lruList[k];
                            if (this._maxAge && Date.now() - hit.now > this._maxAge) {
                                del(this, hit);
                                if (!this._allowStale)
                                    hit = undefined;
                            }
                            if (hit) {
                                fn.call(thisp, hit.value, hit.key, this);
                            }
                        }
                };
                LRUCache.prototype.keys = function () {
                    var keys = new Array(this._itemCount);
                    var i = 0;
                    for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
                        if (this._lruList[k]) {
                            var hit = this._lruList[k];
                            keys[i++] = hit.key;
                        }
                    return keys;
                };
                LRUCache.prototype.values = function () {
                    var values = new Array(this._itemCount);
                    var i = 0;
                    for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
                        if (this._lruList[k]) {
                            var hit = this._lruList[k];
                            values[i++] = hit.value;
                        }
                    return values;
                };
                LRUCache.prototype.reset = function () {
                    if (this._dispose && this._cache) {
                        for (var k in this._cache) {
                            this._dispose(k, this._cache[k].value);
                        }
                    }
                    this._cache = Object.create(null);
                    this._lruList = Object.create(null);
                    this._mru = 0;
                    this._lru = 0;
                    this._length = 0;
                    this._itemCount = 0;
                };
                LRUCache.prototype.dump = function () {
                    return this._cache;
                };
                LRUCache.prototype.dumpLru = function () {
                    return this._lruList;
                };
                LRUCache.prototype.set = function (key, value) {
                    if (hOP(this._cache, key)) {
                        if (this._dispose)
                            this._dispose(key, this._cache[key].value);
                        if (this._maxAge)
                            this._cache[key].now = Date.now();
                        this._cache[key].value = value;
                        this.get(key);
                        return true;
                    }
                    var len = this._lengthCalculator(value);
                    var age = this._maxAge ? Date.now() : 0;
                    var hit = new Entry(key, value, this._mru++, len, age);
                    if (hit.length > this._max) {
                        if (this._dispose)
                            this._dispose(key, value);
                        return false;
                    }
                    this._length += hit.length;
                    this._lruList[hit.lu] = this._cache[key] = hit;
                    this._itemCount++;
                    if (this._length > this._max)
                        trim(this);
                    return true;
                };
                LRUCache.prototype.has = function (key) {
                    if (!hOP(this._cache, key))
                        return false;
                    var hit = this._cache[key];
                    if (this._maxAge && Date.now() - hit.now > this._maxAge) {
                        return false;
                    }
                    return true;
                };
                LRUCache.prototype.get = function (key) {
                    return get(this, key, true);
                };
                LRUCache.prototype.peek = function (key) {
                    return get(this, key, false);
                };
                LRUCache.prototype.pop = function () {
                    var hit = this._lruList[this._lru];
                    del(this, hit);
                    return hit || null;
                };
                LRUCache.prototype.del = function (key) {
                    del(this, this._cache[key]);
                };
                function get(self, key, doUse) {
                    var hit = self._cache[key];
                    if (hit) {
                        if (self._maxAge && Date.now() - hit.now > self._maxAge) {
                            del(self, hit);
                            if (!self._allowStale)
                                hit = undefined;
                        } else {
                            if (doUse)
                                use(self, hit);
                        }
                        if (hit)
                            hit = hit.value;
                    }
                    return hit;
                }
                function use(self, hit) {
                    shiftLU(self, hit);
                    hit.lu = self._mru++;
                    self._lruList[hit.lu] = hit;
                }
                function trim(self) {
                    while (self._lru < self._mru && self._length > self._max)
                        del(self, self._lruList[self._lru]);
                }
                function shiftLU(self, hit) {
                    delete self._lruList[hit.lu];
                    while (self._lru < self._mru && !self._lruList[self._lru])
                        self._lru++;
                }
                function del(self, hit) {
                    if (hit) {
                        if (self._dispose)
                            self._dispose(hit.key, hit.value);
                        self._length -= hit.length;
                        self._itemCount--;
                        delete self._cache[hit.key];
                        shiftLU(self, hit);
                    }
                }
                function Entry(key, value, lu, length, now) {
                    this.key = key;
                    this.value = value;
                    this.lu = lu;
                    this.length = length;
                    this.now = now;
                }
            }());
        });
        _define(155, function (module, exports) {
            module.exports = sigmund;
            function sigmund(subject, maxSessions) {
                maxSessions = maxSessions || 10;
                var notes = [];
                var analysis = '';
                var RE = RegExp;
                function psychoAnalyze(subject, session) {
                    if (session > maxSessions)
                        return;
                    if (typeof subject === 'function' || typeof subject === 'undefined') {
                        return;
                    }
                    if (typeof subject !== 'object' || !subject || subject instanceof RE) {
                        analysis += subject;
                        return;
                    }
                    if (notes.indexOf(subject) !== -1 || session === maxSessions)
                        return;
                    notes.push(subject);
                    analysis += '{';
                    Object.keys(subject).forEach(function (issue, _, __) {
                        if (issue.charAt(0) === '_')
                            return;
                        var to = typeof subject[issue];
                        if (to === 'function' || to === 'undefined')
                            return;
                        analysis += issue;
                        psychoAnalyze(subject[issue], session + 1);
                    });
                }
                psychoAnalyze(subject, 0);
                return analysis;
            }
        });
        _define(156, function (module, exports) {
            var fs = exports = module.exports = {};
            fs._originalFs = require('fs');
            Object.getOwnPropertyNames(fs._originalFs).forEach(function (prop) {
                var desc = Object.getOwnPropertyDescriptor(fs._originalFs, prop);
                Object.defineProperty(fs, prop, desc);
            });
            var queue = [], constants = require('constants');
            fs._curOpen = 0;
            fs.MIN_MAX_OPEN = 64;
            fs.MAX_OPEN = 1024;
            function OpenReq(path, flags, mode, cb) {
                this.path = path;
                this.flags = flags;
                this.mode = mode;
                this.cb = cb;
            }
            function noop() {
            }
            fs.open = gracefulOpen;
            function gracefulOpen(path, flags, mode, cb) {
                if (typeof mode === 'function')
                    cb = mode, mode = null;
                if (typeof cb !== 'function')
                    cb = noop;
                if (fs._curOpen >= fs.MAX_OPEN) {
                    queue.push(new OpenReq(path, flags, mode, cb));
                    setTimeout(flush);
                    return;
                }
                open(path, flags, mode, function (er, fd) {
                    if (er && er.code === 'EMFILE' && fs._curOpen > fs.MIN_MAX_OPEN) {
                        fs.MAX_OPEN = fs._curOpen - 1;
                        return fs.open(path, flags, mode, cb);
                    }
                    cb(er, fd);
                });
            }
            function open(path, flags, mode, cb) {
                cb = cb || noop;
                fs._curOpen++;
                fs._originalFs.open.call(fs, path, flags, mode, function (er, fd) {
                    if (er)
                        onclose();
                    cb(er, fd);
                });
            }
            fs.openSync = function (path, flags, mode) {
                var ret;
                ret = fs._originalFs.openSync.call(fs, path, flags, mode);
                fs._curOpen++;
                return ret;
            };
            function onclose() {
                fs._curOpen--;
                flush();
            }
            function flush() {
                while (fs._curOpen < fs.MAX_OPEN) {
                    var req = queue.shift();
                    if (!req)
                        return;
                    switch (req.constructor.name) {
                    case 'OpenReq':
                        open(req.path, req.flags || 'r', req.mode || 511, req.cb);
                        break;
                    case 'ReaddirReq':
                        readdir(req.path, req.cb);
                        break;
                    case 'ReadFileReq':
                        readFile(req.path, req.options, req.cb);
                        break;
                    case 'WriteFileReq':
                        writeFile(req.path, req.data, req.options, req.cb);
                        break;
                    default:
                        throw new Error('Unknown req type: ' + req.constructor.name);
                    }
                }
            }
            fs.close = function (fd, cb) {
                cb = cb || noop;
                fs._originalFs.close.call(fs, fd, function (er) {
                    onclose();
                    cb(er);
                });
            };
            fs.closeSync = function (fd) {
                try {
                    return fs._originalFs.closeSync.call(fs, fd);
                } finally {
                    onclose();
                }
            };
            fs.readdir = gracefulReaddir;
            function gracefulReaddir(path, cb) {
                if (fs._curOpen >= fs.MAX_OPEN) {
                    queue.push(new ReaddirReq(path, cb));
                    setTimeout(flush);
                    return;
                }
                readdir(path, function (er, files) {
                    if (er && er.code === 'EMFILE' && fs._curOpen > fs.MIN_MAX_OPEN) {
                        fs.MAX_OPEN = fs._curOpen - 1;
                        return fs.readdir(path, cb);
                    }
                    cb(er, files);
                });
            }
            function readdir(path, cb) {
                cb = cb || noop;
                fs._curOpen++;
                fs._originalFs.readdir.call(fs, path, function (er, files) {
                    onclose();
                    cb(er, files);
                });
            }
            function ReaddirReq(path, cb) {
                this.path = path;
                this.cb = cb;
            }
            fs.readFile = gracefulReadFile;
            function gracefulReadFile(path, options, cb) {
                if (typeof options === 'function')
                    cb = options, options = null;
                if (typeof cb !== 'function')
                    cb = noop;
                if (fs._curOpen >= fs.MAX_OPEN) {
                    queue.push(new ReadFileReq(path, options, cb));
                    setTimeout(flush);
                    return;
                }
                readFile(path, options, function (er, data) {
                    if (er && er.code === 'EMFILE' && fs._curOpen > fs.MIN_MAX_OPEN) {
                        fs.MAX_OPEN = fs._curOpen - 1;
                        return fs.readFile(path, options, cb);
                    }
                    cb(er, data);
                });
            }
            function readFile(path, options, cb) {
                cb = cb || noop;
                fs._curOpen++;
                fs._originalFs.readFile.call(fs, path, options, function (er, data) {
                    onclose();
                    cb(er, data);
                });
            }
            function ReadFileReq(path, options, cb) {
                this.path = path;
                this.options = options;
                this.cb = cb;
            }
            fs.writeFile = gracefulWriteFile;
            function gracefulWriteFile(path, data, options, cb) {
                if (typeof options === 'function')
                    cb = options, options = null;
                if (typeof cb !== 'function')
                    cb = noop;
                if (fs._curOpen >= fs.MAX_OPEN) {
                    queue.push(new WriteFileReq(path, data, options, cb));
                    setTimeout(flush);
                    return;
                }
                writeFile(path, data, options, function (er) {
                    if (er && er.code === 'EMFILE' && fs._curOpen > fs.MIN_MAX_OPEN) {
                        fs.MAX_OPEN = fs._curOpen - 1;
                        return fs.writeFile(path, data, options, cb);
                    }
                    cb(er);
                });
            }
            function writeFile(path, data, options, cb) {
                cb = cb || noop;
                fs._curOpen++;
                fs._originalFs.writeFile.call(fs, path, data, options, function (er) {
                    onclose();
                    cb(er);
                });
            }
            function WriteFileReq(path, data, options, cb) {
                this.path = path;
                this.data = data;
                this.options = options;
                this.cb = cb;
            }
            var constants = require('constants');
            if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
                fs.lchmod = function (path, mode, callback) {
                    callback = callback || noop;
                    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        fs.fchmod(fd, mode, function (err) {
                            fs.close(fd, function (err2) {
                                callback(err || err2);
                            });
                        });
                    });
                };
                fs.lchmodSync = function (path, mode) {
                    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
                    var err, err2;
                    try {
                        var ret = fs.fchmodSync(fd, mode);
                    } catch (er) {
                        err = er;
                    }
                    try {
                        fs.closeSync(fd);
                    } catch (er) {
                        err2 = er;
                    }
                    if (err || err2)
                        throw err || err2;
                    return ret;
                };
            }
            if (!fs.lutimes) {
                if (constants.hasOwnProperty('O_SYMLINK')) {
                    fs.lutimes = function (path, at, mt, cb) {
                        fs.open(path, constants.O_SYMLINK, function (er, fd) {
                            cb = cb || noop;
                            if (er)
                                return cb(er);
                            fs.futimes(fd, at, mt, function (er) {
                                fs.close(fd, function (er2) {
                                    return cb(er || er2);
                                });
                            });
                        });
                    };
                    fs.lutimesSync = function (path, at, mt) {
                        var fd = fs.openSync(path, constants.O_SYMLINK), err, err2, ret;
                        try {
                            var ret = fs.futimesSync(fd, at, mt);
                        } catch (er) {
                            err = er;
                        }
                        try {
                            fs.closeSync(fd);
                        } catch (er) {
                            err2 = er;
                        }
                        if (err || err2)
                            throw err || err2;
                        return ret;
                    };
                } else if (fs.utimensat && constants.hasOwnProperty('AT_SYMLINK_NOFOLLOW')) {
                    fs.lutimes = function (path, at, mt, cb) {
                        fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb);
                    };
                    fs.lutimesSync = function (path, at, mt) {
                        return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW);
                    };
                } else {
                    fs.lutimes = function (_a, _b, _c, cb) {
                        process.nextTick(cb);
                    };
                    fs.lutimesSync = function () {
                    };
                }
            }
            fs.chown = chownFix(fs.chown);
            fs.fchown = chownFix(fs.fchown);
            fs.lchown = chownFix(fs.lchown);
            fs.chownSync = chownFixSync(fs.chownSync);
            fs.fchownSync = chownFixSync(fs.fchownSync);
            fs.lchownSync = chownFixSync(fs.lchownSync);
            function chownFix(orig) {
                if (!orig)
                    return orig;
                return function (target, uid, gid, cb) {
                    return orig.call(fs, target, uid, gid, function (er, res) {
                        if (chownErOk(er))
                            er = null;
                        cb(er, res);
                    });
                };
            }
            function chownFixSync(orig) {
                if (!orig)
                    return orig;
                return function (target, uid, gid) {
                    try {
                        return orig.call(fs, target, uid, gid);
                    } catch (er) {
                        if (!chownErOk(er))
                            throw er;
                    }
                };
            }
            function chownErOk(er) {
                if (!er || (!process.getuid || process.getuid() !== 0) && (er.code === 'EINVAL' || er.code === 'EPERM'))
                    return true;
            }
            if (!fs.lchmod) {
                fs.lchmod = function (path, mode, cb) {
                    process.nextTick(cb);
                };
                fs.lchmodSync = function () {
                };
            }
            if (!fs.lchown) {
                fs.lchown = function (path, uid, gid, cb) {
                    process.nextTick(cb);
                };
                fs.lchownSync = function () {
                };
            }
            if (process.platform === 'win32') {
                var rename_ = fs.rename;
                fs.rename = function rename(from, to, cb) {
                    var start = Date.now();
                    rename_(from, to, function CB(er) {
                        if (er && (er.code === 'EACCES' || er.code === 'EPERM') && Date.now() - start < 1000) {
                            return rename_(from, to, CB);
                        }
                        cb(er);
                    });
                };
            }
            var read = fs.read;
            fs.read = function (fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === 'function') {
                    var eagCounter = 0;
                    callback = function (er, _, __) {
                        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            return read.call(fs, fd, buffer, offset, length, position, callback);
                        }
                        callback_.apply(this, arguments);
                    };
                }
                return read.call(fs, fd, buffer, offset, length, position, callback);
            };
            var readSync = fs.readSync;
            fs.readSync = function (fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while (true) {
                    try {
                        return readSync.call(fs, fd, buffer, offset, length, position);
                    } catch (er) {
                        if (er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            continue;
                        }
                        throw er;
                    }
                }
            };
        });
        _define(157, function (module, exports) {
            module.exports = inherits;
            function inherits(c, p, proto) {
                proto = proto || {};
                var e = {};
                [
                    c.prototype,
                    proto
                ].forEach(function (s) {
                    Object.getOwnPropertyNames(s).forEach(function (k) {
                        e[k] = Object.getOwnPropertyDescriptor(s, k);
                    });
                });
                c.prototype = Object.create(p.prototype, e);
                c.super = p;
            }
        });
    }
    function require(id) {
        if (id in loadedModules) {
            return loadedModules[id].exports;
        }
        if (!(id in modulesFactories)) {
            throw new Error('Module "' + id + '" not found.');
        }
        var exports = {};
        var module = {
            exports: exports,
            id: id
        };
        var factory = modulesFactories[id];
        loadedModules[id] = module;
        factory(module, exports);
        return module.exports;
    }
    function _define(id, factory) {
        modulesFactories[id] = factory;
    }
}
(function (root, factory) {
    var exported = factory();
    if (typeof define === 'function' && define.amd) {
        define('crafter-0_1_0', [], function () {
            return exported;
        });
    } else if (typeof exports === 'object') {
        module.exports = exported;
    } else {
        root['crafter-0_1_0'] = factory();
    }
}(this, module_preamble));